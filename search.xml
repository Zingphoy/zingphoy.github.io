<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019清明节</title>
    <url>/2019/04/05/2019%E6%B8%85%E6%98%8E%E8%8A%82/</url>
    <content><![CDATA[<p>2019年第一个假期，一年一度的清明节，我妈提前告诉我要周四休假回家，周五一定要爬山祭祖不能再拖，最晚清明节当天扫墓，一再强调传统里没有人会清明节之后才扫墓。在这样的”命令”下，周四我从深圳坐大巴出发，在路上折腾了7.5小时后才到家里，睡一晚在清明节当天中午12点多就回村子准备爬山锄草扫墓。</p>
<p>老家这边还是相当传统的，只是一个小镇，老人去世了都会选择回到乡下下葬，提前找看风水的挑一个山头找个位子当自己的坟墓，去世之后火化将骨灰埋在乡下山头。清明节放假之前还跟来自五湖四海的同事说了我们这边的传统，估计现在还会爬山亲手用锄头镰刀锄草割草扫墓拜祭的人已经不多了，城里的都会选择公墓，去到直接放点花啊水果啊烧个纸钱就可以了，这边可不会这么简单。传统流程是要爬山，山里的墓（或者称为坟头）过了一年遍地是草，可别说草可以长到膝盖那么高，要扛着锄头镰刀爬上山头找到坟墓，把所有的草除掉，然后摆好蜡烛、香、各种拜祭用的食物，拜祭完再烧纸钱，最后放一个鞭炮，这才算结束，最后得收拾和检查鞭炮是否彻底熄灭，<strong><em>谨防山火，要不牢底坐穿</em></strong>。</p>
<p><strong>多图预警。</strong></p>
<a id="more"></a>

<h3 id="村里"><a href="#村里" class="headerlink" title="村里"></a>村里</h3><p>12点半左右到村里，iphone信号直接变成 <code>E</code> ，无法登录微信收发信息，只能打电话。村里依然比较原始，也是这几年来才陆续接上自来水，现在村里加起来可能也不够十户人家了，农村$\to$小镇$\to$当地城市$\to$大城市$\to$一线城市→出国 的趋势无可逆转，村里已经见不到年轻人了。</p>
<p>正宗走地鸡😌。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%9D%91%E9%87%8C.jpg" alt="正宗走地鸡😌"></p>
<p>破烂的泥田拖拉机。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%A0%B4%E7%83%82%E7%9A%84%E6%B3%A5%E7%94%B0%E6%8B%96%E6%8B%89%E6%9C%BA.jpg" alt="破烂的泥田拖拉机"></p>
<p>黄牛和水牛是农村里最常见的生物之一，我长这么大还没摸过一次😅。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E9%BB%84%E7%89%9B.jpg" alt="黄牛和水牛是农村里最常见的生物之一，我长这么大还没摸过一次😅"></p>
<h3 id="山里"><a href="#山里" class="headerlink" title="山里"></a>山里</h3><h4 id="山头1"><a href="#山头1" class="headerlink" title="山头1"></a>山头1</h4><p>在村里简单准备一下后，4个人扛着3个锄头一把锯子就往山里出发了，把第一个最远最难搞的坟墓给拜祭了。带路的长辈认错路，以往爬上山头虽然要翻草丛，不过还是会有一条人常走的小路留出来的，这一次走着走着不知道路在哪里，我作为队伍最强壮的年轻人(一个50岁的叔叔，一个在读大学的1米5+小女生，一个在读初三的男孩)，扛着锄头，锄柄上还挂着两瓶大瓶怡宝，用肉体在前面开路，一脚深一角浅，靠蛮力把草和树枝给踩下去，那种感觉估计跟绑着大轮胎走路差不多了。每一脚都缠上很多长得跟人一样高的叫不出名字的杂草，有一些还特别坚韧，横在路上扯着你的大腿摆脱不了完全无法向前再挪一步，就像缠上蜘蛛网一样，只能停下来稍稍后退高抬起脚把它踩下去才能通过。有时候脚下不知道怎么横着一跟大木头，直接绊倒，整个人趴在草丛上的感觉，又热又闷，长年没翻过的草丛满是尘，吸一口神清气爽，我甚至把小树叶都给吸到喉咙里，很难受😷。</p>
<p>钻完草丛裤子就变成这样了😶。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E9%92%BB%E8%8D%89%E4%BB%8E.jpg" alt="钻草从"></p>
<p>山里往下拍的感觉，iphone7就给拍成这样了，拍不出人眼看到的绿色。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%B1%B1%E9%87%8C.jpg" alt="山里"></p>
<p>我们上来之后，后面的几个长辈挑着担子把拜祭用的东西挑上来了，包括纸钱、元宝蜡烛、米酒、筷子杯子、烧鹅、甘蔗、鸡蛋、各种糍……墓前的草都已经末膝盖了，还有一颗树倒了下来压在旁边，几个长辈又是锯又是搬才把它推走。作为新生代爬山扫墓主力，基本上手里不是锄头就是柴草，锄累了就搬杂草扔掉，恢复十分钟拿过锄头继续干，我右手都给磨出一个小水泡来了😂。顶着太阳一路干，真的有榨干的感觉，锄不到5分钟就得休息一下，体力流失很快，两个学生就站在一旁看着，果然爬山锄草这种粗活，还是由我们这些长辈(包括我)来干。我也是这几年来才开始接收锄草工作，好多操作和术语都听不懂，浑身除了蛮力之外也没什么排得上用场的东西，不过还是要尽量输出一下自己的力量多做点贡献。</p>
<p> 一路“披荆斩棘”的山路，看一下根本不知道路在哪里😅，偶尔会出现一些比较好走的地方，那是别人先前走过的，要找自家祖先的墓，走的路基本要自己开辟一次。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%8D%89%E4%B8%9B.jpg" alt="草丛"></p>
<h4 id="山头2"><a href="#山头2" class="headerlink" title="山头2"></a>山头2</h4><p>小分队过来把最远最高的山头墓给拜祭完了，把东西扛回村里接着下一个山头，一共有5个地方要去，这才把第一个给整完了，不过剩下4个家里花钱叫人帮我们给锄草了，很专业，也很便宜，500元清理4个墓（绝对友情价），两人干了两天，要是让我来干double价格我都要考虑一下🤔。挑担子可以说真的很难受，担子两端绑着的篮子甩来甩去的，挑久了肩膀还会被摩擦得很痛，沉是一回事，但是摩擦到痛就不能忍了，不停在两个肩膀换来换去，直到都给摩擦到通红，皮都擦掉了，摸一下有股辛辣的感觉，就是痛🙄。</p>
<p>担子另一端还提着一个篮子，像我这种N年不碰重活的，胆子卡在肩膀上是挺痛的。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%8C%91%E6%8B%85%E5%AD%90.jpg" alt="挑担子"></p>
<h4 id="山头-x"><a href="#山头-x" class="headerlink" title="山头$x$"></a>山头$x$</h4><p>这是最后一个了，一天搞下来已经5点，晒到脖子都痛(我真的很容易晒伤🙄)。山里被人开发，树全都锯掉了，可以看到跟之前的照片对比这里就是光秃秃的，长辈们说这挺好的，这样这个山头以后清明就更好走了，我心里的滋味倒是不一样，不知道以后这一片山林会不会就这样慢慢消失……</p>
<p>这里过去原本是个茂密的山林，最近几个月出现了开发商承包山头不知道搞什么开发，现在看过去什么都没有了，整个山体都是裸露出来的，肉眼可见的山地，没有树木挺立起来。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%8E%9F%E6%9C%AC%E6%98%AF%E4%B8%AA%E8%8C%82%E5%AF%86%E7%9A%84%E5%B1%B1%E6%9E%97.jpg" alt="原本是个茂密的山林"></p>
<hr>
<p>一天下来所有的墓终于都拜祭完了，按照我们的方言叫【所有嗰山都行完了】，大伙凑在一起就可以狂吃一通了。一个亲戚说，<strong>在外面工作做梦都想吃这些，然而现在吃几块又腻了</strong>🤣，全场爆笑。里面的不少东西在儿时一点都不喜欢，觉得那是大人才喜欢的东西，现在越是长大越是发现自己喜欢吃，这是一个魔咒？在深圳是不可能吃得到的，所以这些地方食物基本是一年只能吃一次。吃的时候有个亲戚又挑起话题问我怎么不带女朋友过来爬山，有个女朋友而已又不是我中了100万彩票，我就是要带别人也不愿意来呀🤣。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%87%86%E5%A4%87%E5%88%87%E8%82%89.jpeg" alt="准备切肉"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%88%87%E8%82%89ing.jpg" alt="切肉ing"></p>
<p>袋子里装的是我的最爱：糖水糍、白松膏、软饼(从左到右的方言称呼) ，其中前两者在顺德又叫伦教糕，引入到我老家再经过口味改良就变成爬山祭祖专用的食物了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%88%91%E7%9A%84%E6%9C%80%E7%88%B1.jpg" alt="我的最爱"></p>
<p>再补几张路过时留下来的照片，留个念想，感受一下那慢腾腾又很规律的生活⏱。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%B0%8F%E8%B7%AF.jpg" alt="小路"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%94%B0%E9%87%8E1.jpg" alt="田野1"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%94%B0%E9%87%8E2.jpg" alt="田野2"></p>
<p>留意到远处的山头也变得光秃了……开发商的功劳。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>爬了半天的山，一年一度的清明节就这样结束。按照我们家的习惯晚饭都会在大排档一起解决，毕竟搞得这么累谁还想回去做饭，我做了个小程序员老妈好像特别自豪一样说今天让我请大伙吃饭，我😕？？？</p>
<p>先回家洗个澡，家里干净的地边被脏兮兮的我一踩就黑掉了，脱下鞋子终于可以安静地坐下来，把里面的树叶沙子给倒出来，在爬山的时候一只脚还陷到泥水坑里不过幸好没怎么进水，只是表面湿了。</p>
<p>两双鞋这样摆在一起，左边那双是今天爬山穿的，高中时候的旧鞋，右边那双是从深圳穿回来的，平时穿着上班。我看到了两个”我”，一个是作为父母儿子，希望父母安好开心的一面；另一个是在深圳发展职业生涯，一心想成为某个领域技术专家的一面。</p>
<blockquote>
<p><strong>人的本质是一切社会关系的总和。</strong></p>
<div align="right">——马克思</div>
</blockquote>
<p>回到老家想父母开心，我总是会潜意识想方设法多讲一些好玩的东西让父母笑，老妈说，每次我就快要回家的时候，老爸就跟她说很开心很开心，自己在深圳发展职业，走了程序员这条路就注定最后是不可能回老家发展的，时间上确实没办法多陪老人，总是想着在其他方面弥补。比如多买一些东西给父母用用，时间这块补不上来了，真的只能用物质来补；多教教他们用手机，让他们跟得上时代；多跟他们讲讲微信，让他们知道我在这边一切安好……</p>
<p>深漂，虽然从事的工作岗位没有说得上喜欢，但是也尽量在业余时间让起步落后于别人的自己多充电，趁着热情还在多多学习和实践，当然那一面我是不会跟父母说太多的，毕竟也不是什么健康的生活习惯。自己能做的就是驱使自己更多更高效目的更明确地野蛮生长，希望在未来可以有充分的物质生活，才能让父母享受到跟他们现在辛苦程度相匹配的快乐晚年生活。</p>
<img src="/2019/04/05/2019清明节/两个我.jpg" title="两个“我“">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>假期</tag>
        <tag>感想</tag>
        <tag>记录</tag>
        <tag>家乡</tag>
      </tags>
  </entry>
  <entry>
    <title>Code Review落地方案</title>
    <url>/2020/05/31/Code%20Review%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>本文首发于我的<a href="https://zingphoy.github.io/"><strong>个人博客</strong></a>。</p>
<p>之前的博文也写过两篇关于Code Review的文章，出发点的各不相同：</p>
<ul>
<li><p><a href="https://zingphoy.github.io/2019/12/12/QA测试是否要看代码/"><strong>QA测试是否要看代码</strong></a>——QA读产品代码的必要性</p>
</li>
<li><p><a href="https://zingphoy.github.io/2020/03/26/Code-review的思考/"><strong>Code Review的思考</strong></a>——Code Review存在的必要性</p>
</li>
<li><p><a href="https://zingphoy.github.io/2019/11/24/阅读代码小感/"><strong>阅读代码小感</strong></a>——阅读代码的一些方法论</p>
</li>
</ul>
<p>似乎Code Review相关的话题特别容易水文章😅。其实网上有很多介绍Code Review的流程介绍，中英资料都不缺少，但是并没有一个更加系统的文章来阐述一个完整可行的Code Review方案，具体到流程的每一个环节。</p>
<p>相比于再水一篇烂大街的《如何做Code Review》，梳理一篇更系统的Code Review落地方案，给有需要的同学提供参考似乎更有趣也更有意义。本着这样的想法，我从QA的视野，尝试从研发效率的角度整理一些经验以及想法，其中有不少灵感是来源于当前所在的研发团队正在落地的Code Review方案，Code Review后面简称CR。</p>
<hr>
<h2 id="Code-Review-背景"><a href="#Code-Review-背景" class="headerlink" title="Code Review 背景"></a>Code Review 背景</h2><p>大家都知道Bug越早被发现，修复成本越低，各种自动化检查就是尽可能地让测试左移，在研发流程早期发现Bug。按照这个思路从研发流程的角度看，先有RD自测，然后是RD的提交代码前后的单元测试，接下来是代码合入主干分支触发的自动化测试以及CR。先抛开RD的自测与单测不说，这两个点想要做好时常难度较大，需要很强的推动力。那从这个角度看，代码合入主干分支的时间点基本上是外界介入测试的最早阶段，而CR正是一种早期发现Bug的手段，自然而然可以融合进来。</p>
<p>另一方面，CR落地情况体现了一个研发团队的工程氛围，新人很容易通过CR获得技术提升；同时，CR提升了大家对同一个模块的熟悉度，避免一个模块只有单一同学了解，防止人员流动导致代码开发维护上的真空期，好比分布式系统是不希望出现单点，master节点要随时可被替代一样，否则系统出现故障的概率就变高。</p>
<p>更进一步，线上事故经常有，我们的QA联合RD对一系列线上事故做分析之后，发现很多造成事故的Bug都具备在CR阶段被发现的可能性（当然不是100%能被发现）。</p>
<p>综上三点，已经阐述了Code Review的必要性。</p>
<hr>
<h2 id="QA如何做-Code-Review"><a href="#QA如何做-Code-Review" class="headerlink" title="QA如何做 Code Review"></a>QA如何做 Code Review</h2><p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/communicate.jpg" alt="Code Review"></p>
<h3 id="QA为何难以参与CR"><a href="#QA为何难以参与CR" class="headerlink" title="QA为何难以参与CR"></a>QA为何难以参与CR</h3><p>很多QA可能觉得CR是RD的工作，跟QA没有关系，这是片面的。CR确实是RD主导，但也不失为QA贯彻测试左移原则一个好的切入点，还能顺便看看产品代码从细节上熟悉被测对象，何乐而不为？</p>
<p>个人感觉QA难以在CR中体现出参与感的一个最关键的点，可能是很多QA本身缺少一定的代码经验或白盒测试思维导致CR参与度低，换句话说，就是缺少做CR经验和方法论，这些都是可以通过实践去积累的。老QA员工就不看重CR，上梁不正下梁歪，新来的QA同学很可能也不会看重CR。另一方面，确实是日常需求测试比较重，尤其是客户端（移动端和Web端）的同学，业务压力大，是客观现象，这就不在这里做讨论了。私以为，一个好QA，除了充当流程规范的把关者外，技术能力是不应该跟RD相差太远的。</p>
<p>我所在的QA团队做CR也一直有问题，如下：</p>
<ul>
<li>业务类需求（泛指常规具备交互因素的功能），大多数都是需求完成测试后才发起CR，CR的时间节点过于滞后，导致CR发现问题改代码后又缺失测试环节。正确做法应该在测试前或者测试中完成CR，或CR修改完后复测</li>
</ul>
<ul>
<li><p>技术类需求（泛指代码优化或UI不好体现的功能），QA没有参与需求前期阶段，在不清楚上下文的情况下被RD拉进去对陌生功能模块进行CR，没有效果</p>
</li>
<li><p>鉴于上面两点，QA很难发挥真正的合码卡口质量担保的作用，也没办法建立RD对QA在技术上的认可度，QA的CR流于形式（甚至RD的CR也是）</p>
</li>
</ul>
<h3 id="QA视角的CR目标"><a href="#QA视角的CR目标" class="headerlink" title="QA视角的CR目标"></a>QA视角的CR目标</h3><p>最终目标都是质量保障，CR是一种测试左移的手段，意图在测试前期发现Bug，降低Bug修复的成本。QA视角的CR其实是对RD视角的CR做补充，在关注点上会有区别。<strong>QA是以发现代码中的质量缺陷为首要目标，也就是找Bug，而不是代码是否优雅或代码有无更优实现方式</strong>。</p>
<h3 id="QA的CR准则"><a href="#QA的CR准则" class="headerlink" title="QA的CR准则"></a>QA的CR准则</h3><p>要明白QA在CR中扮演的角色，CR的关注点可以很多，如：代码设计、可维护性、可扩展性、安全、性能等，但并非要求QA面面俱到，作为质量把控的角色，QA应该更集中在功能实现和代码健壮性上。</p>
<h4 id="1-不纠结编码风格"><a href="#1-不纠结编码风格" class="headerlink" title="1. 不纠结编码风格"></a>1. <strong>不纠结编码风格</strong></h4><blockquote>
<ul>
<li>理想情况下，编码风格的把关应该交由专门工具（各种lint）或RD自己保证，QA的主要精力应该在代码逻辑上而非命名风格、函数长度、函数返回值等这类规范细节上。</li>
</ul>
</blockquote>
<h4 id="2-明确-Change-List"><a href="#2-明确-Change-List" class="headerlink" title="2. 明确 Change List"></a>2. <strong>明确 Change List</strong></h4><blockquote>
<ul>
<li>改动范围是QA判断CR策略的核心信息，QA对代码本身以及模块设计的熟悉度肯定不及RD，在CR时需要获取更多辅助信息协助CR。</li>
<li>知悉改动范围可以在业务知识上先行识别代码风险，然后根据风险点从代码层面上逐个排查——可以理解为QA根据改动先设计 <strong><em>CR用例</em></strong>，再拿具体代码对着 <strong><em>CR用例</em></strong> 来找Bug，如针对一段循环逻辑，QA基于业务知识知道循环的结束条件，再结合具体实现寻找是否存在导致死循环的潜在条件场景。</li>
<li>Double check附带的说明文档，以防理解错误或遗漏信息。</li>
</ul>
</blockquote>
<h4 id="3-思考Bug在哪里"><a href="#3-思考Bug在哪里" class="headerlink" title="3. 思考Bug在哪里"></a>3. <strong>思考Bug在哪里</strong></h4><blockquote>
<ul>
<li>请跟我默念：<strong>什么场景下这块代码会出Bug</strong>。QA CR关键是要做思维切换 —— <strong>尽量刻意遍历、覆盖可能出Bug的场景</strong>。而不是顺着代码逻辑看下去有没有疑点，可能就被RD的思维同化了。比如看到一个if判断，就要思考这个判断变量的边界值、触发场景等。</li>
<li>得先理解RD的实现思路，可能还是要顺着RD的思路先过一遍，理清功能细节与调用关系，再转换思维重看一遍。</li>
</ul>
</blockquote>
<h4 id="4-疑问找RD解答"><a href="#4-疑问找RD解答" class="headerlink" title="4. 疑问找RD解答"></a>4. <strong>疑问找RD解答</strong></h4><blockquote>
<ul>
<li>尤其是对于技术需求，大多数情况下不能保证QA的前期参与，QA不清楚需求背景与代码设计，存在严重信息不对称，无法google解决的疑问不要花太多时间琢磨，直接问RD的效率更高。</li>
<li>不要觉得问实现相关的问题很羞耻，RD之间review代码都要互相了解实现细节，QA就更不用说了，比如特殊实现手法、语言高级特性、改动点涉及的调用关系等，都能找RD解答。</li>
<li>如果大范围看不懂且该CR很重要，果断找RD当面了解，或远程语音。</li>
</ul>
</blockquote>
<h4 id="5-严格控制时间花销"><a href="#5-严格控制时间花销" class="headerlink" title="5. 严格控制时间花销"></a>5. <strong>严格控制时间花销</strong></h4><blockquote>
<ul>
<li>保证CR的速度，把控时间花销，很重要！！！特别是一个QA对接好多RD的需求这种现状，如果集成代码那天来5个Merge Request，一次CR半小时，那当天就没了快一半的时间（算上任务切换的耗时）。QA做CR以走读为主，关键代码细看即可，不必每行都看懂。</li>
<li>不同的需求对CR要求不一样，平台强相关的进阶技术、大范围多文件改动、基于复杂功能的调整、UI需求等QA可能较难review，建议粗粒度CR；对于CR更友好的需求，如新增一个依赖少的独立小功能，QA可以获取到完整的上下文，应该多花一些时间CR。</li>
<li>CR来的时间不合适，考虑换一个具备相关能力的QA同学review。</li>
</ul>
</blockquote>
<h4 id="6-可以给RD提建议"><a href="#6-可以给RD提建议" class="headerlink" title="6. 可以给RD提建议"></a>6. <strong>可以给RD提建议</strong></h4><blockquote>
<ul>
<li>觉得存在遗漏的场景或未知风险的代码，应该指出来，可能是不知悉代码上下文带来的误判，也有可能是真的有问题！</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/do_CR_right.jpg" alt="do CR right"></p>
<h3 id="QA做CR的一些经验"><a href="#QA做CR的一些经验" class="headerlink" title="QA做CR的一些经验"></a>QA做CR的一些经验</h3><p>RD做CR更多的是从风格、代码设计、注释、功能、性能、安全、可维护性、等各种维度下手，QA做CR更多是从功能、异常处理、性能、可测性方面下手，关注点会比RD少但是更集中。一般可以根据代码Diff，顺着数据流转链路往前后延伸走读，下面列举一些经验性的关注点。</p>
<p><strong>可以让RD当面解释数据流转过程，有奇效。</strong></p>
<hr>
<p><strong>🚨 QA重要考点</strong> </p>
<blockquote>
<ul>
<li>正确初始化</li>
<li>弱网、断网、失败</li>
<li>缓存清理、缓存失效</li>
<li>持久化数据被删</li>
<li>变量判空</li>
<li>越界</li>
<li>循环结束条件</li>
<li>数据格式与类型非预期（常见服务端线上事故）</li>
<li>锁获取：饿死、死锁</li>
<li>阻塞与非阻塞、同步还是异步</li>
<li>内存/资源泄露，尤其是异常逻辑</li>
<li>隐式类型转换</li>
<li>上下游接口明确</li>
<li>实现方案有缺陷</li>
<li>安全问题（如关键信息明文持久化）</li>
<li>ab实验相关代码要了解开实验的详情</li>
</ul>
</blockquote>
<p>一个简单却又经常被忽略的辅助信息：<strong>历史commit message</strong>。</p>
<hr>
<h3 id="代码可测性"><a href="#代码可测性" class="headerlink" title="代码可测性"></a>代码可测性</h3><p>如果需要QA做具体测试的需求，还要关注一下<a href="https://zingphoy.github.io/2019/12/06/程序可测性/"><strong>代码程序的可测性</strong></a>。</p>
<ul>
<li>可验证性<ul>
<li>添加必要的日志</li>
<li>因输入导致变更的点就是输出，输出全部可查看（正例：中间数据的落盘）</li>
<li>提示信息可读，意义明确且唯一（反例：返回码意义不明确且多个不同错误用同一个返回码）</li>
</ul>
</li>
<li>可操作性<ul>
<li>简化测试准备和测试清理工作（正例：几个标志组合的判断条件，可一键完成标志设置，不需要人工操作场景完成设置）</li>
<li>测试过程有易用的配套工具</li>
</ul>
</li>
<li>可控制性<ul>
<li>所有影响输出的因素都可控（反例：难以构造的死锁现场；难以构造的内部异常）</li>
<li>可直接控制中间状态的数据</li>
</ul>
</li>
<li>可分解性<ul>
<li>大系统中可以针对小模块独立测试</li>
</ul>
</li>
<li>可理解性<ul>
<li>文档明确且随时update</li>
<li>提供修改背景和影响范围</li>
</ul>
</li>
</ul>
<h3 id="CR例子"><a href="#CR例子" class="headerlink" title="CR例子"></a>CR例子</h3><p>这里给一些简单例子，可能不严谨，体会到意思即可。</p>
<p>一、变量没有初始化即使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意java基本类型默认有初始值，但是赋初值还是个好习惯</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">uploadData(a);</span><br></pre></td></tr></table></figure>

<br>
二、代码不符本意

<p>mainDic已经初始化，if 判空逻辑永远为True，应该是 mainDic.count</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *mainDic = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">if (mainDic)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
三、异常情况遗漏处理 或 处理不完善

<p>如断网弱网重试、异常抛出未catch、变量不判空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件资源在抛异常时没有close，资源泄露</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">""</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  out.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
四、循环结束判断条件错误

<p>喜闻乐见你懂的，不用举例了。</p>
<br>
五、手误写错变量名、函数名

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rulesForA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rulesForB</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B()</span><br><span class="line">rulesForA(b);   <span class="comment">//  手误写错变量名or函数名</span></span><br><span class="line">rulesForB(a);</span><br></pre></td></tr></table></figure>

<br>
六、全局变量与局部变量混淆使用

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    a += <span class="number">1</span>;   <span class="comment">// 可能本意是对全局变量a自增，这里错误把局部变量a自增</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于做CR的方法论，谷歌也出了一个CR工程师实践，文末参考资料附上链接。</p>
<hr>
<h2 id="Code-Review-配套工具"><a href="#Code-Review-配套工具" class="headerlink" title="Code Review 配套工具"></a>Code Review 配套工具</h2><h3 id="流程平台"><a href="#流程平台" class="headerlink" title="流程平台"></a>流程平台</h3><p>想要好好做CR，必须要依托工程平台的支持，你不可能把别人提交的分支代码拉到本地来diff着看吧，所以针对CR环节也对工程平台提出了一些基本要求：</p>
<ol>
<li><p>不同的聚合方式来查看diff：</p>
<ul>
<li><p>改动涉及的不同仓库（改动涉及多仓，分开看）</p>
</li>
<li><p>改动的文件类型（如统一查看.java后缀的文件改动）</p>
</li>
<li><p>被修改文件的组成的目录树</p>
</li>
</ul>
</li>
<li><p>diff代码颜色高亮展示，支持查看diff代码以外的其他代码</p>
</li>
<li><p>支持任意代码添加CR评论 以及 展示评论的解决情况</p>
</li>
<li><p>展示source分支的历史commit message</p>
</li>
<li><p>展示source分支以及要合并到的target分支</p>
</li>
<li><p>绑定文档模板，让RD按模板填写相关内容</p>
</li>
<li><p>查看所有需要待CR的Merge Request</p>
</li>
</ol>
<h3 id="精准pick人"><a href="#精准pick人" class="headerlink" title="精准pick人"></a>精准pick人</h3><p>相信有参与CR流程的同学都会遇到同一个问题，就是在需求扎堆上车合码的日期，当天会收到大量CR邀请，不说手头工作进度被拖累，收到的CR邀请可能还跟自己负责的模块不相关，尤其是QA同学对接多个RD，可能都会被不同的RD邀请CR。所以这个问题必须要解决：<strong>如何更精确地pick CR候选人</strong>。</p>
<p>相比于随机选择CR人选，有一个十分简单的解决办法：<strong>通过后台配置，指定某个代码目录匹配相关CR人选</strong>。一个代码目录应该有一到两个负责人，再加上若干候选人，CR的时候自动拉负责人，候选人则随机拉若干个，这样基本上就解决了随机选择CR人选导致CR不相关效果差的问题。</p>
<p>但是随着模块越来越多，团队越来越大，人员流动与代码变更会变得十分频繁，上面提到的配置名单是否还方便维护呢？答案肯定是No，每来一个新人，就要将这个新人添加到配置里，太麻烦了！还需要一种更精准的自动推荐CR人选的方式，这里我有一个想法：</p>
<blockquote>
<p><strong>流程总览</strong></p>
<ol>
<li>RD完成代码开发，提交代码发起Merge Request</li>
<li>根据RD改动的文件，<strong>结合 该文件与其他文件的 关联关系</strong>，获取被修改文件相关的其他文件，层级上下共x层（可配置）</li>
<li>遍历这些关联文件，逐一找出这些文件模块的RD（如果是子repo，获取repo owner；如果是子文件，根据git blame等git命令获取文件的最新（or最频繁）改动RD，否则兜底到根据配置获取文件负责人）</li>
<li>pick这些RD进来CR代码，或者推荐给发起CR的RD让ta自己选择拉谁</li>
</ol>
<p><strong>一个具体例子</strong></p>
<ol>
<li>RD小陈修改了代码文件A.java，提交后发起Merge Request</li>
<li>分析A.java的改动，发现本次改动中<strong>添加/删除/修改 方法function</strong>，根据A.java的代码进行分析，<strong>方法function属于类Example，类Example在B.java中被定义声明</strong>，被A.java import了进来；<strong>A.java在文件C.java、D.java中也有被使用，而C.java、D.java里定义的类被E.java和F.java调用</strong>。所以最后获取到关联的上下游文件集合有 [ A.java, B.java, C.java, D.java, E.java, F.java ]，下面附一个简单的图来表达这个上下关联关系</li>
<li>获取 [ A.java, B.java, C.java, D.java, E.java, F.java, G.java ] 这些代码文件的CR候选人（这里可以根据git代码行修改人获取对应RD，也可以配置RD）</li>
<li>这些候选RD推荐给CR发起人，让他选择拉哪些RD进来CR</li>
</ol>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/relationship_between_file.png" alt="代码文件的关联关系举例"></p>
<p><strong>核心问题</strong></p>
<p>如何抽取出代码文件之间的关联关系？使用什么样的静态代码分析技术？</p>
<p>以前有接触过类似的项目，通过正则表达式匹配不同的java语法，匹配范围包括：类对象的创建声明、包的引用关系，这样就可以知道<strong>一个文件会对外提供什么类，以及它使用了来自什么包的哪个类</strong>，进一步地，就可以匹配出两个java文件之间是否有关联关系——你调用我还是我调用你，也就是上下游关联关系。比如A.java有类A，B.java引入了类A并进行使用，那么B.java与A.java就存在关联关系。</p>
<p>基于正则的代码分析方案会有非常多坑，一方面是语法很难通过正则来穷极表达，难免出现语法遗漏覆盖导致关联关系的丢失；另外还需要处理大量代码格式兼容问题，代码格式稍有变动（比如敲多俩空格，代码中间换行展示）就可能导致正则匹配miss，又会出现关联关系丢失，所以不建议采用正则来做分析。</p>
<p>业界更常见的做法，是基于parser获取的AST（Abstract Syntax Tree）分析文件的关联关系。</p>
<p>对于移动端代码，本身又有很多系统平台提供的回调函数（比如Android onCreate方法等），这些在关联关系上还需要做特别处理。</p>
<p><strong>其他可能的问题</strong></p>
<ol>
<li>关联关系的分析性能，能否做到实时分析？使用线下分析的关联结果准确率多高？</li>
<li>大范围的改动，比如代码沉库、代码迁移，是否也适用？</li>
<li>打通代码库提交历史，具备静态代码分析能力以获取代码文件之间的关联关系，根据修改历史</li>
</ol>
</blockquote>
<hr>
<h2 id="Code-Review-落地"><a href="#Code-Review-落地" class="headerlink" title="Code Review 落地"></a>Code Review 落地</h2><p>Code Review流程大家应该基本清楚，那么CR应该如何落地，下面展开讲述一下。</p>
<h3 id="理念宣讲"><a href="#理念宣讲" class="headerlink" title="理念宣讲"></a>理念宣讲</h3><p>CR落地，第一件事就要宣讲CR理念，让大家知道这么一件事情的存在。最关键是要讲清楚为什么要做CR、CR如何嵌入当前流程、大家需要比平时额外做一些什么以及如何做CR，最后表达CR正式落地后的预期收益。</p>
<h3 id="流程试点"><a href="#流程试点" class="headerlink" title="流程试点"></a>流程试点</h3><p>研发流程改动是一件大事，起码CR的加入，涉及到RD与QA的工作流程变动，上上下下就是几十甚至上百人，再不能100%确定可以获取足够的收益前，流程试点是必须的。</p>
<p>不得不提，CR本身虽然只是一个流程环节，但是CR环节效果的好坏跟前置流程直接相关，比如需求评审的粗细、技术文档的质量、代码注释的多寡等。</p>
<p>在CR全面推广普及之前，CR可以有多种试点落地形式，比如：</p>
<ol>
<li>做一份人员配对名单，几个相关RD为一组，互相review对方的代码</li>
<li>筛选部分需求放到CR池子，RD选择想要review的需求自行参与CR</li>
</ol>
<p>两种形式各有优缺点，但是第二种形式给了更多自由，可能参与度更高，但是也要避免需求的扎堆Review，尤其是技术性很强很高大上的需求，毕竟做工程师很多都会对高深技术有向往，每个需求要设置一个CR上限人数，超过人数后就从CR池子中剔除。</p>
<h3 id="奖惩机制"><a href="#奖惩机制" class="headerlink" title="奖惩机制"></a>奖惩机制</h3><p>正向鼓励可以加速CR氛围的形成，最终要以实物作为奖励（京东卡？），所以需要一些预算💰，根据大家的产出来授予奖品。至于惩罚理所当然就是事故共担，线上问题责任按比例分配。</p>
<p>奖励考虑通过积分来兑换，所以可以做一个<strong>CR积分排行榜</strong>，具体分数可由如下几项指标转换过来：</p>
<ul>
<li>主动评估<ul>
<li>reviewer评估本次CR给自身带来的收获打分（对模块的熟悉度、代码技能的提升等）</li>
<li>CR效果打分（reviewer在CR结束后打分，评估本次review效果）</li>
</ul>
</li>
<li>被动评估<ul>
<li>CR前置发现的问题数</li>
<li>千行代码Bug数（可以按不同维度细分：团队、个人、需求等维度）</li>
<li>单个需求的Bug数</li>
<li>有效的CR评论（标记为已解决的评论）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>从各种资料看，国外大厂似乎比较流行Code Review，也许这使得国内对Code Review的态度时不时会有种难以言状的推崇或者仰望，错误地认为Code Review可以解决很多问题。Code Review仅仅作为一种质量保障的补充手段，它并不是银弹，不要指望Code Review可以发现多少关键问题，即使投入无限的人力也只能获取有限的收益，它的效果不如测试那么稳定。</p>
<p>这不代表就不需要Code Review，长期来看一个健康的技术团队是需要实践Code Review的。尤其是大体量产品，体量越大Bug产生的影响也就越大，而Code Review的性价比越高，为什么这么说呢？</p>
<blockquote>
<p>试想一下产品的日活从100W变成1000W，同样症状的线上事故，影响的用户量整整相差一个量级，也就代表着100W日活时一个P2级线上事故，在1000W日活时它会上升为P1级甚至P0级。</p>
<p>产品代码越复杂，Bug就隐藏得越深，问题场景就越构造，线下人工或者自动化测试，碍于工具支持以及建设程度，总有难以覆盖到的点，而Code Review正是一种精细耕作的手段，以弥补测试的不足，特别是很隐晦的Bug，比如资源竞争导致死锁饿死、异常处理分支出错、大流量下的性能问题、技术债的有无（技术债也是一种问题，未来需要成本解决）等……这些就是Code Review独特的作用。</p>
<p>随着产品体量增大，Code Review能发挥的价值会有所增长。</p>
</blockquote>
<p><strong>Code Review做得不好，就说Code Review无用，这样的说法就好比单元测试写得烂，就说单元测试不用做一样</strong>。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://coolshell.cn/articles/11432.html" target="_blank" rel="noopener">从 CODE REVIEW 谈如何做技术</a></p>
<p><a href="http://szuwest.github.io/code-reviewfang-an.html" target="_blank" rel="noopener">Code Review方案</a></p>
<p><a href="https://google.github.io/eng-practices/" target="_blank" rel="noopener">Google Engineering Practices Documentation</a></p>
<p><a href="https://phauer.com/2018/code-review-guidelines/" target="_blank" rel="noopener">Code Review Guidelines for Humans</a></p>
]]></content>
      <categories>
        <category>研发效率</category>
      </categories>
      <tags>
        <tag>code review</tag>
        <tag>白盒</tag>
        <tag>推荐阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Code Review 的思考</title>
    <url>/2020/03/26/Code-review%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>最近出了一个广告物料展示错误的P0线上事故。背景是RD在做视屏流畅度优化时，针对广告视频在滑动出屏幕瞬间出现卡顿的反馈，将资源释放时机延迟到滑动停止后。这个改动埋下了潜在问题——连续刷出两个视频广告时，滑出第一个视频开始自动播放，在滑出现第二个视频后，如果两个卡片cell资源复用，会在滑动停止后才切换播放第二个视频广告物料。在停止前播放的都是上一个广告的视频。</p>
<p>feature对应的commit是一个技术需求，RD自测保证质量，CR +1 的人有对应业务方的RD&amp;QA，也有己方的RD&amp;QA，一切看起来似乎都在正常流程内，那问题是出现在什么环节？</p>
<p>问题应该比较明显：</p>
<ol>
<li>CR效果差</li>
<li>自动化测试没有到位</li>
</ol>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/CR_for_both.png" alt="CR中对立方的心态"></p>
<p>说到CR，对标一下国外的明星公司，CR的严格可能超乎想象，而CR能严格执行的前提是RD、QA有客观充分的CR时间和风气习惯，RD对于代码出bug要有羞耻心，QA也要对标RD具备同等水位的能力要求。</p>
<p>我们都会说测试左移，都会说bug在自测和CR环节发现的代价是最低的，然而现实是大家都懒得通过CR去发现问题，因为自动化和手工测试成本虽然高，但思维强度低，本质上轻CR重黑盒是偷懒的表现。同时高强度的需求工作伴随着疯狂的迭代速度，CR时间被极度压榨，对单一系统熟悉的人也被压制到一个很窄的范围，每个人都是面向模块单一负责的，一个人都不完全了解另一个人所做的事情，那即使拉上一堆人来CR，实质上潜在能发挥CR作用的人也就那么一两个。</p>
<p>另一方面，国内互联网的风气还是高强度加班，用时间和人力来感产品窗口，某个角度上来看，真的很像劳动密集型产业。为什么会有很多程序员说35岁就中年危机面临失业的危险，当然这跟个人努力程度有着必然的联系，但是存在即合理，有这个焦虑就代表有对应的现象。程序员年纪大了写代码的功力真的会倒退吗？我觉得不是，随着程序员的经验、视野的成长，代码质量的上升是必然的结果，无论在工具使用、问题排查、代码调优、架构设计上都会有长足长进，本身这些能力就是需要时间来补齐的。那问题是什么？</p>
<p>可能的原因是否是国内大多数企业不需要你的经验，不需要你高质量的代码，所以你的经验是浪费的；另一方面伴随着年龄增长由于身体家庭等因素导致你的有效工作时长必然变短，所以老程序员对企业性价比下降了，就有程序员35岁中年危机？所以自然而然又有很多说法，程序员到30来岁就要转管理岗，离开一线编码工作。</p>
<p>B乎：<a href="https://www.zhihu.com/question/366571406/answer/984068963" target="_blank" rel="noopener">很多程序员都说 35 岁职业危机，那么为什么做开发的 35 岁程序员不转做测试呢？</a></p>
<p>当然这个标题本身就对测试带着偏见，我们不需要理会标题，里面有些回答比较精彩有参考意义。</p>
<p>理性看待程序员成长这个问题，对于行业说法这里不置可否。字节跳动有一句话，<strong>成长看个人。</strong></p>
<blockquote>
<p>在一个增长缓慢的公司/业务中大部分人都会遭遇职业瓶颈， 如果你已经被系统所驯化， 失去了对新的平台机会的敏锐嗅觉和拓展自己的勇气， 那怎么走都会遭遇职业危机。</p>
</blockquote>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>code review</tag>
        <tag>白盒</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY装机小白科普-cpu篇</title>
    <url>/2019/06/30/DIY%E8%A3%85%E6%9C%BA%E5%B0%8F%E7%99%BD%E7%A7%91%E6%99%AE-cpu%E7%AF%87/</url>
    <content><![CDATA[<p>电脑是这个年代的刚需，笔记本便携固然好，但是性能有限，当各位上班族的住所稳定下来之后，购买一台配置跟上时代的台式机的需求自然而然就有了，为什么需要台式机，我用一台笔记本不就够了吗？</p>
<ol>
<li>台式机性价比高，同样的价格买回来的配置性能比笔记本高一到两个档次，同样的配置买回来价格分分钟比笔记本低25-40%。</li>
<li>台式机灵活性好，配置更换方便，基本上任何部分都可以随意升级更换，坏了自己修方便。</li>
<li>台式机容易上 RGB Buff 😆！（RGB灯：五颜六色的灯光效果）</li>
</ol>
<p>好吧，第3点其实是半开玩笑的，前2点已经解释了为什么选择台式机了，但是购买台式机也有要注意的地方：</p>
<ol>
<li>不买品牌机，因为品牌机配置没什么选择性，想要升级配置还得定制，价格贵配置差捆绑售后服务，基本上是交智商税[^1]。</li>
<li>不买电商平台上面看到的整主机（如x美国度），里面的配置缩水得看不下去[^2]。</li>
<li>不去实体店买配件，要网购，请认真看这个链接[^3]，引用别人的话：实体店价格高、不专业、套路多、型号老、售后差。</li>
</ol>
<p>好了，正文准备开始了，这篇文章的用意是指导小白入门，所以尽量做到基础知识上的面面俱到同时将没必要的细节屏蔽，图文会比较多，同时附上较多有价值的参考链接，如果是pc端看的话建议一起看了。建议先收藏，有空就看一个部分😏。注意本文有时效性哦~</p>
<a id="more"></a>

<h3 id="CPU篇"><a href="#CPU篇" class="headerlink" title="CPU篇"></a>CPU篇</h3><p>cpu是什么？电脑的核心啊，因为主板需要根据cpu来选择，所以买电脑一个首先要考虑的就是cpu，cpu正片现在开始。</p>
<blockquote>
<h4 id="cpu有哪些牌子吗？"><a href="#cpu有哪些牌子吗？" class="headerlink" title="cpu有哪些牌子吗？"></a>cpu有哪些牌子吗？</h4></blockquote>
<p>cpu适合个人PC的大概也就是<code>两个牌子</code>，你认为只有两个牌子其实也没有错，因为其他牌子估计也不会听到。这两个牌子一个是<code>Intel (英特尔)</code>，一个是<code>AMD</code> (一般没人叫中文名，百度百科管它叫超威)。在PC上这两个牌子都有一段长长的历史，这里就不做展开了，但是目前Intel在大众视野里应该更加著名，毕竟早个五六年AMD一直被Intel吊打，性价比一直比不上Intel。到了2017年，AMD研制出全新架构，推出Ryzne锐龙处理器之后，格局就不一样了，<a href="https://zhuanlan.zhihu.com/p/44571636" target="_blank" rel="noopener"><strong><em>了解Intel和AMD的恩恩怨怨可以点我</em></strong></a>。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMDvsIntel.jpeg" alt="AMDvsIntel"></p>
<hr>
<blockquote>
<h4 id="cpu的参数如何识别好坏？"><a href="#cpu的参数如何识别好坏？" class="headerlink" title="cpu的参数如何识别好坏？"></a>cpu的参数如何识别好坏？</h4></blockquote>
<p>放上一张JD的cpu参数介绍图，我们来一项一项说明，这里以<code>AMD r7 2700X</code>做例子：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD-r72700x-JD.png" alt="AMD锐龙7 2700x"></p>
<p><code>核心</code>：这是2019年了，早就是cpu的多核时代了，以前的cpu只有一个核心，现在技术上单个cpu核心上的性能已经越来越接近物理极限，厂商们想要提升cpu的性能，开始从单cpu核心转变为多cpu核心。<code>一般来说核心越多越好</code>，当然这不是绝对定理，因为不同的厂商单个cpu核心的性能是有差距的，3个诸葛亮跟4个臭皮匠 (3个好核心比4个垃圾核心)，肯定是前者更好呀。但是核心太多会导致其他问题，越多核心，cpu之间的协作成本越高，好比现实世界，有时候一个人做事反而比三个人更快，就是因为一个人独立负责可以剔除一切沟通成本，使得效率更高，同理，<code>cpu核心越多，不同cpu之间因为合作需要内耗越大</code>，所以cpu核心数并不是越多越好的，需要软件硬件的结合。</p>
<p><code>接口类型</code>：这个一般不关注，不同的接口类型是互不兼容的，也就是插不上去不能用，我们需要关注的是主板是否适合cpu的接口即可。</p>
<p><code>主频</code>：Intel给了一个公式，<strong><em>CPU性能＝IPC×频率</em></strong>，IPC是 <strong>Instruction Per Clock</strong>，也就是cpu每一个时钟周期可以执行的指令多少，这个越高cpu就越快；而频率就是主频，代表一秒可以跑多少个时钟周期，在IPC相同的前提下，主频越高单核性能越强。但是不同型号cpu的主频是无法直接比较的，因为不同代的cpu架构不一样，这会使得IPC、指令集等都不一样，有些老cpu主频也可以很高很高，但是实际上还不如最新一代架构但是主频更低的cpu来得性能好。</p>
<p><code>缓存</code>：cpu缓存分为好几级，现在一般都分为3级，可不要小看这里的缓存怎么才几个MB那么少，L1级缓存的速度可是比内存快上<code>100倍以上</code>，让我们来直观地来看看下面的表格，参考自<a href="https://www.prowesscorp.com/computer-latency-at-a-human-scale/" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>实际耗时</th>
<th>cpu的感官体验</th>
</tr>
</thead>
<tbody><tr>
<td>一个cpu周期</td>
<td>0.4ns(纳秒)</td>
<td>1s(标准数据)</td>
</tr>
<tr>
<td>读取L1级缓存</td>
<td>0.9ns</td>
<td>2s</td>
</tr>
<tr>
<td>读取L2级缓存</td>
<td>2.8ns</td>
<td>7s</td>
</tr>
<tr>
<td>读取L3级缓存</td>
<td>28ns</td>
<td>1 min</td>
</tr>
<tr>
<td>读取内存</td>
<td>~100ns</td>
<td>4 min</td>
</tr>
<tr>
<td>NVMe接口固态硬盘读写</td>
<td>~25μs</td>
<td>17 h</td>
</tr>
<tr>
<td>普通固态硬盘读写</td>
<td>50-150μs</td>
<td>1.5 - 4 days</td>
</tr>
<tr>
<td>机械硬盘读写</td>
<td>1-10ms</td>
<td>1 - 9 months</td>
</tr>
<tr>
<td>从San Francisco到New York City的一次网络通信</td>
<td>65ms</td>
<td>5 years</td>
</tr>
<tr>
<td>从San Francisco到Hong Kong的一次网络通信</td>
<td>141ms</td>
<td>11 years</td>
</tr>
</tbody></table>
<p>cpu的运行速度实在太快了，内存、硬盘、网络三人哭着表示大佬求你别跑了我们跟不上🤣。在cpu看来这3个东西实在太慢了，要是每次都要我去等那我不就废了？于是产生了cpu缓存，cpu从缓存里拿数据的速度非常快，可以大大减少cpu因为等待内存、磁盘、网络响应导致cpu空转原地踏步而浪费性能的时间。所以现在知道这个缓存的重要意义了吧？<code>cpu缓存越大越好！</code></p>
<p><code>功耗</code>：这个参数相对来说比较玄幻，有一定的参考意义，<code>一般来说当然希望功耗越低越好，功耗低发热就少，而且省电</code>。一般同性能等级Intel的cpu功耗要比AMD的cpu低出不少，而功耗过高就要额外考虑cpu的散热问题。</p>
<p>再补一个AMD官网拿过来的<code>AMD r7 2700X</code>的数据，可以看看官网的数据是怎么写的 (长年有道词典在手🤣)，注意TDP，这个参数是功率的参考参数，一般还是要以实际测试为准。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD-r72700x-official.png" alt="AMD锐龙7 2700x官方数据"></p>
<hr>
<blockquote>
<h4 id="哦，看完参数啦？不太懂……"><a href="#哦，看完参数啦？不太懂……" class="headerlink" title="哦，看完参数啦？不太懂……"></a>哦，看完参数啦？不太懂……</h4></blockquote>
<p>看完上面的cpu科普后，是不是依然不得要领，是不是感觉没有找到一个参数能作为cpu对比的靠谱指标呢？那就对了😂。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/Confused_Young.gif" alt="What 7 you say?"></p>
<p>其实上面的cpu数据一般都不会拿来直接对比的，只有在高玩的眼里这些参数才会有足够的参考价值，一般人嘛，只要不是想着买万元土豪机或者工作站什么的，都是不太需要关注这些数据的啦，我们需要什么？是真实测试的cpu性能数据！有这个需求就就产生了cpu天梯图 (另外各大视频弹幕网站里的各种cpu测评也是很有参考价值的)。</p>
<p>百度搜索<a href="https://www.baidu.com/s?wd=cpu天梯图" target="_blank" rel="noopener"><strong><em>cpu天梯图</em></strong></a>，有不少别人已经整理好的图表，非常直观，建议多看两张进行对比，毕竟这些图表都是相对主观的个人编辑，会存在一些作者偏爱什么的，举个例子比如下面这张，而且要注意图表制作的时间，现在是2019年，你再拿2017年的天梯图看已经没有任何参考意义，因为市场在售产品已经完全更新换代了：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/CPU_ladder_201904.jpg" alt="转载自 http://www.365pcbuy.com/article-411.html"></p>
<p>专门的电脑配置百度贴吧里也有不少高玩潜伏，多在贴吧里混一下可以给新手带来十分可观的知识量哦。</p>
<p>面对cpu天梯图，分为Intel和AMD两个阵营，从高至低有一个直观的cpu性能排行榜，可以在JD或Tmall上分别搜索一下<code>排在前头的</code>，<code>排在中间的</code>和<code>相对靠后</code>的cpu的价格，体会梯度之间的差距。</p>
<p>看着天梯图应该是能注意到cpu的命名是有模式的，先说Intel阵营，以<code>i7-9700K</code>举例子，<a href="https://www.intel.cn/content/www/cn/zh/processors/processor-numbers.html" target="_blank" rel="noopener"><strong><em>这个链接是Intel对于型号的官方解释</em></strong></a>：</p>
<ol>
<li><code>i7</code>代表型号，相同后缀4位数前提下，越高越好.</li>
<li><code>9700K</code>需要拆分，第一位代表第几代cpu，代数越大，架构更优。i7-4770K &gt; i7-3770K</li>
<li>第二位代表处理器等级，数字越大，性能越好。i5-8500 &gt; i5-8100</li>
<li>第三位代表核心显卡，可忽略不比。</li>
<li>第四位代表功耗，可忽略不比。</li>
<li>第五位英文字母含义可多了，这里就不全列了。H、M、U从高到低代表功耗，一般是笔记本电脑上的cpu会用到；K、S、T也是功耗从高到低，功耗越大性能就会越好，而且K代表不锁频，意味着可以玩<code>cpu超频</code> (后面解释)；X代表顶级cpu。</li>
</ol>
<p>然后是AMD阵营，这里只讲解锐龙产品线，看<code>Ryzen5 r7 2700x</code>，Ryzen3 (r3)、Ryzen5 (r5)、Ryzen7 (r7) 感官上对标i3、i5、i7。接下来一图胜千言，跟Intel差不多套路：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD_cpu_name.jpg" alt="转载自 http://www.chinaaet.com/article/3000060423"></p>
<hr>
<blockquote>
<h4 id="不同牌子cpu有什么特点，适合什么工作？"><a href="#不同牌子cpu有什么特点，适合什么工作？" class="headerlink" title="不同牌子cpu有什么特点，适合什么工作？"></a>不同牌子cpu有什么特点，适合什么工作？</h4></blockquote>
<p>相比而言，AMD的cpu性价比要稍稍高一些 (反正我是偏爱AMD的嘿嘿嘿😝)。网上流传的是普通电脑用Intel cpu，专门的图像处理、电脑用AMD cpu。</p>
<p>不同的牌子cpu适合什么类型的工作，分别有什么特点</p>
<p>这里可以列举一些场景所对应的性价比高的cpu：</p>
<ol>
<li>单纯需要普通office办公、上上网、看看视屏、播放电影音乐的用户，建议<code>i3-8100</code>，也适合拿来玩烂大街的小网游如DNF、CF、LOL等，不需要买独立显卡。</li>
<li>适度游戏益智类的用户，玩玩几年前的大型单机游戏，放在2019年来说，玩玩孤岛惊魂系列、孤岛危机系列、使命召唤系列、古墓丽影、黑魂啊啥啥啥的，只要特效调节合理都没问题，也包括一般强度的视频图像剪辑、跑代码计算等，写这篇文章的时候我特别偏爱AMD的<code>r5 2600x</code>。</li>
<li>土豪装备，玩当前流行的3A大作全特效，并且希望一步到位在四五年后依然可以玩最新最吃配置的游戏，不要给我说什么性价比、什么架构、什么核心数，老子装电脑就是一把梭，哪个最贵买哪个🤦‍♂️。截止至2019年5月1日，PC (不算工作站cpu)最好的cpu应该是Intel<code>i9-9900K</code>，JD在售4300RMB，妈呀这价钱都能组装一台不差的台式机了。</li>
</ol>
<p><code>i3-8100</code>是一个普适的cpu，性能表现良好，很多装机老司机都推荐，只要是一般工作娱乐机，上上网看看视频玩玩低配网游如英雄联盟，一个<code>i3-8100</code>即可流畅运行，性价比十分高。<code>r5 2600</code>也是一个不错的选择，AMD的cpu超频空间相对较大，不少人买<code>r5 2600</code>回来超频用。其实一切都得要看需求，什么样的需求决定用什么性能层级的cpu，只言片语是无法决定的，需要多搜资料考察，多看看别人的装机性能测评，这样自己就会慢慢有概念，了解什么样的cpu能handle什么样的工作场景。举个例子，AMD的锐龙cpu后缀不带G都是没有核显的，你可以理解为买这样的AMD cpu可以省下核显的钱，尤其是你有强大的独显根本不用核显那么点性能的场景下，而Intel cpu后缀带F则代表无核显，基本上Intel的cpu都是有核显的，虽然现在它的核显性能越来越好 (Intel cpu在功耗和温度上吊打AMD cpu)，但是买高配机，压榨配置预算换取最高性能的条件下，一部分钱捐给了这个无用的核显 ，就显得钱花得不那么值了(都买了很牛逼的独显，要核显干嘛？</p>
<p>接下来对比一下Intel和AMD的cpu，信息翻译自这个<a href="https://www.digitaltrends.com/computing/amd-vs-intel/" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>：</p>
<p>再次来对比Intel和AMD，在中端和低端领域，AMD能给到的性能和价格都更加理想，Intel cpu有更强劲单核性能和游戏表现 (不过一般cpu都不会是游戏的瓶颈，更多时候是显卡)，而AMD的线程撕裂者cpu则适合需要多线程协同工作的场景。</p>
<p>这里额外科普一下主频和线程数在cpu中的概念，参考自<a href="https://www.pc841.com/article/20180522-89740_all.html" target="_blank" rel="noopener"><strong><em>CPU知识科普：秒懂主频、核心、线程、缓存、架构</em></strong></a>：</p>
<p>可以将主频想像成一只粗壮的手臂，线程数想象成手臂的数量。</p>
<p>对于需要粗暴计算的游戏场景，主频高的cpu更有优势，这就好比我的工作是搬砖，肌肉强，力气大才是硬性需求 (主频高)，就算我有8条胳膊16只手 (线程数多)，看起来张牙舞爪很厉害，但是我搬砖的时候根本用不到，这些胳膊大多力气小，所以效果并不会很好。</p>
<p>对于图形渲染等专业工作需求，需要进行大量并行计算，多核心多线程同时工作能比少核心高主频的傻大粗节省大量时间。绿巨人虽然搬砖能力出众，但是如果让他去完成一副复杂的拼图，速度自然是比那种有多条胳膊和多只手同时工作的小机灵慢了不少。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/intel&amd.png" alt="两家各有卖点"></p>
<hr>
<blockquote>
<h4 id="超频，核显分别是什么？"><a href="#超频，核显分别是什么？" class="headerlink" title="超频，核显分别是什么？"></a>超频，核显分别是什么？</h4></blockquote>
<p><a href="https://www.gcores.com/articles/105781" target="_blank" rel="noopener">超频</a>一般是高玩的手法，普通玩家就不要管什么超不超频的了，远离超频珍爱生命，超频的具体定义是：</p>
<p>通过BIOS或者软件将CPU的工作频率设定高于基准频率，CPU能够稳定在这个高频率下运行时可以加快计算机的处理速度。换句话说，超频也就是调整硬件设置让CPU芯片稳定运行时的频率更高的技术手段。可以看看这个<a href="https://www.expreview.com/tag/chaopin.html" target="_blank" rel="noopener">链接</a>补充一下。</p>
<p>可以说超频就是将到手的cpu零成本提升性能的手段 (当然超频除了cpu之外，内存、显卡、甚至显示器都能给超频来获取突破基准的额外性能)。</p>
<p>放在大几年前，超频可能是穷人的玩法，但是放到了现在，超频一般是有钱人或者电脑爱好者拿来折腾的玩法，已经开始变味了 (神tm液氮干冰超频了解一下🙃)。cpu出厂分好坏，有些cpu体质好，能超频超到比较高或者同等电压下就可以达到更高的主频，有些cpu只能超一点点，稍微多一点就不稳定。每个cpu能超频的幅度都不一样，你买到的cpu也分大雕和打雷😆。</p>
<p>超频是一个调试过程，分为软件超频和硬件超频（软超和硬超），一般更偏向于一次性设置便可以不再管的bios硬超，软超每次开机都需要重新配置参数很麻烦。硬超简单来说就是在bios调节各种参数，给cpu加电压，进入系统拷机测试 (<strong><em>拷机就是使用特定软件制造出庞大的运算负载，以此来检测CPU、内存、显卡在极限负载下的超频效果是否稳定，如果拷机过程中死机、黑屏、驱动重置，则代表超频失败，需要降频，重复上述过程</em></strong>)。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/liquid_nitrogen.jpeg" alt="液氮超频"></p>
<p>当然cpu频率上去了，性能也上去了，也不知道谁说的😆，P=U×V，cpu电压给加上去了，发热必须得增加啊！对于cpu甚至全部硬件来说，温度就是<strong><em>生命</em></strong>，所以极限超频都判随着很高的散热要求，如果cpu（无论任何硬件都一样）在过高温下长时间工作，轻则宕机，重则造成硬件永久性的损坏，降低硬件寿命和性能，这也是为什么建议普通玩家不要瞎超频，入坑深似海。</p>
<p>顺带科普一下，intel cpu不是全部都能超频的，只有后缀K的型号（当然比不带K的更贵）并且配合支持超频的主板才满足超频的前提。这里给出一个公式：<strong><em>主频＝倍频×外频</em></strong>，所以超频分为超倍频和超外频，超倍频是cpu自己的事，最坏的情况就是cpu超坏了，而外频和主板上其他所有东西都是关联的，如PCI-E接口频率、总线频率、内存频率……牵一发而动全身，超外频意味cpu和它周边所有硬件包括内存、硬盘、显卡等跟着一起超频。cpu、显卡、内存这些比较耐艹，但是硬盘可是很脆弱的东西，经受不了折磨，数据物价，超坏了硬盘导致数据资料全没了，损失分分钟比坏一个cpu还高哦。所以一般超频都会选择超倍频，而intel不带K型号的cpu是<strong>锁倍频</strong>的，意味着你没法超倍频，真的要抄只能冒险超外频。可以参考链接：<a href="https://baijiahao.baidu.com/s?id=1619727719362104239&wfr=spider&for=pc" target="_blank" rel="noopener">认识外频和倍频</a>。</p>
<p>我们一般看到的intel cpu主频参数是基准频率，实际上cpu在运行时是主频是动态变化的，核心电压也是动态变化的，这里引申出intel的睿频技术，可以根据不同的任务负载智能提高cpu主频，比如我的主机用了intel的cpu <code>e3 1230v2</code>，我观察到机器在空闲时cpu频率会掉到1500+Mhz，偶尔会上到3600+Mhz，所以我在windows<code>我的电脑-&gt;右键属性</code>上看到cpu后面跟着两个频率，一个是3.3Ghz，一个是3.7Ghz。当然这个睿频最高频率只是单核能达到的最高频率，而在多核情况下，核心之间需要保持数据一致性、共用cache、TDP设计等原因，是不可能所有核心同时都达到最高睿频的（AMD当然也有类似的技术）。</p>
<p><a href="https://baike.baidu.com/item/核心显卡" target="_blank" rel="noopener">核显</a>就是<code>核心显卡</code>，是指cpu内置的显卡，区别于独立显卡 (也就是一整块额外买的显卡)，高端cpu的核显吊打垃圾独显，核显相比于独显，功耗低、性价比更高，只是性能有限，没办法玩得动大型游戏or大型图像处理工作。如果只是日常办公的一般需求，核显性能也可以满足要求，显然性价比更高。</p>
<blockquote>
<h4 id="cpu会不会有假货？"><a href="#cpu会不会有假货？" class="headerlink" title="cpu会不会有假货？"></a>cpu会不会有假货？</h4></blockquote>
<p>市面上在售的cpu分为2种：</p>
<p><code>盒装cpu</code>，定位是零售商品，面向市面普通个体用户，官网叫做box，是有序列号有保修服务的。以Intel举例，在Intel官网可以通过序列号查到cpu，也可以看到保修状态，Intel cpu的质保服务是3年内出现非人为损坏免费换新。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/box_cpu.jpg" alt="盒装cpu"></p>
<p><code>散片cpu</code>，定位是批发商品，官网叫做tray，面向企业以批发价出售。这些散片cpu到了企业手上由于各种原因再流向普通市场，就是我们看到的散片cpu。举个例子，个人零售价一个cpu 100美元，现在hp这种买品牌机的厂商向Intel进货cpu 10万个，批发价每个cpu 95美元，后来hp发现自己的品牌机销量不够，cpu 10万个用剩1万个，怎么办？聪明的你肯定想到将cpu偷偷卖给市面上的个体用户 (Intel肯定是不乐意的，但是也放任不管)，诶我不用压价卖，95美元单价一个买回来，我现在96美元一个卖出去，对于企业来说还是有得赚的，个体用户也省钱，岂不美哉😏。当然散片缺少盒装cpu赠送的散热风扇，也不排除是走私水货或者从别的电脑上拆下来的cpu，Intel是不负责保修的，有可能是经销商负责保修服务。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/tray_cpu.jpg" alt="散片cpu"></p>
<p>那你可能问，cpu会不会像其他货物一样出现假货呢？</p>
<p>首先答案是【cpu不存在假货】，这么精密的东西，你要是能造假cpu，国家还不赶紧投几百个亿让你继续研究cpu造着去，至于cpu有多精密，可以看看这个<a href="https://www.bilibili.com/video/av22544389" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>。</p>
<p>可能这里的cpu造假概念不太一样，也还是有一些手段来欺骗消费者的，如：</p>
<ol>
<li>就是<strong><em>换盖</em></strong>，CPU的型号是刻在顶盖上的，所以造假方法就是给垃圾CPU换个牛一点的顶盖吓唬别人。比如核心是i3，换成i7的顶盖，当i7卖。这种你一开机就知道了，设备管理界面，或者各种检测软件都能看到。</li>
<li>用机器把原来的型号打<strong><em>磨掉</em></strong>然后刻上新的型号，这个和第一种差不多，纯粹的物理手段改变外观型号，本质上没改，所以一开机看一下参数就知道了。</li>
<li>用<strong><em>remark</em></strong>直接修改CPU参数，但是这种参数修改只能骗骗windows，用<strong><em>CPU-Z</em></strong>一查就能查到，还有windows自带的注册表管理修改，也可以从软件层面达到更改CPU型号的目的，但是用别的软件都能查到。</li>
<li>整机销售一般惯用套路，就是机器买来系统是装好的，桌面有个鲁大师用来看配置，那么直接把这个<strong><em>鲁大师改掉</em></strong>就好了，你换个别的检测软件就能查出来了，这个套路闲鱼非常多，希望各位看到什么2999就i7 32G内存的机器，切记要小心，贪过分便宜你就要付出代价。</li>
<li>将CPU的<strong><em>测试产品</em></strong>或者<strong><em>残次品</em></strong>当成正品卖。CPU生产成正式商品之前需要先通过测试版本，测试版本相对于正式版没有那么稳定，很有可能会出各种BUG，有的测试版本在CPU-Z是不显示型号的，而有的测试版本是会显示型号的，这时候你看一下<strong><em>步进</em></strong>是什么水平就能知道他到底是不是测试版了 (CPU生产会先生产测试产品，步进就代表它属于什么阶段的产品了，越先进的步进越接近零售产品)。而残次cpu可能出现的情况就是掉电容、缩肛 (超频超坏了，频率往下掉)、剪角、单通道、坏核显等 (cpu摔了也会坏的)……</li>
</ol>
<p>剪角cpu，注意左上角被剪，cpu<strong>可能会</strong>损失一部分性能或功能，属于残次品。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu_imperfect.jpg" alt="剪角cpu"></p>
<p>总的来说，如果在保修的不那么重要的前提下，散片的价格优势太明显，一般组装电脑更推荐买散片，至于散片在JD、Tmall这种正规市场是基本没有的，在某宝就有很多，可以挑选销量高评价高的购买，只要不是运气太足够买彩票，一块cpu正常用上五六年都不会有任何问题。</p>
<blockquote>
<h4 id="其他趣事"><a href="#其他趣事" class="headerlink" title="其他趣事"></a>其他趣事</h4></blockquote>
<p>关于cpu的东西，差不多就这样了，可以给大家说说cpu的一些趣事。</p>
<p>首先介绍一下AMD的别称，一叫<code>农企</code>，二叫<code>按摩店(An|Mo|Dian)</code>。虽然AMD是Advanced Micro Devices的缩写，但由于多年以来产品性能不给力，广大粉丝宁愿相信AMD是来自于缩写Agriculture Machine Devices（农机设备），Agriculture Machine Department（农业机械部）。而且巧合的是，之前AMD的推土机系列处理器命名采用了全套农机设备不是跟你开玩笑的：推土机（一代）、打桩机（二代）、压路机（三代），这无异于官方默认玩家的爱称，这更加坐实了农企的称号是非常科学的🤣。</p>
<p>Intel别称是<code>牙膏厂</code>，前几年时间由于AMD的cpu一直被Intel吊打，AMD被打得苟延残喘，甚至产生了<code>i3战A8，i5秒全家，i7轰成渣</code>的调侃说法（感兴趣的可以自己了解一下15年cpu天梯图），那时候Intel处理器长期保持在一个8、9%的性能提升节奏上，根本不怕AMD赶上来。Intel的cpu技术升级缓慢，更新迭代如同挤牙膏一般，所以广大玩家给Intel起名牙膏厂。</p>
<p>Intel为了赚取更多的利润和降低研发投入，仅需每年做一点提升就能始终保持主流芯片的龙头地位，这样既不需要重新规划产品架构，也不需要投入过多研发实力，还能持续获得利润，这不就是企业最想得到的商业结果吗？躺赚！当然Intel也不傻，这样每年就节约了很大一部分开支用来做未来的技术储备，当市场有威胁其地位的新品出现时，就可以随时进行反击，怎么想都是美滋滋的，何乐而不为？</p>
<p>这两三年AMD推出性能提升52%的Ryzen系列处理器，网友就炸锅了，大有翻身做主重振雄风之势，英特尔马上就采取了行动推出了i9，Intel依然保持着一定的优势，只是远远没有以前那么大了，浪多了还是得稳一波。</p>
<blockquote>
<h4 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h4></blockquote>
<p>cpu本身肯定是有接口类型区分的，不同的cpu只能在不同主板平台上运行，并不是一颗cpu什么主板都能给嵌上去。intel不同的针脚数就是不同的平台，而AMD有Socket AM4等接口类型定义。cpu上每一个针脚位都有固定的含义，如下图：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu_pins.jpg" alt="cpu针脚定义图"></p>
<p>cpu硬改是通过加一层中间层来屏蔽针脚或者调换针脚定义的黑科技手段，具体可参考链接<a href="http://www.21ic.com/news/mcu/201810/838733.htm" target="_blank" rel="noopener">硬改CPU黑科技是啥？</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/55724462" target="_blank" rel="noopener">硅脂U和钎焊U</a></p>
<p>入门概念介绍这么多也足够了，我水平有限，剩下更多的知识需要大家多混论坛贴吧长知识甚至实操才能有所体会了😄。</p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>电脑配件</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY装机小白科普-显卡篇</title>
    <url>/2019/07/01/DIY%E8%A3%85%E6%9C%BA%E5%B0%8F%E7%99%BD%E7%A7%91%E6%99%AE-%E6%98%BE%E5%8D%A1%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<h4 id="显卡有哪些牌子？"><a href="#显卡有哪些牌子？" class="headerlink" title="显卡有哪些牌子？"></a>显卡有哪些牌子？</h4></blockquote>
<p>显卡芯片可以粗略认为只有两家大厂：NVIDIA (英伟达) 和 AMD。是的，又是我们的AMD。</p>
<p>你可能会说，我们平时不是见到很多其他品牌的显卡吗，什么华硕、技嘉、微星、影驰、七彩虹、蓝宝石、迪兰……其实这些只是显卡厂商而已，显卡芯片才是显卡的核心，但是只有显卡芯片是没用的，一块完整的显卡还需要由显存、PCB板、散热设备、供电设备等其他配置共同组成，板卡厂商生产显卡如果要用NVIDIA的芯片，是要得到授权的。</p>
<p>芯片厂商只要用心设计芯片就好了（设计出来也是由别的厂商代工生产芯片），而板卡厂商则是在显卡芯片所能达到的性能范围内，通过设计不同的供电方案、PCB板、散热方案等等，提高显卡的整体性能，并且设计出厂家独特的风格。这就是社会的专业化分工结果。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/zhuangbi_1.jpg" alt="装逼大图"></p>
<blockquote>
<h4 id="显卡参数如何识别？"><a href="#显卡参数如何识别？" class="headerlink" title="显卡参数如何识别？"></a>显卡参数如何识别？</h4></blockquote>
<p>显卡类型一般分三种：集成显卡、核心显卡、独立显卡。这个年代pc显卡已经淘汰集显了，都是核显和独显的时代了。不懂的小白可能不明白，为什么有的电脑没有显卡也可以跑，那是因为cpu中有核显，核显的性能肯定不如独显好，但是胜在功耗低，适合不需要独显的需求，省下买独立显卡的钱 ，比如普通办公上网、代码编程等均不需要独立显卡。</p>
<p>来看看JD上迪兰rx590的参数，一项项说明显卡参数。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/jd_rx590_param.png" alt="迪兰rx590京东参数"></p>
<p><code>显示芯片</code>：显示芯片是N卡还是A卡，芯片具体是什么型号，芯片的性能直接决定显卡性能的好坏，一般板卡商的整块显卡命名也会带上芯片的型号，比如<code>AMD蓝宝石RX590 8G超白金极光特别版</code>，这里能获取的信息就是板卡商是蓝宝石，芯片是AMD的rx590，显存是8G。至于芯片的好坏，这里就要祭出显卡芯片天梯图了，百度搜索<a href="https://www.baidu.com/s?wd=显卡天梯图" target="_blank" rel="noopener">显卡天梯图</a>，跟cpu天梯图同理，显卡天梯图也是有时效性的，注意图的日期：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/graphical_card_ladder.jpg" alt="显卡天梯图，转载自 http://www.365pcbuy.com/article-398.html"></p>
<p><code>流处理单元</code>：简称SP (Stream Processor)单元，直接影响显卡的处理能力，是显卡的核心之一，网上的资料都是干巴巴的，反正是<code>越多越好</code>了。</p>
<p><code>显存容量</code>：显存容量一般称为显存，显存是用来存储芯片处理过或者即将读取的渲染数据。在显示器上显示出的画面是由一个个的像素点构成的，而每个像素点都以4至64位的数据来控制它的亮度和色彩，这些点构成一帧的图形画面，为了保持画面流畅，要输出和要处理的多幅帧的像素数据必须通过显存来保存，达到缓冲效果，比如画面里的草草木木、房屋建筑、车辆人流，细节越多数据量就越大，显存就越重要。玩游戏的画面参数如分辨率、<a href="https://zh.wikipedia.org/wiki/反鋸齒" target="_blank" rel="noopener">抗锯齿</a>、<a href="https://baike.baidu.com/item/各向异性过滤/662077" target="_blank" rel="noopener">各向异性过滤</a>、物理效果模拟等选项都是需要显存容量的，显卡芯片越强，能提供越好的画面，就需要更多的显存来配合。在win10系统下，如果显存不够用，系统会挪用部分内存提供给显卡使用的，所以显存如果很捉急，内存够大还可以来抢救。最后，显存当然越大越好，不过<code>要看搭配的显示芯片的性能</code>是什么等级，给你一个垃圾芯片，你拿32G显存都毫无卵用。</p>
<p><code>核心频率</code>：是一个有参考意义的参数，同一型号的芯片，因为体质问题 (厂家成品芯片出厂时只要芯片频率在一个可以接受的范围即可，并不是精准的频率)导致频率有高有低，在相同的显示芯片下，<code>频率越高性能越强</code>。但是显卡的性能还受到其他因素的印象，如果显示芯片不一样，核心频率比较起来没有太大意义。</p>
<p><code>显存类型</code>：目前市面上主流显存类型都是GDDR5，G=Graphical，DDR=Double Data Rate，数字代表第几代，越高越好。要是想正儿八经而自己买个显卡，肯定是<code>买GDDR5</code>了，GDDR3已经是垃圾，GDDR4市面上很少见。</p>
<p><code>显存位宽</code>：<code>越大越好</code>，每一个时钟周期显卡与显存之间的数据传输量，目前最顶级的显卡可以高达1024GB/s，中高端显卡普遍是256GB/s。</p>
<p><code>显存频率</code>：显存在显卡上的工作频率，以MHz (兆赫兹)为单位，意思是一秒可以完成多少个显存时钟周期，一定程度表现了显存的速度。</p>
<p><code>显存带宽</code>：显存与显卡芯片之间的的数据传输量，也就是显存的吞吐量，计算公式：<code>显存带宽=显存频率*显存位宽/8</code>；</p>
<p><code>显示器接口</code>：具体接口有什么用，我们留到<code>显示器</code>的环节再说。VGA接口已经很古老了，在如今的中高端显卡&amp;显示器中慢慢淘汰，它传输的是模拟信号，在这个数字信号时代已经不合适了。DVI接口仍然是传输模拟信号，体积大同事不支持音频信号，也慢慢被淘汰。HDMI支持音频输出 (你会见到一些有HDMI接口的显示器支持播放声音就是这个原理)，是目前最主流的视频输出口，接口也不大。DP可以理解为HDMI的升级版，传输带宽更高，可以传输更高分辨率的画面，在超高清4K下优于HDMI。总的来说，<code>DP &gt; HDMI &gt; DVI &gt; VGA</code>。</p>
<p><code>TDP</code>：Thermal Design Power (热设计功耗)，作为一项十分重要的功耗参考数据，让你知道你要<code>搭配什么样的电源</code>才能良好支持这块显卡。但是TDP不等于实际功耗，官方参数往往有各种水分。</p>
<p><code>电源接口</code>：我对于这块也很懵逼，网上资料也不好找，下面的内容是从<a href="https://www.gamersky.com/hardware/201409/468317.shtml" target="_blank" rel="noopener">辅助供电真有必要？从供电接口看显卡发展</a>搬过来的。显卡性能越来越强，需要电源给显卡进行独立供电，目前多数独显都是6pin+8pin的规格，pin的意思就是针口，简单理解起来，同样的牌子，性能越强越强的显卡一般功耗越大，所以供电要求也越高，供电不足会导致降频，也就是性能发挥不出来，一般用来参考电源的选择，关于更多供电问题会在主板部分说明。</p>
<p><code>Crossfire</code>：双卡交火，也就是一台电脑怼上两块独立显卡，但是不要以为有两站显卡就代表性能是单张显卡的200%，双卡交火的提升其实是很有限的，一般提升130%，具体看计算任务类型，毕竟不是所有的计算任务都能分个并行在两张显卡上独立运行的。</p>
<p>照旧，官方数据图放上来做一下对比：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/rx590_param.png" alt="AMD的rx590官方参数"></p>
<p>总结一下：</p>
<ol>
<li><strong>显存位宽</strong>：显存对显示芯片的通道，决定显存在一个运算周期瞬间的吞吐量；<br>位宽不足会引起高分辨率下画面不流畅，或帧数不稳定现象，原因是显卡芯片没有充足 的数据来计算， 基本上128 Bit可以应付主流的高分辨率。</li>
<li><strong>显存频率</strong>显存的数据传输速度。</li>
<li><strong>显存容量</strong>显存可缓冲存储数据的容量。</li>
<li>1与2是决定性能的关键。</li>
</ol>
<blockquote>
<h4 id="公版与非公版是什么？"><a href="#公版与非公版是什么？" class="headerlink" title="公版与非公版是什么？"></a>公版与非公版是什么？</h4></blockquote>
<p>显卡还会涉及一个问题：什么是公版卡和非公版卡，到底买哪个？</p>
<p>公版卡是芯片厂商自己设计的整块显卡，因为在芯片生产出来后，各个合作板卡商都还没来得及为芯片设计电路板和散热，于是芯片厂商会自己设计一个方案让代工厂把整块显卡做出来（芯片厂商自己没有生产线，一般需要代工厂）给自己的新芯片做宣传和测试，所以当芯片面向市场发布的时候，公版卡永远是第一个上市的”新货”。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/NVIDIA_2080ti.jpg" alt="公版卡一般外观并不炫酷甚至有点朴素，公版gtx2080ti"></p>
<p>非公版卡就是板卡商拿到芯片之后自己设计方案生产出来的整块显卡，这里要注意，公版卡并不是芯片厂商才能生产的，板卡商拿到芯片的时候也会拿到芯片厂商原先设计的一套显卡设计方案，只是看板卡商是否采用而已。对于一款刚刚发布的显示芯片，更多板卡商需要详细了解其性能、功耗等诸多信息，才能为其量身定做，自行研发非公版板卡，所以通常他们会选择先投产少量公版显卡以抢占市场先机，然后用这些时间去研发非公版。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/ROG_2080ti.png" alt="非公版，花里胡哨的华硕gtx2080ti"></p>
<p>公版和非公版的概念清楚了，我们来看看两者的优劣，参考自<a href="https://www.zhihu.com/question/37170991" target="_blank" rel="noopener">到底显卡买公版还是非公？</a>和<a href="https://zhuanlan.zhihu.com/p/45816942" target="_blank" rel="noopener">公版显卡和非公版显卡有啥区别？</a>。</p>
<p>公版卡所谓的官方方案体现在性能稳定、自身保守 (低频或不能超频)以及豪华的用料上。一般公版卡默认频率低，超频空间小，可玩性差，散热差，而且价格昂贵，投产数量也十分有限，所以公版卡还会有人去收藏。另外公版卡还起到了定价的作用，非公版会围绕着公版卡的定价上下变动，但是不会偏得太厉害。最后，公版卡外观千篇一律，同一代显卡基本长得阿妈都分不清。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/meiqizao.jpeg" alt="gtx2080ti煤气灶，男人拿到会流泪的"></p>
<p>非公版分3种。一种是公版同款设计，在公版的电路上换个更好的散热，价格和公版持平；一种是超公版，加强供电，提高频率（帮你超频），加强散热（频率高发热就高），加大显存，价格在公版之上的土豪选择；一种是缩水阉割版，由于相对低端的芯片不需要那么好的供电的散热，板卡商会在这方面缩水，价格会降低。另外，非公版卡外观各有各家特点，想多炫酷就有多炫酷。</p>
<p>那么到底是买公版还是非公版？</p>
<p>公版的质量有着绝对的保障，但是价格过高令人望而却步。非公版的市场鱼龙混杂，有些厂商为公版卡换个散热器或者外壳就佯称非公版、超公版，从而卖出高价，又有一些厂家偷工减料，疯狂阉割，然后在型号后面加上一代二代、静音版等字样来混淆消费者。</p>
<p>公版一般与非公版的性能差距小于10%，在PCB、散热上做出较大改变，有些非公版是成本妥协的产物，有的则是加强了公版卡明显不足的地方。一般非公版确实存在明显的价格优势，性价比确实更高，同时有更多的外形选择，所以一般来说消费者会更偏向选择非公版，当然必须选大牌非公版，如微星、华硕、技嘉、蓝宝石等会稳很多。</p>
<blockquote>
<h4 id="不同显卡的优缺点"><a href="#不同显卡的优缺点" class="headerlink" title="不同显卡的优缺点"></a>不同显卡的优缺点</h4></blockquote>
<p>A卡和N卡目前最大的区别是“能效比不同”，能效比是衡量处理器（包括CPU和GPU）最重要参数，含义是每瓦性能对比，这方面N卡比A卡出色太多，这也是大多数人用N卡的原因之一（另外N卡知名度在圈子外的人眼里会更高），实际上N卡的技术某种程度确实比A卡好。有个梗是<code>A卡电表倒着走</code>，就是调侃A卡的功耗问题。举例：N卡的GTX1060 6G和A卡的RX580 8GB，性能上RX580还比GTX1060高大约3%，但满载功耗却要高大约70-80W，这是个非常巨大的差距，更高的功耗，并不是仅仅是多用点电费，而是更高的工作温度（长期高温的副作用是故障率会升高，缩短显卡寿命）。一分钱一分货，性价比高的同时换来其他的缺点。</p>
<p>其实也不能说死了两者的显卡就是有什么优缺点，市场定位不一样，每个价格区间都有N卡和A卡在竞争，从低端到高端市场无一例外，引用一篇文章的结论：</p>
<blockquote>
<p>The bottom line is, AMD is still a better choice for low-end and mid-range gaming setups, as it has been for a while now. Radeon cards simply present much better value for your money in this range. On the other hand, if you are ambitious and aiming for high framerates in QHD or even 4K , then Nvidia is the only real choice.</p>
<p>But of course, as already mentioned in the article, things might very well change in the near future.</p>
<p>—<a href="https://www.gamingscan.com/nvidia-vs-amd/" target="_blank" rel="noopener">NVIDIA vs AMD – Which Graphics Cards Are Better In 2019?</a></p>
</blockquote>
<blockquote>
<h4 id="矿卡潮？垃圾佬？三天回本，七天血赚！"><a href="#矿卡潮？垃圾佬？三天回本，七天血赚！" class="headerlink" title="矿卡潮？垃圾佬？三天回本，七天血赚！"></a>矿卡潮？垃圾佬？三天回本，七天血赚！</h4></blockquote>
<p>首先要知道什么叫<code>矿卡</code>，所谓矿卡就是专门用来挖矿的独立显卡，现在是19年了，18年是比特币最火爆的一年，批量显卡被拿去当做比特币挖矿计算的算力。旷工为了尽可能多尽可能快地挖矿，这些矿卡是非常惨的，被迫一天到晚24小时不间断满载计算，每一天都有一批矿卡熬不住部分损坏导致性能下降甚至永久损坏只能废掉，就是这样一批又一批矿卡顶着上，到18年后半年比特币泡沫爆炸，比特币的价值一落千丈，挖矿成本（电费、管理费、硬件费）已经比挖矿收益还要大了，矿工纷纷退场，矿卡便被低价甩卖流入市场，然后玩家们就可以用正常价的40%-60%将卡收进来，分分钟以垃圾卡的价格买到中高端显卡。当然矿卡有风险，流传的梗是<code>三天回本，七天血赚</code>😂，你运气不咋样，分分钟买回来的矿卡还没用上一两个月就报废了，而且还是正常使用的那种，毕竟矿卡本身的寿命已经被极度压缩了，运气好而且懂得怎么挑，比如在矿卡潮末期挑到那种只上岗两三个月的矿卡，那真的是血赚不亏了。</p>
<p>而A卡更是矿卡重灾区，原因可参考<a href="https://zhuanlan.zhihu.com/p/27644114" target="_blank" rel="noopener">显卡太贵？聊聊挖矿潮的正确避难姿势</a>，主要因为A卡的流处理器数量更多，并行运算量更大，穷举计算效率更高。A卡的RX480、470以及470的各个版本，是矿卡的重灾区。</p>
<p>然而现在已经矿卡潮基本已经过去了，市面上的矿卡逐渐变少，想买矿卡也不好买，买二手显卡也没那么担心买到差不多报废的矿卡，果然还是上车要趁早，机会不等人啊。</p>
<p><a href="http://tieba.baidu.com/p/5930641877" target="_blank" rel="noopener">小白扫盲向-矿卡入门知识</a></p>
<blockquote>
<h4 id="什么是马甲卡和甜品卡？"><a href="#什么是马甲卡和甜品卡？" class="headerlink" title="什么是马甲卡和甜品卡？"></a>什么是马甲卡和甜品卡？</h4></blockquote>
<p><a href="[https://baike.baidu.com/item/%E9%A9%AC%E7%94%B2/2611954?fr=aladdin](https://baike.baidu.com/item/马甲/2611954?fr=aladdin)">马甲</a>可是有百度百科词条的😂，定义：为了让认识你的人猜不到是你，在常用的用户名外再注册的其他名字，叫穿马甲，一般论坛明令禁止使用马甲 (也就是小号)闹事这种现象。顾名思义，马甲卡就是旧版显卡上套了个马甲，也就是换一个包装重新推到市面上，一般只是单纯将原的显卡主频或者其他参数微微提高而已，工艺制程等其他因素跟原显卡几乎没有什么实质性差别，性能也没有多大提升。</p>
<p>马甲卡是芯片厂商在不同价格互相竞争的产物，是争夺市场的一种手段，是市场策略而不是技术原因。芯片被研制出来，只有最大化规模生产，利润才会更大，对于厂商来说，追求的无非是利益最大化，而要想达到这个目标，就是要芯片最大程度利用起来，有两种方式可以利用好这些芯片，马甲和阉割，马甲可能就是挑一些生产过程中经过测试发现的体质好的芯片做另一次包装来吸引人，而阉割就是将GPU（显卡核心）的参数往下降，比如阉割显存位宽，降低显存容量等。</p>
<p><code>甜品卡</code>一般指千元价位，主打中端市场，性能适中性价比较高的显卡，以后你见到网上说什么卡是甜品卡的时候，你应该要明白这张卡是千元上下，性价比较高，适合普通玩家的意思了。</p>
<blockquote>
<h4 id="堆料的豪华版和阉割的乞丐版有多大差距"><a href="#堆料的豪华版和阉割的乞丐版有多大差距" class="headerlink" title="堆料的豪华版和阉割的乞丐版有多大差距"></a>堆料的豪华版和阉割的乞丐版有多大差距</h4></blockquote>
<p>看到网上同一个型号的显卡，有超多显卡厂商的产品，价格差别从一两百到大几百不等，是不是觉得很迷惑？明明显卡核心都一样，怎么价差就这么大呢？举个例子，A卡一线厂商和二线厂商同一个显卡核心的不同产品，可以查查<strong>蓝宝石 和 迪兰 的rx590</strong>价格对比。</p>
<p><a href="https://zhuanlan.zhihu.com/p/42960555" target="_blank" rel="noopener">为什么芯片型号相同的显卡，不同品牌会有那么大的差价</a></p>
<p>点亮机器实际上并不需要显卡的存在，不过图形界面的显示会很蛋疼（我没试过）。</p>
<blockquote>
<h4 id="其他趣事"><a href="#其他趣事" class="headerlink" title="其他趣事"></a>其他趣事</h4></blockquote>
<p>4G狂牛，8G疯牛，16G牛魔王，显示芯片要与显存匹配才有价值，否则就是搞笑。</p>
<p>咸鱼的二手显卡为什么如此便宜？一没保修，二可能是矿卡，三可能是，毕竟一分钱一分货，没有那个眼光不是老司机就不要作死。</p>
<p>GTX1050Ti这张显卡现在在圈子里绰号<font color="red">智商检测卡</font> ，只有傻子才去买它，因为同等价位的A卡性价比已经完全吊打它，有人在这个时候还去买GTX1050Ti，那证明绝对是小白。</p>
<p>还有个<code>最高级别认证伙伴</code>的概念，也就是被Nvidia和AMD官宣授予的称号，有得天独厚的质量保证。</p>
<hr>
<p>这篇博文烂尾了，在写作过程因为工作变更的原因，被中断了若干个月，再回来时发现写作思路已经无法衔接。本文写自2019年6月，实际上是在2020年4月才发出来，下面是我收集到的一些参考资料，感兴趣可以点进去看看。真的很想把它写好，但是博主对装机的三分钟热度已经结束😣，本来是打算写一个完整系列，包括cpu、显卡、内存、主板、机箱散热、电源、硬盘，相关的资料都收集了好多，未来如果心血来潮就让它们重见天日吧。</p>
<p>历史上还出现过<strong><a href="https://zhidao.baidu.com/question/65055866.html" target="_blank" rel="noopener">五虎显卡</a></strong>。</p>
<p>引用知乎的一个帖子：<a href="https://www.zhihu.com/question/42110806" target="_blank" rel="noopener">各个牌子的显卡有什么特点，哪些系列好？</a></p>
<p><a href="https://www.pc841.com/article/20160506-65859_all.html" target="_blank" rel="noopener">显卡参数知识扫盲：教你怎么看显卡好坏 (全文)</a></p>
<p><a href="https://www.pc841.com/article/20180412-88865_all.html" target="_blank" rel="noopener">显卡参数知识科普：避免这些显卡参数骗局！ (全文)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20600228" target="_blank" rel="noopener">消费陷阱——超大显存显卡你心动了么？</a></p>
<p><a href="http://tieba.baidu.com/photo/p?kw=图拉丁&ie=utf-8&flux=1&tid=4297521484&pic_id=befce61190ef76c630515c349a16fdfaae5167cb&pn=1&fp=2&see_lz=0" target="_blank" rel="noopener">超大显存骗小白 - 疯牛病显卡</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28892355" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28892355</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28892355" target="_blank" rel="noopener">二手9系卡购买指北（1/30修改）</a></p>
<p><a href="https://www.bilibili.com/video/av20730054/" target="_blank" rel="noopener">视屏：”矿卡”如何弄成”箱说全”的”自用卡”</a></p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>电脑配件</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>QA测试是否要看代码</title>
    <url>/2019/12/12/QA%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E8%A6%81%E7%9C%8B%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>以前有个RD同事问过我，为什么你做测试还要看代码，看代码干嘛！？</p>
<p>还有个RD在提测会议上当场说，QA不应该看代码，避免思维跟RD一样，那就测不出问题了（这个同学还是个准百度T7）……</p>
<p>必须得评价一下，对QA这样的认知应该是QA的职能存在一定误解。</p>
<p>假如需求在文档层面能描述清楚，功能实现的思路和细节在文档里写得明明白白，贴上关键代码及相关解释，当然可以省掉QA测试看代码的环节，只是RD习惯输出从简，或者并不了解QA的想法或工作方法。看代码的作用就是为了填补QA对细节实现上信息不对称的gap，有时这种gap会浪费QA长达几个小时的时间。举个例子：有些较为繁琐的嵌套判断逻辑，或者一些corner case，RD懒得在文档写得这么清楚，当QA测试到这里后看到程序表现在文档中没有说明，往往无法确认该现象是否符合预期，随之而来就是沟通的时间成本。</p>
<p>在实际测试中，真的经常碰到类似的情况，在测试过程中随着对功能理解的越发细致，会突然想到某个corner case，但是文档没有体现相关的处理逻辑，此时我一般会选择走读代码check是否有对应处理，找不到或者看不懂再问RD，这样对RD也会友好一些。</p>
<p>产品本身是由一个一个功能模块组成的，我们可以对产品的功能十分熟悉，在手上把玩自如，这是在黑盒层面上去理解一个产品，或许可以把玩出一些味道，明白产品为什么在功能和UI细节上如此这般设计、产品为什么能吸引用户留住用户、产品如何做选择来支撑它的发展壮大，又或者通过用户数据和指标的分析，找出用户增长点，这是pm的方式。</p>
<p>pm的方式对于技术人员是性不太通，产品的设计和产品的实现，总是会存在gap，这也就是为什么pm认为合理的需求有时候在技术实现上十分困难（技术也有技术债或历史包袱！）。要真真实实摸清产品，就不能只停留在宏观层面，得深入到技术层面。每一个功能模块，它在代码层面映射出来的是多个代码模块，不同的代码模块提供什么能力支撑，互相如何合作，甚至是产品技术选型的初衷和优劣势及其演进，这些都是理解产品生命周期的重要线索。同时在产品背后，支撑产品的一整套周边系统，要足够清晰，花的时间一点也少不得。</p>
<p>当然还是要补充一个观点，深入到代码，有时可以让我们掌握更多信息，但是有时又会让人陷入细节失去大局观，各有不同应用场景。</p>
<p>我觉得上面这个理由已经足够支撑QA去看代码了，如果是真的想好好融入到这个产品的建设中去添砖加瓦，而不是单纯的【我只是来打工】的心态。</p>
<p>最后，QA很多时候就是充当一个打破规律的人，拿着一些奇奇怪怪的case和问题去挑战RD的脾气🤣，有些代码实现本身就导致corner case无法修复，看代码来提前只细问题有没有可能被修复，可以大大降低RD心态爆炸的概率。或者自己就可以找到修复方案给RD提点意见，蹭蹭蹭在RD心中提高一下地位，还是不错的~</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>code review</tag>
        <tag>白盒</tag>
      </tags>
  </entry>
  <entry>
    <title>cvechecker调研分享</title>
    <url>/2018/08/02/cvechecker%E8%B0%83%E7%A0%94%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="cvechecker"><a href="#cvechecker" class="headerlink" title="cvechecker"></a><strong>cvechecker</strong></h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>cvechecker是一个工具，会根据你提供的软件列表自动确认装在本机的软件的相应版本，然后跟网上的在线数据库（database of potential vulnerable software）进行漏洞与软件版本的匹配，发现可疑漏洞会报告。</p>
<br>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h3><ul>
<li><strong><em>CVE</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>V</strong>ulnerabilities and <strong>E</strong>xposures：通用漏洞披露（维基百科）</p>
<p>CVE：A list of entries — each containing an identification number, a description, and at least one public reference — for publicly known cybersecurity vulnerabilities. </p>
<p>格式：CVE-YYYY-NNNN；YYYY为西元纪念，NNNN为流水编号</p>
<p>例子：2014年发现的心脏出血漏洞（Heartbleed bug）编号为 CVE-2014-0160</p>
<ul>
<li><strong><em>CPE</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>P</strong>latform <strong>E</strong>numeration</p>
<p>一种结构化的命名规范/标准。</p>
<p>例子：</p>
<p>规范的版本较多，对于一个这样的信息：<br>[part=”a”,vendor=”microsoft”,product=”internet_explorer”,version=”8.0.6001”,update=”beta”]</p>
<p>CPE格式可以如下：</p>
<p>cpe:2.3: a:microsoft:internet_explorer:8.0.6001:beta:*:*:*:*:*:*</p>
<ul>
<li><strong><em>CVSS</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>V</strong>ulnerability <strong>S</strong>coring <strong>S</strong>ystem：通用漏洞评分系统</p>
<p>它是工业标准，用于描述安全漏洞严重程度的统一评分方案。</p>
<a id="more"></a>

<hr>
<h3 id="cvechecker的安装"><a href="#cvechecker的安装" class="headerlink" title="cvechecker的安装"></a><strong>cvechecker的安装</strong></h3><ol>
<li>官方下载压缩包解压</li>
<li>进入cvechecker的根目录，运行 <code>./configure</code> 开始配置</li>
<li>运行 <code>make</code></li>
<li>运行 <code>make install</code> </li>
<li>完成安装</li>
</ol>
<p>注意点：运行 <code>configure</code> 不成功的话，可能先需要解决一些依赖问题。cvechecker默认使用sqlite3来管理cve数据，支持sqlite、sqlite3、mysql，如果使用mysql需要做一些额外的配置，具体可以参考<a href="https://www.zhihu.com/question/37822443" target="_blank" rel="noopener">这个链接</a>。</p>
<br>

<h3 id="cvechecker的使用"><a href="#cvechecker的使用" class="headerlink" title="cvechecker的使用"></a><strong>cvechecker的使用</strong></h3><ol>
<li><p><code>cvechecker -i</code></p>
<p>在本机初始化数据库（默认使用sqlite3），用来存储网上下载到本地的CVE，在我的ubuntu上试验的时候，初始化数据库会在目录 /usr/local/var/ 中创建名叫cvechecker文件夹，需要root权限来运行。当然可以直接修改cvechecker根目录下conf文件夹中的 <code>cvechecker.conf</code> 文件来改变数据库存放的位置</p>
</li>
<li><p><code>pullcves pull</code></p>
<p>该命令会自动从网络下载CVE数据，存到数据库中去</p>
</li>
<li><p>准备工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -path /mnt -prune -o -path /media -prune -o -type f -perm -o+x &gt; scanlist.txt</span><br><span class="line">echo "/proc/version" &gt;&gt; scanlist.txt</span><br><span class="line">cvechecker -b scanlist.txt</span><br></pre></td></tr></table></figure>

<p>每一次系统软件有更改，都需要让cvechecker重新加载系统安装的二进制文件清单。cvechecker不会去自动重新加载文件清单，更加不会去感知系统软件版本的变动。所以需要手动使用 <code>find</code> 命令去感知所有executable commands和libraries</p>
</li>
<li><p><code>cvechecker -r</code> or <code>cvechecker -r -C &gt; output.csv</code></p>
<p>启动检查，cvechecker会打印出一个漏洞列表，加一个 -C 选项会打印出csv格式。</p>
<p>更加具体详细的命令选项，可以参考<a href="https://www.mankier.com/1/cvechecker" target="_blank" rel="noopener">链接</a>。</p>
<br>

</li>
</ol>
<h3 id="cvechecker扫描结果解读"><a href="#cvechecker扫描结果解读" class="headerlink" title="cvechecker扫描结果解读"></a><strong>cvechecker扫描结果解读</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;/home/zingphoy/Software/odp/lib/gcc-3.4.5/libsasl2.so.2&quot; (CPE = cpe:/a:carnegie_mellon_university:cyrus-sasl:2.1.19::￼:) on host ubuntu (key ubuntu)</span><br><span class="line">  Potential vulnerability found (CVE-2009-0688)</span><br><span class="line">  CVSS Score is 7.5</span><br><span class="line">  Full vulnerability match (incl. edition/language)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一段是具体的文件匹配到了一个具体的CPE信息</li>
<li>第二段是相应的CVE编号</li>
<li>第三段是CVSS分数</li>
<li>第四段是匹配出一个漏洞的可能性</li>
</ul>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><p>cvechecker的核心功能就是拿到软件的版本号，然后根据规则去匹配cve漏洞库，cvechecker是怎么做的呢？Sven（开发者）没有依赖于包版本管理器，而是直接通过查找软件包的版本号，然后构造CPE（Common Platform Enumeration）信息，通过在cve数据库中查找给CPE信息来提取CVE信息。每个软件包都包含了众多的软件，如ls和cat都属于coreutils,那么如何从系统软件列表差找到软件包列表及版本号便是Sven方法的关键所在。通过查看代码发现，Sven自己维护了一个软件包和各个命令的映射关系表。内容类似于：</p>
<blockquote>
<p>,perlivp,1,perlivp$,# perlivp v([0-9][0-9]<em>(.[0-9]+)+),a,perl,perl,\1,,,<br>,libvorbis.so,1,libvorbis.so.</em>,Xiph.Org libVorbis ([0-9][0-9]*(.[0-9]+)+),a,xiph,libvorbis,\1,,,</p>
</blockquote>
<p>看过cvechecker帮助文档的用户都知道，用户自己也可以定义添加这种映射表，而默认的映射表是由Sven自己维护的，默认只有<a href="https://github.com/sjvermeu/cvechecker/blob/master/versions.dat" target="_blank" rel="noopener">650条</a>，因此这里就是漏报的一处主要原因。</p>
<p>这个映射表解决了从命令到软件包的映射，但怎么获取软件包的版本号呢？继续看代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Here is where the various version extraction methods are supported.</span></span><br><span class="line"><span class="comment"> * We currently still only support a single method (1, which is the</span></span><br><span class="line"><span class="comment"> * "strings -n 3 &lt;file&gt;" command execution) but now we can see if we can</span></span><br><span class="line"><span class="comment"> * support additional methods as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (filetype == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[BUFFERSIZE];</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        zero_string(buffer, BUFFERSIZE);</span><br><span class="line">        ret = strings_extract_version(ws, &amp;preg, pmatch, &amp;cpe_data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                add_to_sqlite_database(ws, cpe_data);</span><br><span class="line">                cpe_to_string(buffer, BUFFERSIZE, cpe_data);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">" - Found match for %s/%s:\t%s\n"</span>, ws-&gt;currentdir, ws-&gt;currentfile, buffer);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" ! %s/%s: The sqlite3 implementation currently doesn't support file type %d\n"</span>, ws-&gt;currentdir, ws-&gt;currentfile, filetype);</span><br><span class="line">&#125;;</span><br><span class="line">ws-&gt;rc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原来是通过strings读取二进制程序中的标示，然后通过正则表达式来提取其中的版本信息。系统中的软件多种多样，尽管有默认的编程约定，但不同的开发者肯定会使用不同的声明方式，难免会无法找到或找错版本信息。此外，各个发行版本在发现CVE时往往采用<a href="https://zh.wikipedia.org/wiki/向後移植" target="_blank" rel="noopener">backporting</a>策略，因此即使CVE已经修复，软件包的大版本号也不会发生变化，这也是引起误报的主要原因。</p>
<p>更具体看函数调用（可上github自查）—— strings_extract_version( )的声明和实现：</p>
<p><a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c" target="_blank" rel="noopener">cvechecker</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c/src" target="_blank" rel="noopener">src</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c/src/output" target="_blank" rel="noopener">output</a>/<strong>stringscmd.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../cvecheck_common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../swstring.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Sven Vermeulen.</span></span><br><span class="line"><span class="comment"> * Subject to the GNU Public License, version 3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings_extract_version - Method for extracting the version from the file using the strings command</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strings_extract_version</span><span class="params">(struct workstate * ws, <span class="keyword">regex_t</span> * preg, <span class="keyword">regmatch_t</span> * pmatch, struct cpe_data * cpe)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e" target="_blank" rel="noopener">cvechecker</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e/src" target="_blank" rel="noopener">src</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e/src/sqlite3" target="_blank" rel="noopener">sqlite3</a>/<strong>sqlite3_impl.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlite3_impl.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strings_extract_version</span><span class="params">(struct workstate * ws, <span class="keyword">regex_t</span> * preg, <span class="keyword">regmatch_t</span> * pmatch, struct cpe_data * cpe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * stringcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> file[FILENAMESIZE];</span><br><span class="line">    <span class="keyword">char</span> data[FILENAMESIZE];</span><br><span class="line">    FILE * workfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">config_setting_t</span> * stringcmdcfg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * buffer;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> retv;</span><br><span class="line">    </span><br><span class="line">    zero_string(data, BUFFERSIZE);</span><br><span class="line"></span><br><span class="line">    stringcmdcfg = config_lookup(ws-&gt;cfg, <span class="string">"stringcmd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (stringcmdcfg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Configuration file does not contain stringcmd directive.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    stringcmd    = config_setting_get_string(stringcmdcfg);</span><br><span class="line">    <span class="keyword">if</span> ((swstrlen(stringcmd) == <span class="number">0</span>) || (swstrlen(stringcmd) &gt; FILENAMESIZE<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Configuration files 'stringcmd' directive cannot be empty or exceed %d characters\n"</span>, FILENAMESIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (swstrlen(ws-&gt;currentdir)+swstrlen(ws-&gt;currentfile) &gt; FILENAMESIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"File path cannot exceed %d characters\n"</span>, FILENAMESIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">"%s/%s"</span>, ws-&gt;currentdir, ws-&gt;currentfile);</span><br><span class="line">    buffer = substitute_variable(stringcmd, <span class="string">"@"</span>, <span class="string">"@"</span>, <span class="string">"file"</span>, file);</span><br><span class="line"></span><br><span class="line">    retv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    workfile = popen(buffer, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(data, FILENAMESIZE, workfile) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[FILENAMESIZE<span class="number">-1</span>] != <span class="number">0x00</span>) </span><br><span class="line">            data[FILENAMESIZE<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[swstrlen(data)<span class="number">-1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            data[swstrlen(data)<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    rc = regexec(preg, data, <span class="number">16</span>, pmatch, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">        retv = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Found a match, extracting version (but first, print it out)</span></span><br><span class="line">        <span class="keyword">for</span> (rc = preg-&gt;re_nsub; rc &gt; <span class="number">0</span>; rc--) &#123;</span><br><span class="line">            retv += search_and_substitute_group(preg, pmatch, data, cpe, rc);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    zero_string(data, FILENAMESIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(workfile);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> retv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到此，cvechecker已经获取了系统软件包列表以及软件包对应的版本号，将该信息处理成CPE信息，在CVE列表中查找即可。</p>
<hr>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>扫描速度快，扫描时资源占用少，程序不用需要后台运行，默认配置即可覆盖常用的软件</li>
<li>当扫描规则支持得越丰富，cvechecker的威力就会越大，从某种程度上说它是一个成长性的扫描工具，通过人为配置（如同WAF添加规则一样），作用会越来越强大</li>
<li>cvechecker虽然无法准确的查询出当前系统的cve信息，但是很好的解决了不同Linux版本中包管理器差异的问题，底层依赖较少</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>cvechecker处理中涉及到众多的映射信息，如程序和软件包的映射表、CVE列表，默认会下载当前所有的CVE信息，使用数据库来组织这些映射信息，需要占用不少磁盘空间，截止至2018-08-02，nvdcve漏洞信息的文件就有820MB大小</li>
<li>难以保证漏报率，需要进行大量人工干预</li>
</ul>
<br>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>作为主机软件安全的基准扫描，由于扫描时消耗的资源也不是特别大，可以作为例行扫描来使用；</p>
<p>除了在单台机器上都部署一个cvechecker之外，这里考虑一种集中式的cvechecker。本身cvechecker并不需要长期后台运行，只需要给它一个cpe信息它就可以开始匹配，所以可以试着做成一个后台服务器，上面部署cvechecker，其他机器上装一个agent例行收集机器上软件的cpe信息。agent把收集的信息发送到服务器让上面cvechecker完成匹配工作再返回结果。当然这里的额外工作量就是完成一个收集cpe信息的agent，肯定涉及到不少的兼容工作，而且部署在server上的cvechecker本身的软件版本侦查能力也被浪费了。这样做好处就是可以不用再每一台机器上都拉去nvdcve漏洞信息，可以省去不少磁盘空间，并且只需要维护一套匹配规则，更加方便人为配置匹配规则，而后台负责匹配的cvechecker也可以做成集群式，只要数据库和匹配规则适当地分发下去，就可以连续高负载地匹配漏洞。</p>
<p>对于特殊的、硬件环境较为低端苛刻的服务器，上面只部署了极少数的软件服务，而且存储空间十分小，可考虑使用watchlist功能，手动配置需要扫描的软件的CPE信息，而不需要从网上拉取一个巨大的数据库存在本地。</p>
<hr>
<h2 id="对比公司内部项目"><a href="#对比公司内部项目" class="headerlink" title="对比公司内部项目"></a><strong>对比公司内部项目</strong></h2><p>内部某项目的资产、指纹收集功能也是收集软件和类库的版本号，主要的技术手段是调用软件的shell命令或find文件名，再去截取版本号。这种方案是针对性地获取版本号，覆盖类库&amp;软件若干种。将这些版本号上报到后台，后台会进行CVE版本匹配，找出对应的软件版本是否存在已知CVE漏洞。</p>
<p>部分已脱敏的golang代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g_ClassLibraryInfo = []ClassLibraryInfo&#123;</span><br><span class="line">    &#123;<span class="string">"apr"</span>,<span class="string">"libapr-1.so.0"</span>,<span class="string">"ldconfig -p|grep libapr-|head -1|cut -d '&gt;' -f 2"</span>,<span class="string">"ldconfig -p|grep libapr-|head -1|cut -d '&gt;' -f 2|cut -d '.' -f 3"</span>,<span class="string">""</span>&#125;,</span><br><span class="line">    &#123;....&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> <span class="string">"apr"</span>:</span><br><span class="line">    classlibpath, classlibversion = GetLibInfo(<span class="string">"libapr-"</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"apr-util"</span>:</span><br><span class="line">    classlibpath, classlibversion = GetLibInfo(<span class="string">"libaprutil"</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">case</span> ...</span><br></pre></td></tr></table></figure>

<p>获取软件版本号似乎市面上还没有一个通用的方案，cvechecker也需要针对性地获取软件版本。cvechecker主要是通过编写匹配规则来针对性获取，可以看配置文件 <a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">cvechecker</a>/<strong>versions.dat</strong> ，获取方法上面已经分析过了，就是利用strings命令+正则的方式来匹配版本号，其优点就是不同Linux系统都比较通用（内部的方案其实也是比较通用的，至少在公司需要兼容的几种系统上没有特别问题），但是没有明显数据支撑两者到底哪一个更好，所以这里拿不出高下之分的定论。</p>
<p>缺点也是很明显的，如果软件版本号格式一旦修改，那么规则都会对新的版本号失效，不过一般正规有名气的软件发行到市面上的版本号格式都比较固定，所以不需要担心这个问题。</p>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="https://www.jianshu.com/p/944618676dae" target="_blank" rel="noopener">漏洞扫描基本概念</a></p>
<p><a href="cpe.mitre.org">CPE官网</a></p>
<p><a href="https://cve.mitre.org/index.html" target="_blank" rel="noopener">CVE官网</a></p>
<p><a href="https://nvd.nist.gov" target="_blank" rel="noopener">Natinal Vulnerability Database - CVE数据库</a></p>
<p><a href="https://cpe.mitre.org/specification/1.1/cpe-specification_1.1.pdf" target="_blank" rel="noopener">cpe格式详解</a></p>
<p><a href="https://www.mankier.com/1/cvechecker" target="_blank" rel="noopener">cvechecker官方使用文档</a></p>
<p><a href="https://github.com/sjvermeu/cvechecker/blob/master/docs/cvechecker.1" target="_blank" rel="noopener">cvechecker的github文档</a></p>
<p><a href="http://www.seteuid0.com/cvechecker实现分析/" target="_blank" rel="noopener">cvechecker实现原理分析</a></p>
<p><a href="http://blog.siphos.be/2011/04/cvechecker-3-0/" target="_blank" rel="noopener">cvechecker 3.0</a> </p>
<p><a href="https://www.oschina.net/question/11_6205" target="_blank" rel="noopener">如何选择漏洞扫描工具（扫盲帖）</a></p>
<p><a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">cvechecker的github仓库</a></p>
]]></content>
      <categories>
        <category>调研</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>调研</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>一个高效的会议</title>
    <url>/2020/01/04/%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<p>最近工作汹涌而至，半个月没更新了，一上来标题就不自觉写成【2019-】，原来已经是新的一年了。个人github page博客从18年开始写，个人年度总结也是从18年开始写的，眼看着就要写2019年年度总结，到时候在这里补个链接。</p>
<p>好了，题外话说这么多，这一次的主题在两三个星期前其实已经有想法了，主要是在字节也开过不少低效的会议，这是对时间的一种奢侈的浪费。有句话是这么说的【如果你想消磨时光，会议是最好的工 具】，一个会议的成本由下图的公式来计算，直观感受一下无聊低效的会议室多么费钱:-p。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/meeting_cost.png" alt="会议成本"></p>
<h3 id="会议主题"><a href="#会议主题" class="headerlink" title="会议主题"></a>会议主题</h3><p>如果会议连基本的主题都搞不清楚，那还开个鬼哦。会议也分很多种，如通知型、讨论型、交流型、复盘型等，每种类型的会议都有它的主题，但是过程会有区别。主题的存在本身不只是会议的一个代号，更重要的，它是这个会议的指导方向，它代表这次会议要解决什么问题。</p>
<p>如果不能很好地提炼一个简洁精确的会议主题，或者会议主题不够精细过于宏大，那就要拆分会议。其实这就像写代码，你单个函数想做的事情太多，证明你没做好充分的抽象，此时你就要把这个大函数进一步拆分成若干个小函数。</p>
<h3 id="待解决的问题清单"><a href="#待解决的问题清单" class="headerlink" title="待解决的问题清单"></a>待解决的问题清单</h3><p>问题清单直观体现整个会议的流程，给人一个一二三四步的明确感受。<strong>往往低效的会议就是没提前梳理问题清单</strong>，一个问题完结了不知道下一个该讨论的问题是什么，会议进程全靠当场拍脑袋决定，拍出来的问题，东一个西一个没有条理也不连贯，这样不仅低效，还有可能漏掉关键问题没有解决。</p>
<h3 id="会议结论"><a href="#会议结论" class="headerlink" title="会议结论"></a>会议结论</h3><p>会议的目的就是要得出结论，不然开完会什么都不剩下那这个会就是在浪费公司的钱。待解决的问题要出一个结论，如果不能会议上当场给出结论，那至少应该给出一个解决步骤一二三四五，而不是讨论到半路，就说我下去看一下，等会给个结论……一般这种操作，就是烂尾会议，问题还是没解决，大家在IM上可能踊跃发言，然而不会剩下什么东西。</p>
<p>待解决的问题即使最后没得出解决方案，但是如果明确了后续步骤或者排除了一些弯路，客观上依然算是个结论。</p>
<h3 id="主持人"><a href="#主持人" class="headerlink" title="主持人"></a>主持人</h3><p>主持人关乎着会议质量，负责时刻警惕着有没有偏离主题并及时把与会人的思维拉回来，尤其是与会人思维发散得比较厉害的时候，典型场景是与会人问的问题一个接一个，越来越偏离会议，这时主持人要适当提醒与会人当前的主题并引导大家的思维走回正轨。</p>
<p>除了上面说的，主持人还要选择正确的与会人。会议一般会牵涉不同角色，有时候某一方的关键人因时间冲突无法参会，就会派一个代表过来参会，然而这个临时代表往往什么都不知道，基本上来到就是做个样子，不会发表观点也不能完整了解会议主题，只是一个摆设。这个会议要不就选择另一个时间开，要不就会后同步结论到缺席关键人即可，不需要再浪费这个临时代表的时间。</p>
<h3 id="会议节奏"><a href="#会议节奏" class="headerlink" title="会议节奏"></a>会议节奏</h3><p>会议节奏说得抽象，直观一点就是时间把控和思维引导，这些对主持人有所要求。</p>
<p>时间把控建立在大家的时间观念和主持人对待解决问题的清晰程度上，典型的失败的会议组织——关键与会人可能因为未及时通知或时间冲突等各种缘由迟到，或者因为设备技术故障拖了大几分钟甚至半小时才上线参会（我真的经历过，在会议室等了半个多小时才开😑，我又不能走）。为了避免这些情况，主持人需要提前做一下提醒工作，选择好合适的开会时间（比如在深圳选择2点开会效果就很差，因为很多人会午睡，睡醒起来整理一下就是2点10分，经常迟到😑）。</p>
<p>主持人一定要事先对会议问题有过思考，也许可能想不出结果，但是在会议上抛砖引玉引导与会人的思维，保持大家踊跃发表观点意见的气氛，让与会人不要太懒散，这样对会议才是利好的，才能推动会议进程。</p>
<h3 id="及时解散无关与会人"><a href="#及时解散无关与会人" class="headerlink" title="及时解散无关与会人"></a>及时解散无关与会人</h3><p>如果只是需要别人的在会议过程偶尔的支持一下，澄清一点什么事实，那就不要邀请别人参会，应该尽量在会前获取足够的支持资料，恰当安排会议流程。提前做了这些功夫，如果会议现场真的需要别人支持，lark加急然后安排下一个不冲突的议题即可，而不是强行拉别人过来坐在旁边【陪着】你们开会，浪费别人一堆时间。在会议室里工作真的不好受，凳子不舒服，没有外接屏幕，缺少纸笔，被开会的人吵着，还要时不时跟上会议看看自己需不需要说点什么，真的很低效，干不了什么有意义的事情🙂。</p>
<h3 id="会议纪要"><a href="#会议纪要" class="headerlink" title="会议纪要"></a>会议纪要</h3><p>会议室一个过程，没有人可以记得住这一个小时的会议每分每秒发生了什么，会议纪要要书面记录会议进程（如提出过什么方案但是被否决）和会议结论（如解决方案，TODO）外，这样才能确保会议的结论<strong>可被执行</strong>，不是为了表现出自己很踊跃参与工作事务跑去开会出来之后啥也没有。</p>
<h3 id="会议方式"><a href="#会议方式" class="headerlink" title="会议方式"></a>会议方式</h3><p>周会或者什么沟通会，基本上是最浪费时间的会议，因为这些会议的主持人往往是现场读资料，然后挑着点问与会人问题，这个有多低效就不说了……主持人都不提前读资料整理问题，这些时间成本就要搬到会议上，而且消耗的不是个人时间，而是集体时间。而与会人往往又是个复读机，照着资料读，不会挑重点，真的很没意思，这到底是没挑重点来讲，还是资料上给的内容除了重点之外再无更多补充内容？</p>
<hr>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/good_participant.png" alt="其中最好的与会者"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/bad_participant.png" alt="其中最坏的与会者"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结一下：</p>
<ol>
<li><p>明确议题，主持人要提前梳理问题清单</p>
</li>
<li><p>主持人选择恰当的与会人</p>
</li>
<li><p>主持人和与会人要提前阅读相关资料，整理问题和发言，提前思考</p>
</li>
<li><p>主持人把控会议时间和进程，与会人准时参会</p>
</li>
<li><p>主持人引导思维，与会人积极思考发言</p>
</li>
<li><p>有完备的会议纪要，确保会议结论落地</p>
</li>
</ol>
<p>重要参考链接：<a href="https://www.plantronics.com/content/dam/plantronics/documents-and-guides/zh_cn/ebooks/better-meeting-blueprint-ebook-zh-cn.pdf" target="_blank" rel="noopener">better-meeting-blueprint-ebook-zh-cn.pdf</a></p>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>会议</tag>
        <tag>合作</tag>
      </tags>
  </entry>
  <entry>
    <title>个人目标管理</title>
    <url>/2020/02/20/%E4%B8%AA%E4%BA%BA%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>最近任务接得比较多，甚至交了智商税浪费了大半天做一件吃力不讨好的事情，由此引发出对个人进度管理的思考。日常工作接触到更多的是团队目标管理，网上有大把的文章介绍团队管理方法论、工具、计划模板，依葫芦画瓢我也能学来一点手段，但似乎总是没法get到实在的点，这个星期的经历似乎有所收获。</p>
<p>为什么每次定OKR都很痛苦，review OKR时更痛苦？因为定OKR的时候想得好痛苦，review OKR时很多目标又没有完成甚至没有开始做，中间还穿插了很多OKR之外的事情😂。这些计划之外的事情我们也不能说它没有意义，它可能是一些紧急不重要的事，也可能也是紧急且重要我们必须得做的事，包括但不仅限于别人突如其来的合作、上司突然排下来的额外工作、当前状况必须马上着手的建设。跟OKR冲突的时候应该怎么做？这就设计到个人时间管理了。</p>
<p>我也没什么特别好的术语可以表达，在我的理念里应该有下面4个点（简化场景，不讨论项目维度的成本、质量等问题）：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>细分任务</th>
<th>里程碑</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>要做什么，做到多少分？<br>SMART原则</td>
<td>目标拆解，细分到每周每日需要完成的任务<br>周期性check</td>
<td>短期进度deadline<br>灵活松紧</td>
<td>很多任务前，理智挑拣</td>
</tr>
</tbody></table>
<ul>
<li><strong>目标</strong></li>
</ul>
<p>目标是工作中交流做多的点，工作目标的制定大多数情况都要跟别人一起商量讨论得出，或者自己有思路再跟别人一起讨论细化，就不多说了，SMART原则来指导目标的制定，不会太差。</p>
<ul>
<li><strong>细分任务</strong></li>
</ul>
<p>往大目标的方向，往下拆解，为了完成目标，需要达成什么什么样的条件，细化到每周要完成什么工作，甚至是每天要完成什么工作，这样才是更加【可把控】的进度，可以更直观地感受到进度的压力，防止潜在的进度失控风险。但要注意不要过度细化，因为细化本身就有成本，未来的事情是有很大不确定性的，一天8小时工作，可能有4小时就被其他突然插入的事情占据，所以不要抠得太精确。</p>
<ul>
<li><strong>里程碑</strong></li>
</ul>
<p>更好的做法应该以里程碑作为短期的目标，一个一个达成，在感官上直接传达进度信息，对于自己或是关心项目的他人，都有很好的项目管理效果。里程碑可以是一个or多个细分任务的deadline，或者我们不应当把里程碑只理解成deadline，它更大的作用还是进度把控而不是进度压力（虽然往往进度压力来源于进度把控🤣）。</p>
<ul>
<li><strong>优先级</strong></li>
</ul>
<p>你不用去找事情，事情自然会来找你，工作是永远都做不完的，就需要引入事情优先级。工作做不完，但是工作有轻重缓急之分，不是来一个任务就要做一个，有时为了支持别人随口说的一个不成熟的想法，莽撞地撸起袖子就是埋头干，做了好些工作后发现其实做出来意义没有想象那么大，投入的时间精力就白白浪费了，反而还会拖累核心任务的进度。应对办法就是识别出任务的优先级，不要轻易开始一个没经思考和讨论的工作。别人也许也不清楚事情的难易，自己马上接过来热火朝天干是不理智的。最终要的效果应该是在保证核心任务的进展下，我们拿出余力去完成计划之外的事情。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/self_time_management.png" alt="时间管理"></p>
<p>某天突然看到了这个视频【<a href="https://mp.weixin.qq.com/s/CETheAYqXcRHwOzV01PDiw" target="_blank" rel="noopener">时间管理，除了紧急度和重要度，还有什么？</a>】，然后自己本周马上中招了，原因是自己接任务的时候没有留buffer，突发插入若干高优任务导致排期失控，最终某个需求没能赶上当周版本，幸好是对上线时间不敏感的技术需求，不然就😶了。概括视频的意思，就是告诉我们要考虑事情是否有深远的意义，再判断是否需要自己处理，还是决定将事情委托给别人。事情除了紧急、重要两个维度外，还有在影响上的时间维度。life is short，尽量只做自己该做的事情，原话就是：</p>
<ul>
<li>How <strong>soon</strong> does it matter</li>
<li>How <strong>much</strong> does it matter</li>
<li>How <strong>long</strong> does it matter</li>
</ul>
<p>（我简直是渣翻……）</p>
]]></content>
      <categories>
        <category>自我管理</category>
      </categories>
      <tags>
        <tag>推荐阅读</tag>
        <tag>目标管理</tag>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title>【python源码探究】dict的key不能是list</title>
    <url>/2020/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88dict%E7%9A%84key%E4%B8%8D%E8%83%BD%E6%98%AFlist/</url>
    <content><![CDATA[<h2 id="一条面试题"><a href="#一条面试题" class="headerlink" title="一条面试题"></a>一条面试题</h2><p>本文源自一条最常见的python面试题：</p>
<blockquote>
<p>问：list对象能不能做dict的key？tuple呢？</p>
<p>答：不能，因为list是Mutable类型，不能作为dict的key。而tuple是Immutable类型，可以作为dict的key。</p>
</blockquote>
<p>咱们做个实验，从<code>dict</code>的赋值代码抛错来感受一下上面的答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[l]=<span class="number">123</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure>

<p>抛错已经说明白了，因为<code>list</code>是unhashable类型，所以能否hashable就是关键点，再来看<code>list</code>与<code>tuple</code>之间在hashable上的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">'__repr__'</span>: &lt;slot wrapper <span class="string">'__repr__'</span> of <span class="string">'list'</span> objects&gt;, <span class="string">'__hash__'</span>: <span class="literal">None</span>, ...&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">'__repr__'</span>: &lt;slot wrapper <span class="string">'__repr__'</span> of <span class="string">'tuple'</span> objects&gt;, <span class="string">'__hash__'</span>: &lt;slot wrapper <span class="string">'__hash__'</span> of <span class="string">'tuple'</span> objects&gt;, ...&#125;)</span><br></pre></td></tr></table></figure>

<p>这里注意到魔法方法<code>__hash__</code>，在<code>list</code>类型中<code>__hash__</code>实现为None，而<code>tuple</code>持有对应的实现。我们大胆猜测一下，<code>tuple</code>之所以hashable是因为实现了<code>__hash__</code>，再做个验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.__hash__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'NoneType'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.__hash__()  <span class="comment"># 从输出的形式来看，这很可能就是对象的hash值</span></span><br><span class="line"><span class="number">2528502973977326415</span></span><br></pre></td></tr></table></figure>

<p>这样子的黑盒试验终究是没办法让人放心，难道真的只是因为<code>__hash__</code>方法的实现与否吗？尝试看<code>list.__hash__</code>和<code>tuple.__hash__</code>的源码，由于函数是由python解释器直接实现，所以无法得到更进一步的结论。为了整明白这个问题，这里拿官网下载python 3.8.2 的CPython源码继续深入探究。我们有两种思路：</p>
<ul>
<li>知道<code>dict</code>的赋值是调用魔法方法<code>__setitem__</code>，追溯该方法一层一层往下看，寻找出关键判断hashable的条件</li>
<li>按照<code>dict</code>赋值的抛错文案进行全局搜索，直接定位相关代码</li>
</ul>
<h2 id="定位抛错文案"><a href="#定位抛错文案" class="headerlink" title="定位抛错文案"></a>定位抛错文案</h2><p>显然第二种反推思路效率会更高一些（实际上第一种思路是不通的，因为<code>dict.__setitem__</code>下面就是C源码，在python层没法得到更多信息），通过全局搜索<code>unhashable type</code>这个文案定位到两处python的C源码，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置：Modules/_ctypes/_ctypes.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Py_hash_t <span class="title">PyCData_nohash</span><span class="params">(PyObject *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyErr_SetString(PyExc_TypeError, <span class="string">"unhashable type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************分割线****************************** //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件位置：Objects/object.c</span></span><br><span class="line"><span class="function">Py_hash_t <span class="title">PyObject_HashNotImplemented</span><span class="params">(PyObject *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyErr_Format(PyExc_TypeError, <span class="string">"unhashable type: '%.200s'"</span>,</span><br><span class="line">                 Py_TYPE(v)-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易就可以判断源代码是<code>Objects/object.c</code>文件的实现，因为看<code>unhashable type</code>文案后面还跟有python对象的类型名，这样才可能打印出完整的抛错信息：</p>
<blockquote>
<p>TypeError: unhashable type: ‘list’</p>
</blockquote>
<p>至此，我们知道了<code>PyObject_HashNotImplemented()</code>函数就是<code>dict</code>在赋值操作时，key为Mutable类型导致抛错的源头，接着只要跟踪这个函数在哪里被调用就可以知道<code>dict</code>具体判断key是否hashable的逻辑了。实际上，函数名<code>PyObject_HashNotImplemented</code>给了很多信息，隐约告诉我们，答案很可能就是一开始的推测——<code>__hash__</code>没有实现。</p>
<h2 id="根据调用链逐步往上摸"><a href="#根据调用链逐步往上摸" class="headerlink" title="根据调用链逐步往上摸"></a>根据调用链逐步往上摸</h2><p>顺腾摸瓜，寻找``PyObject_HashNotImplemented()`函数被调用的地方，源码中有很多地方都有调用，但这个函数引起了我的注意，它的实现中带有对类型的hash函数存在与否的判断逻辑，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置：Objects/object.c</span></span><br><span class="line"><span class="function">Py_hash_t <span class="title">PyObject_Hash</span><span class="params">(PyObject *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyTypeObject *tp = Py_TYPE(v);</span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">    <span class="comment">/* To keep to the general practice that inheriting</span></span><br><span class="line"><span class="comment">     * solely from object in C code should work without</span></span><br><span class="line"><span class="comment">     * an explicit call to PyType_Ready, we implicitly call</span></span><br><span class="line"><span class="comment">     * PyType_Ready here and then check the tp_hash slot again</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">true<span class="comment">// 备注：如果tp_hash为NULL，就会调用PyObject_HashNotImplemented导致抛错</span></span><br><span class="line">    <span class="comment">/* Otherwise, the object can't be hashed */</span></span><br><span class="line">    <span class="keyword">return</span> PyObject_HashNotImplemented(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，咱们继续寻找<code>PyObject_Hash()</code>被调用的地方，感觉离真相已经不远了，同样，整个源码中存在大量对它的调用，有很多C文件从名字上一眼就能识别出跟<code>dict</code>类型不相关，最终这个特殊的C文件名和函数名吸引了我，简直就是明明白白告诉我，这里就是<code>dict</code>的C实现😂，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置：Objects/dictobject.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDict_SetItem</span><span class="params">(PyObject *op, PyObject *key, PyObject *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp = (PyDictObject *)op;</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash = ((PyASCIIObject *) key)-&gt;hash) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 备注：获取key的hash函数，如果hash函数为NULL（参考 PyObject_Hash 的实现），则返回 -1（同时抛出类型错误）</span></span><br><span class="line">        hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_keys == Py_EMPTY_KEYS) &#123;</span><br><span class="line">        <span class="keyword">return</span> insert_to_emptydict(mp, key, hash, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* insertdict() handles any resizing that might be necessary */</span></span><br><span class="line">    <span class="keyword">return</span> insertdict(mp, key, hash, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实到了这里已经算真相大白了，已经找到<code>dict</code>的set函数C实现了，里面有判断key是否可hash的逻辑，如果key不可hash则向上返回-1。不过本着打破砂锅问到底的心态，我们来看看这个<code>PyDict_SetItem()</code>究竟会在哪里被调用吧🤔。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件位置：Objects/dictobject.c</span></span><br><span class="line"><span class="comment">// 为了阅读的方便，下面的变量、函数摆放的前后顺序做了调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.跟踪PyDict_SetItem，这里封装dict赋值与删值的，对外暴露单一入口</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dict_ass_sub</span><span class="params">(PyDictObject *mp, PyObject *v, PyObject *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyDict_DelItem((PyObject *)mp, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> PyDict_SetItem((PyObject *)mp, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.跟踪dict_ass_sub，这是保存dict函数指针的数组</span></span><br><span class="line"><span class="keyword">static</span> PyMappingMethods dict_as_mapping = &#123;</span><br><span class="line">    (lenfunc)dict_length, <span class="comment">/*mp_length*/</span></span><br><span class="line">    (binaryfunc)dict_subscript, <span class="comment">/*mp_subscript*/</span></span><br><span class="line">    (objobjargproc)dict_ass_sub, <span class="comment">/*mp_ass_subscript*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.跟踪dict_as_mapping，最终发现PyDict_Type里存了这个数组变量</span></span><br><span class="line">PyTypeObject PyDict_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"dict"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &amp;dict_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    PyObject_HashNotImplemented,                <span class="comment">/* tp_hash */</span></span><br><span class="line">true<span class="comment">// ...</span></span><br><span class="line">    dict_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.顺带再确认PyDict_Type被调用的地方，dict_new函数应该就是python dict分配内存时的调用，至此整个追溯过程就结束了</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">dict_new(PyTypeObject *type, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *self;</span><br><span class="line">    PyDictObject *d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为dict类型分配内存空间</span></span><br><span class="line">    assert(type != <span class="literal">NULL</span> &amp;&amp; type-&gt;tp_alloc != <span class="literal">NULL</span>);</span><br><span class="line">    self = type-&gt;tp_alloc(type, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (self == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    d = (PyDictObject *)self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The object has been implicitly tracked by tp_alloc */</span></span><br><span class="line">    <span class="keyword">if</span> (type == &amp;PyDict_Type)</span><br><span class="line">        _PyObject_GC_UNTRACK(d);</span><br><span class="line"></span><br><span class="line">    d-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">    d-&gt;ma_version_tag = DICT_NEXT_VERSION();</span><br><span class="line">    d-&gt;ma_keys = new_keys_object(PyDict_MINSIZE);</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ma_keys == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(self);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_CONSISTENT(d);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外再找了一下，在文件<code>Objects/odictobject.c</code>下发现了这样的注释说明：</p>
<blockquote>
<p>…The equivalent C API call to <code>dict.__setitem__(obj, k, v)</code> is <code>PyDict_SetItem(obj, k, v)</code>.  This illustrates how subclasses in C call the base class’s methods, since there is no equivalent of super() in the C API.  </p>
</blockquote>
<p>虽然<code>odictobject.c</code>与<code>dictobject.c</code>是两种不同用处的<code>dict</code>的实现，但讲道理两种实现对外的api应该接近一致，所以上面的注释侧面说明了<code>dict</code>的赋值函数就是<code>PyDict_SetItem</code>。</p>
<h2 id="推断验证"><a href="#推断验证" class="headerlink" title="推断验证"></a>推断验证</h2><p>上面的过程让我们明确了在dict赋值key时会判断是否实现hash函数，我们还可以在<code>list</code>和<code>tuple</code>的角度验证一下。<code>list</code>是Mutable类型，它不实现hash函数，<code>tp_hash</code>指向函数<code>PyObject_HashNotImplemented</code>；<code>tuple</code>是Immutable类型，它实现了hash函数，<code>tp_hash</code>指向对应的hash函数。代码如下，结果符合预期：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyTuple_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"tuple"</span>,</span><br><span class="line">true<span class="comment">// ...</span></span><br><span class="line">    (hashfunc)tuplehash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"list"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    PyObject_HashNotImplemented,                <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>咱们追了好阵子源码，该总结一下了。</p>
<p>原问题：为什么<code>dict</code>的key不能是<code>list</code>？</p>
<p>引申问题：为什么<code>dict</code>的key不能是可变类型，可变与不可变类型的区别是啥？</p>
<p>结论：通过追溯CPython源码，发现对<code>dict</code>赋值时会调用<code>PyDict_SetItem</code>检查key对象是否实现hash函数，如果没实现hash函数则抛错并提示类型unhashable（通过函数指针是否为NULL来判断是否实现hash函数）。这里还引出了Mutable与Immutable类型，但本文暂未确定两者除了hash函数外还有无更多区别。</p>
<p>【TODO】确认Mutable与Immutable的区别细节？为什么会有这样的区别？</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://wiki.python.org/moin/DictionaryKeys" target="_blank" rel="noopener">https://wiki.python.org/moin/DictionaryKeys</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>推荐阅读</tag>
        <tag>源码阅读</tag>
        <tag>cpython</tag>
      </tags>
  </entry>
  <entry>
    <title>产品小感</title>
    <url>/2020/01/22/%E4%BA%A7%E5%93%81%E5%B0%8F%E6%84%9F/</url>
    <content><![CDATA[<p>以前觉得做产品，就是解决一个问题，把这个问题拆分成一堆需求，需求、功能之间不论有无相关性，其代码实现凑在一起了，代码量变庞大之后，量变到质变，就成为了一个真正意义上的大产品。</p>
<p>这样的想法比较幼稚，产品并不是单一要素的产物，毕竟除了技术实现外，它往往包含了一系列的调研、设计、策略、抉择，除了肉眼可见的代码，背后还有很多不为人知的细节、理念、历史。如果看产品只从技术角度来看，从实现的难易来衡量，是本末倒置的。产品生而解决问题，首先要发现问题，其次是找到解决方案，最后一步才是代码实现。可能在日常中接触到产品的形态更多是一个可用的实体软件程序，而不是一行行代码，代码实现上的神秘会催生这种代码唯上的片面思维，嗯，要戒掉。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/product_manager.jpg" alt="Product Manager"></p>
<p>PM的工作是技术含量的，可能平时我们看啥产品发布会，产品布道者会在公众场合发表定性的观点，它具有概括性、逻辑演绎和思辨色彩，他说一个产品怎么怎么好，是听他描绘的画面，是靠人自己去感受，当然这种【可感觉出来的好】，一般是产品真的好，才会给人这样的感受。对于PM，产品分析不是一个定性的任务，而是要定量的，好与不好，用户不一定在感官上体会到，而在数据下就能发先指标正向还是负向（不能直接用数字刻划的，还可以做访谈，做横向对比等）。这种正向在若干的迭代的update之后会被慢慢放大，最后大众可能突然觉得【哇，这产品是真的好】，特别是长久不升级的用户，从旧版突然更新到新版，一个跳板级的新体验，是 critical hit。</p>
<p>很多时候产品也会憋大招，比如apple每年更新一次的macOS或者iOS系统，每次更新总会使人眼前一亮，这里牵扯到操作系统层面的更新，有点庞大；可以看看微信的更新频率，以月甚至双月为单位，每次都会掀起一阵小高潮，这种更新频率是在于这个产品已经被认可并且难以替代的前提下才会有的，正如张小龙说每天有上1亿人教他做产品，反过来反映了微信的不可或缺。</p>
<p>技术壁垒是产品护城河，应用生态也是产品护城河，点子是产品生命力。</p>
<p>为什么强调提高交付效率，完善质量保障体系，这就是在建立自己的技术壁垒，技术壁垒除了在代码实现难度上比别人高使得别人抄不了外，还可以通过交付效率、质量保障进行压制。想想看，同样的功能，我比你提前三天发布，我就先赢得了一大批用户，赢在了起跑线；同样的功能，我的产品做出来bug free，你的产品就各种闪退发烫耗电烧流量，高下立判。</p>
<p>至于应用生态，那就是产品布局，从小的角度来说，我们希望把app里探索验证后反响好的功能拆分出来孵化成一个独立app，一部分原因是抢夺下沉市场份额，因为单一产品一直做下去就会有产品的惯性，也就出现了枷锁，新点子不一定适合在当前产品框架上做，比如资讯类的头条app去做小说阅读器。这种时候，会在原先app上试验这个点子，如果ok，就把功能抽离出来做成一个app，新app可以脱离原有产品框架形态、交互模式、代码实现的束缚，去走它自己的风格，做好深度用户体验；另一部分原因也是丰富应用生态，从大的角度来说，以小米为例子，雷军除了做手机，还要贴牌家电，整得像个杂货铺一样，但是假如一个用户真的用上了小米全套，那他脱离这个生态的成本将会非常大以至于在可以忍受的前提下依然苟在里面不肯出来，因为生态与生态之间互不兼容（不知未来会不会继续各家割裂）。</p>
<p>好产品有它自己的短期中期长期规划，细到单个迭代要做什么功能，然后中期要给一个什么会心一击的大招，再到长期产品彻底完善后我希望它及周边是一个什么样子，用户习惯是如何如何。这还是一个目标往下拆分的过程，所做的一切最终都是为了更靠近目标。字节跳动，群众喜欢叫它app工厂，这样的称呼听起来似乎公司就是app流水线，快速看结果、快速试错、快速占领市场。这样的风格更贴切当前的社会节奏，人们每天接触这么多产品，经历有限的情况下如何在竞品中脱颖而出，靠的是求变。反过来看，技术人也应该求变，技术更新迭代，我们要跟上步伐，掌握核心原理的前提下多方拓展，打出竞争力来！</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>功能测试小感</title>
    <url>/2018/02/28/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%84%9F/</url>
    <content><![CDATA[<p>功能测试某种意义上确实是有套路规律的。所谓的测试经验，在我看来就是把套路运用在不同场景的能力，也就是灵活运用的能力。其实这里的<code>套路</code>，换种说法就是<code>测试理论</code>。</p>
<p>从黑盒角度来说，<code>边界值、等价类</code>，这些应该都是软件测试人员的基本知识，应该深入思维信手拈来而不是刻意为之。<code>边界值</code>帮助我们发现比较好找的bug，改善软件最下限的质量（还别说边界校验真的是bug的重灾区，具体依赖RD自测水平），<code>等价类</code>帮助我们精简用例数量，提高执行效率。这些方法论使得我们可以脱离具体业务场景对代码逻辑针对性设计用例。</p>
<a id="more"></a>

<p>除此之外，<code>场景法</code>也是非常重要的手段。<code>场景法</code> 简单理解就是根据不同的用户场景来设计用例，这里没有什么一套一套的测试理论，唯一的要求就是理解业务场景，从用户角度出发。<strong>一些不是bug的问题，在这样的要求下可能就会变成bug，因为它们有悖于业务场景，削弱了用户体验</strong>。</p>
<p>另外，一些更加工程类的bug，比如线程饿死、变量未初始化、数据库死锁等问题，从黑盒角度症状有时会比较奇怪。这些问题更加适合在白盒的角度发现，这也是code review存在的必要性。很多时候，如资源竞争这类问题需要的业务场景比较复杂，场景触发所需要的成本相对更高，甚至靠线下测试环境的机器资源根本无法触发。所以如果什么问题都想着从黑盒角度来发现，那是不靠谱的。<strong>这也正是一个好的QA与普通QA拉开差距的地方——除了理解业务场景、熟练地黑盒发现功能问题外，还要求可以白盒通读代码，在脑海模拟业务场景，进而去发现逻辑问题。</strong></p>
<h2 id="如何设计测试用例"><a href="#如何设计测试用例" class="headerlink" title="如何设计测试用例"></a>如何设计测试用例</h2><p>这里并不打算写一篇全面的教程，只是分享个人对某些点的一些看法。</p>
<p>测试的初衷，是<strong><em>验证程序功能是否符合需求</em></strong>。那可能会问：“既然只需要符合需求，那为什么还要考虑那么多的边界、异常值呢？”，道理很简单，因为<strong>这些都是隐藏在需求之下的情景</strong>。需求，本身是服务于用户体验的，而不是凭空出来的产品功能约束。那么为了一个完整的用户体验，肯定要包含一定程度的容错操作，这就是边界值、异常值考虑的缘由。</p>
<p>既然已经有了一个测试的最终目的，那么具体如何设计用例就好办了。</p>
<hr>
<ol>
<li><p>根据代码逻辑设计用例，以代码覆盖率作为衡量标准。</p>
<p>明显覆盖相同逻辑、相同代码路径的用例可以只留下一条。比如新增功能点是支持连续升级，如果连续升级2次和连续升级3次这两个case覆盖的代码逻辑没有差异，后者完全没有存在的必要，不必因为没有测试后者而不安。</p>
</li>
<li><p>结合需求进行用例设计。</p>
<p>QA必须对一切保持怀疑，故不能认为RD已经完全按照需求完成开发工作。相反，往往不同的视角对需求的理解不一样，在功能的实现方式上会有区别，进而影响功能实际效果——比如同样是实现队列，一个用单向链表实现、一个用数组实现、优先级队列甚至还要用堆来实现，不同的实现方式内部数据流转过程是完全不一致的。另外，这种方式可能会有bonus——发现RD与QA对需求点理解的差异，反向确认真正的需求到底是什么，这样无疑对产品有积极的帮助。</p>
</li>
<li><p>刻意的异常情景考虑。</p>
<p>异常测试可以被放在一个大块里，这样更加方便归纳整理、查漏补缺。异常包括很多情况，具体根据不同业务类型来定义什么是 “异常” ，安装失败、升级失败、解析配置失败、网络失败、用户作弊操作、数据库失败、业务场景失败等等，这些都是异常。</p>
</li>
<li><p>提高用户体验的用例设计。</p>
<p>这里本身不应该单独分出来的，但是我觉得很重要。用户体验其实不一定会有具体的用例，很多时候往往只是一种主观感受，比如UI层面的感受、操作流程顺序、功能的作用大小等。一个具体例子就是根据商品名的历史订单搜索，商品名使用模糊匹配效果往往要比精确匹配好，原因很简单，因为用户根本不可能记住商品叫什么名字。</p>
</li>
</ol>
<p>扯一点题外话，一个好的QA，还应该要熟练掌握各种对自己有帮助的工具。除了发现bug外，还应该有定位bug、调试代码的能力。定位某些bug，比如常见却又难定位的内存泄漏，就需要特定工具帮忙。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程下的单例模式</title>
    <url>/2019/04/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式可能是应用得最广泛的设计模式之一，也是学习设计模式必学、面试必问的模式之一🤣，那么就很有必要搞清楚单例模式是一个什么东西了。这里着重讨论一下多线程下的单例模式，<a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">Singleton（单例模式）</a>的基本概念就不再展开了。一般来说，应用单例模式的场景为要求全局只存在一个单例类的实例，如果该单例类产生了多个实例可能会对系统造成影响或损害，需要限制为1个。</p>
<blockquote>
<p> It ensures that the Singleton class has only one instance and provides a global access point for it. We can use a Singleton when the presence of multiple instances can potentially damage the system, and we need global access to the single instance. </p>
</blockquote>
<a id="more"></a>

<h3 id="单例模式的经典实现"><a href="#单例模式的经典实现" class="headerlink" title="单例模式的经典实现"></a>单例模式的经典实现</h3><p>我们可以来看一下最经典的例子，以伪代码（接近java，get到意思就好😂）展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以说是单例模式最直接的实现了，private修饰构造函数导致外部无法通过<code>new</code>关键字来实例化对象，需要实例化Singleton或者获取Singleton实例必须调用提供的唯一接口<code>getInstance()</code>，对外界调用起到限制。调用<code>getInstance()</code>时首先会检查Singleton对象是否已被初始化，再返回对象实例，另外，Singleton实例只有在第一次调用<code>getInstance()</code>时才会真正初始化，也就是说只有在真正使用的时候才生成实例，这叫做<code>懒加载(lazy initialization)</code>，可以提高系统启动速度，也更加适合在资源有限的系统中运行。</p>
<p>上面的经典实现有十分明显的问题，<strong>它不是线程安全的（not thread safe）</strong>，具体可以看下面的场景：</p>
<ol>
<li>在需要实例化Singleton时，<strong>线程A</strong>进入<code>getInstance()</code>，此时<code>_instance == null</code>为<code>True</code>，<strong>线程A</strong>会进入if分支。</li>
<li>在<strong>线程A</strong>执行初始化代码<code>_instance = new Singleton()</code>之前，发生一次线程切换，<strong>线程A</strong>挂起，切换到<strong>线程B</strong>，并且<strong>线程B</strong>也调用<code>getInstance()</code>。</li>
<li>对于<strong>线程B</strong>来说<code>_instance == null</code>也是为<code>True</code>，因为<strong>线程A</strong>根本还没生成Singleton实例，<strong>线程B</strong>进入if分支。</li>
<li>最终结果就是<strong>线程A</strong>与<strong>线程B</strong>都在if分支里，两个线程都会生成一个Singleton实例，此时系统就有两个Singleton实例。</li>
</ol>
<h3 id="简单粗暴地解决"><a href="#简单粗暴地解决" class="headerlink" title="简单粗暴地解决"></a>简单粗暴地解决</h3><p>怎么样可以防止生成多个Singleton实例呢？很容易，把懒加载去掉就好：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放弃懒加载的特性，这种实现会在类加载的时候就生成Singleton实例，并且保证线程安全。如果Singleton实例生成的代价低、性能影响小，或者这是最合适的一种实现，因为它简单并且安全。</p>
<h3 id="添加锁🔐"><a href="#添加锁🔐" class="headerlink" title="添加锁🔐"></a>添加锁🔐</h3><p>但是我们还是想要懒加载要怎么改？一般方法是添加锁来保护Singleton实例化过程，保证只有一个线程可以进入实例化流程（enter crtical section），实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire_lock();</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    release_lock();</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现也可以保证线程安全，<strong>线程B</strong>不可能在<strong>线程A</strong>完成Singleton实例化之前接触到if判断分支，即使<strong>线程A</strong>在if分支里被切换，其他线程也因为等待锁都被阻挡在<code>if (_instance == null)</code>之前。但是这个实现的致命弱点是对性能影响很大，因为每一次调用<code>getInstance()</code>时都要获取锁，特别是当多个线程一起调用<code>getInstance()</code>的情况下，线程之间会因为竞争锁而被阻塞，当调用足够频繁的时候，系统对外的表现可会是经常卡一会没响应，或者整体的运行效率降低，看起来这样的实现也不太好。</p>
<h3 id="添加锁之前先check"><a href="#添加锁之前先check" class="headerlink" title="添加锁之前先check"></a>添加锁之前先check</h3><p>认真观察添加锁的实现会发现，其实添加锁只是为了安全地进行对象实例化，一旦<code>_instace</code>被实例化后，这把锁🔐就再也不需要了，但是上面的实现是每一次获取实例都去获取一次锁。有没有办法只让锁获取一次就好了？我们意识到锁只是在第一次获取的时候（第一次调用，实例化对象时）才产生意义，所以if判断可以提前到获取锁之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        acquire_lock();</span><br><span class="line">        _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        release_lock();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来好像很机智的样子🎉，我们可以只在首次调用<code>getInstance()</code>时才获取锁，往后因为<code>_instance</code>不为<code>null</code>所以都不用获取锁了，然而实际上行不通，为什么呢？当线程A进入if判断但是在获取锁之前被切换线程，线程B此时也可以进入if判断，会发生两个线程进入if判断的情况，后面就会生成多个Singleton实例，没错，坑就坑在线程可能随时被切换。</p>
<h3 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h3><p>能解决上面的问题吗？还是可以的，我们可以额外添加一个if判断来防止重复进入实例化代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        acquire_lock();</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        release_lock();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码估计是最常见的double-check单例模式实现了，看起来可以有效防止上面提到的问题，即使有多个线程同时进入第一个if判断，在Singleton实例首次被生成之后，后面的线程在critical section里也不会再重复实例化对象了，因为还有第二个if判断在里面。</p>
<p>真的是这样吗？就这样完了？并不是🙃，还有坑。</p>
<h3 id="编译器优化问题"><a href="#编译器优化问题" class="headerlink" title="编译器优化问题"></a>编译器优化问题</h3><p>上面的实现不能保证100%的线程安全，原因是存在编译器优化。现代编译器都太先进了，它们会按照效率更高的方式进行指令重排，会充分利用寄存器和流水线以最高并行度去运行指令（现在已经是多核时代，一台机器上不再是一个CPU而是多个CPU，多个CPU在数据不互相干扰的情况下可以也同时独立运行指令）。一个具体例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>

<p>我们人眼认为a是先于b被声明初始化的，最后c再被计算，但是对于编译器，它可以向我们保证c最后计算出来等于30，也会保证在c计算出来之前a和b都被正确声明和赋值即a肯定等于10，b肯定等于20，但是它不保证的是<strong><em>到底a先被声明赋值还是b先被声明赋值</em></strong>，有可能是先b再a，也有可能是先a再b，我们无从猜测，所以我们也不能指望它可靠。</p>
<blockquote>
<p>这里引申出另一个问题，<code>_instance = new Singleton();</code>实例化操作到底是怎么被运行的？</p>
</blockquote>
<p><code>_instance = new Singleton();</code>并不是一个原子操作，它被执行时是分为3个步骤的：</p>
<ol>
<li><p>一块特定的内存被分配出来给Singleton对象使用。</p>
</li>
<li><p>这块内存会被赋值初始化，此时Singletom对象已经能用了。</p>
</li>
<li><p>这块内存（Singleton对象）的引用赋值给<code>_instance</code>。</p>
<p><code>_instance</code>指向Singleton实例的内存，实际上只有这块内存被完整初始化之后，<code>_instance</code>才是一个正确可用的实例（<code>_instance</code> is valid only when the initialization is complete）。这里可能出现的问题是编译器将这3个步骤打混了，假如<strong>线程A先执行步骤1和3，在没来得及执行步骤2的时候发生线程切换</strong>，对于线程B来说，<code>_instance</code>已经不为<code>null</code>了，就屁颠屁颠拿去用了，但是实际上<code>_instance</code>指向一块还没有被初始化的内存，如果线程B拿这个对象去使用会引发各种谜之bug甚至出现系统崩溃。</p>
</li>
</ol>
<blockquote>
<p>如何解决这个问题？</p>
</blockquote>
<p>我们只需要将实例化对象那一行代码的运行顺序摆正就好了，换个说法就是避免编译器的优化：</p>
<ol>
<li><p>在C++和Java中存在关键字<code>volatile</code>，也就是<code>private volatile Singleton _instance = new Singleton();</code>，它可以使编译器不去做激进的优化，保持原来的执行顺序不变，不过这个关键字某种程度上也会影响整个系统的性能，毕竟变量变成<code>volatile</code>后即使实例化完成后，每次去对象都不去寄存器快速取出来而要去内存取。（<code>volatile</code>这个关键字坑很多，最好还是不要乱用）</p>
</li>
<li><p>使用<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障</a>来迫使完全实例化之后再改变flag的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            acquire_lock();</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                memory_barrier();</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            release_lock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有内存屏障的存在，可以保证<code>flag = true;</code>这句代码不会被编译器优化执行顺序，也就是一定会完成<code>_instance = new Singleton();</code>之后，flag变量才会变为true，所以flag就是<code>_instance</code>已经被正确初始化的标志，if直接判断flag变量即可。如果将<code>flag = true;</code>放在内存屏障前面行不行呢？那是不行的，因为可能被编译器优化之后flag变量甚至会在<code>_instance</code>正确实例化之前就被置为true。然而内存屏障也需要编译器的支持，否则可能很难使用内存屏障，甚至需要写上汇编代码。</p>
</li>
<li><p>最后一种是针对Java的实现，详见<a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" target="_blank" rel="noopener">Initialization-on-demand holder idiom</a>。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面提到的所有实现，都没有找到尽善尽美可以运行在所有平台/编译器的方式。可能最后的解决方案就是放弃懒加载，权衡性能和安全。如果我们想坚持使用懒加载同时保证线程安全，性能会因为锁的获取受到影响（<a href="#添加锁🔐">full locking</a>版本），当然还是有一点小手段可以优化——尽量减少<code>getInstance()</code>的调用次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用三次getInstance函数，也就获取了三次锁</span></span><br><span class="line">Singleton.getInstance().method1();</span><br><span class="line">Singleton.getInstance().method2();</span><br><span class="line">Singleton.getInstance().method3();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 只调用一次getInstance函数，获取一次锁，性能更好</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">instance.method1();</span><br><span class="line">instance.method2();</span><br><span class="line">instance.method3();</span><br></pre></td></tr></table></figure>

<p>虽然这并没有解决问题，但是确实可以在性能上有所提高。</p>
<p>Singleton设计模式从来就不是一个简简单单的设计模式，在不同场景下，每一种设计模式都需要进行演变来应用，分清每一种实现的好坏，挑一种最合适业务场景的实现进行应用，这才是代码功力和业务理解能力💪。</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>violate关键字对单例的影响</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://taskinoor.wordpress.com/2011/04/18/singleton_multithreaded/" target="_blank" rel="noopener">墙裂推荐阅读：Singleton in multi-threaded environment</a></p>
<p><a href="https://www.cnblogs.com/god-of-death/p/7852394.html" target="_blank" rel="noopener">C/C++ volatile关键字深度剖析</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">LINUX KERNEL MEMORY BARRIERS</a></p>
<p><a href="http://ifeve.com/disruptor-memory-barriers/" target="_blank" rel="noopener">Dissecting the Disruptor: Demystifying Memory Barriers</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>推荐阅读</tag>
        <tag>单例模式</tag>
        <tag>多线程</tag>
        <tag>代码实现</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>你的需求是什么</title>
    <url>/2019/12/15/%E4%BD%A0%E7%9A%84%E9%9C%80%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>遇到过一些RD，喜欢上来就问：你现在的需求是什么？</p>
<p>我不太明白ta说的这句话，是为了提高沟通效率，引导话题到正确的方向上去？还是单纯只是想知道自己需要干一些什么，省得去动脑思考协商？</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/doubt.jpeg" alt="我傻diao了"></p>
<p>在现实世界，除非有专门pm给提需求，事先梳理得清清楚楚明明白白，否则多数人的需求可能都是含糊的，因为本身需求的梳理——也就是问题的发现，就已经很难了，得用一段话来描述一个场景并给出预期结果，然后希望你来帮忙解决（特别是peer合作）。</p>
<p>我觉得嘛，不要一上来就只会问你的需求是什么，死抓这一个问题对理清需求没有什么帮助。有时候是别人单纯有一点灵光，还没能总结出一个精炼、可理解、甚至可复述的（讲了一遍，第二遍就再也讲不清楚）需求，就需要自己清楚一下背景和痛点，跟别人的思路走，帮别人梳理出实际需求。最忌讳的是，还没确定需求，你就已经引导别人去聊详细的代码实现问题，需求还被讲完，你就说这个无法实现打断别人的思路。这只会是一个死循环，别人表述本就不一定准确，莽撞定论无法实现进行否定，这怎么能让人好好梳理清楚思路呢？</p>
<p>另一个问题，就是高姿态。作为peer合作方，有句话叫【谁受益，谁推动】。己方可能是被拉进来的人，配合别人输出，这时更容易发展成高姿态，因为受益方过来推动多了，己方有时会产生【我很重要我是关键节点世界需要我】的错觉，腰杆儿就开始直起来了……emmmmmm，这个应该挺常见的。</p>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>合作</tag>
        <tag>需求</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试初探</title>
    <url>/2017/12/18/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>目前已经对两个不同的C/S架构产品的Server端进分别进行过一次性能测试，慢慢开始对性能测试有了初步的认识，下面大概分享一下我们小组的性能测试过程。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>性能测试开始之前会和开发讨论，目的就是要确定真实业务场景下的各种相关数据的量级，最终计算出预期多少<strong>QPS</strong>才可以应付业务场景的需要。当有了预期的<strong>QPS</strong>作为一个性能目标后，就可以开展性能测试了（根据业务需求不同会有各种不同的指标要求，可能是一个，也可能是多个）。</p>
<p>这里性能测试使用的是<strong>Jmeter</strong>，<strong>Jmeter</strong>的优点很明显，就是简单易用，可以快速搭建分布式测试环境，通过水平扩展增加测试机器来增加对Server的请求压力，把Server推向它的性能转折点。</p>
<p>机器资源在性能测试中是一个比较重要的东西，因为机器配置的好坏或者机器的多少就已经决定了你能对Server造成多大的压力，不同机器之间的配置是越接近越好，因为<strong>Jmeter</strong>的分布式测试是不存在调度一说的，只是简单地通过一个Master对配置好的所有Slave发送测试计划<code>jmx文件</code>，然后Slave会去执行测试计划（Slave也可以是Master自己）。如果Slave机器之间的性能差距太大，那么性能差的机器就会成为短板，导致性能相对好的机器无法最大程度发挥性能。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>1. 机器资源</strong></p>
<p>继续上面说的机器性能，为什么说性能差的机器会成为分布式测试环境中的短板呢？因为每一台Slave执行的测试计划都是一样的，都要发那么多请求，起那么多线程，一旦消耗的资源超过机器承受范围，该机器发送的请求数量和质量就无法达到预期，总请求数势必变少，也就无法知道并发数等重要指标是否满足，从严谨的角度出发，这一次测试结果是作废了。</p>
<p>所以，分布式环境中性能差的机器会成为测试计划里的短板，使得测试计划的各项参数被遏制在某条线之下。另外，Jmeter的分布式环境应该选用性能最好的机器作为Master，Master所做的工作肯定是比Slave要多的，如果Master性能不好，会造成Jmeter客户端的假死，导致本次压测数据作废，甚至可能得到一些偏差较大的数据。</p>
<p>个人真实经验：用了一台很谜的机器做Master，导致多次测试无法正常结束，浪费时间，后面换了一台好的机器做Master，压测都是一次过，在调到更大请求压力后看到的响应时间甚至比没换Master之前相对更低压力的响应时间更快，所以Master也会对测试数据有影响，应该谨慎挑选。</p>
<p><strong>2. 通过重复测试来分散风险</strong></p>
<p>道理非常明显，单次的测试结果存在较大的偶然性，这些偶然性可能来自于你的测试数据，可能来自于Slave的资源状态，也可能来自于网络……为了降低各个方面的风险，重复测试当然是必须的，至少重复三次取一个平均值，而且要特别关注明显异常的数据，比如某个数据突然变高或变低，要思考一下可能的原因，而不是直接舍弃这一次结果鲁莽地开始下一次测试，谁也说不准里面是否就有一个bug。</p>
<p><strong>3. 调整测试计划</strong></p>
<p>性能测试本身不仅仅是为了验证Server的性能指标是否达到预期，找到Server的性能转折点也是一件重要的事情，需不需要准确定位这个转折点就要看业务需要了。</p>
<p><strong>如何通过调整测试计划来发现这个转折点？</strong>以<strong>Jmeter</strong>来举例子。</p>
<ol>
<li>线程数<code>n</code></li>
<li>发送请求的时间区间<code>t</code>——我理解为在<code>t</code>时间区间内，会逐步启动共<code>n</code>个线程并发出请求</li>
<li>线程循环次数<code>i</code>——也就是总共多少个区间<code>t</code>，因为循环<code>i</code>次，总共就会发<code>n*i</code>个请求</li>
</ol>
<p>以单个请求的平均响应时间为标准，由于线程在t区间内就会全部启动造成并发（可以粗略看成并发数为<code>n/t</code>），如果单请求平均响应时间大于区间t，则代表代表Server在区间t内已经处理不过来这么多请求了，就会造成请求的堆积。</p>
<p><strong><em>为什么说Server处理不过来？</em></strong></p>
<p>拿第一个启动起来的线程来看，本身预期该线程的请求在t区间内返回是没有问题的。但是，假如该线程发出的请求对应的响应时间大于t，则代表该响应在一个大于t的区间内依然算一个并发数，也就会影响到下一个区间t，结果是下一个区间t的并发数会受到来自上一个区间的叠加，最后导致在某个不知道的时间区间内，并发数会大于<code>n/t</code>，这对我们来说既不准确也不可控。</p>
<p>除了以响应时间作为判断转折点的依据之外，<strong><em>Througput</em></strong>也可以作为参考。</p>
<p>另外，应该特别注意一下总请求量，一旦发现总请求量不足预期，很大可能是机器资源不够了，此时只能把参数调低，继续往上压已经不现实。如果请求量比预期要多（这个我们遇到，谜之问题），可以先检查csv配置文件是否正确，csv里的数据是否充足，可以看看<strong>Jmeter</strong>发出的不同请求有没有发生内容的重复，再根据这些已知条件去排查。</p>
<p><strong>4. 测试数据的准备</strong></p>
<p>很多时候构造请求是需要数据的，可以根据数据库的运作特征来构造数据，从而相应地验证数据库的增删改性能，也可以根据Server逻辑来构造，从而触发Server的不同业务路径。但是构造数据务必要合理，以真实业务场景为依据。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>应该对一次性能测试怎样进行记录呢？可以有如下点：</p>
<ul>
<li>核心测试计划的各种指标数据</li>
<li>存在性能问题的方案</li>
<li>优化修改后的方案</li>
<li>优化前的指标数据和优化后的对比指标数据</li>
</ul>
<p>拿到上面的数据，就可以分析得出性能测试的结论，清晰可观地知道这一次性能测试产生一些什么样的积极意义了。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>感情问题的小总结</title>
    <url>/2019/03/29/%E6%84%9F%E6%83%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这是8个多月来我记录下的第16次较大的矛盾了，不包括一些及时解决的小问题。你懂的，大矛盾时时伴随着泪水，我的也好她的也好，我这流眼泪的次数远远大于初中+高中+大学的总和了，现在回头总结一下，其实归根到底都是一个原因：<font color="red"><strong>沟通不充分</strong></font>。</p>
<a id="more"></a>

<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>回顾最近跟妹子发生的一个矛盾，背景是最近打算开始同居生活，按照想法准备找一室一厅的出租屋，期间也到现场看过两次，矛盾的导火索是之前我同事介绍的一个房子我们都喜欢，但是最后被别人放了鸽子，因为全程都是我对接沟通的，她看起来几乎没有怎么贡献过，让我觉得她一点积极性都没有，派不上用场。</p>
<p>当然她要反驳，毕竟我说的是有点夸张，她期间也会在app看出租屋，跟我讨论出租屋好不好，也一起商量出租房范围，还有跟进中介发出来的房源，被我这样说得分文不值，开心是不可能的。</p>
<p>在我的立场，最近学习劲头特别足，我越来越不想被其他乱七八糟的事情打扰我的学习计划，但是从开始找房子到现在我都感觉是我自己主导整个流程，沟通、安排、跟进几乎都是我一个人在做，让我的怨气积累得越来越多，最后在她面前释放了出来（当然这里有个问题就是房子是我的同事介绍的，对接工作我来完成也是理所当然）。</p>
<p>周日晚上我坐了40分钟的地铁过去找她吃饭，她提起房子被放鸽子的事情，让我的情绪和不满爆发了出来，矛盾出现之后一路上都不说话，两个人虽然并排走路，但是气氛死僵很难受，人在身边心在千里，一刻都不想呆，我有种立马想调头回家的冲动。最后一起随便吃了个沙县继续散步一点一点把压在心里的怨气互相发泄出来后矛盾才算解决了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/sorrow.jpg" alt="sorrow"></p>
<h3 id="侃大山"><a href="#侃大山" class="headerlink" title="侃大山"></a>侃大山</h3><p>矛盾不是第一次了，这么多次下来，我和她的脾性其实都已经掌握得七七八八了。我在有情绪的时候往往不喜欢说话，她也是，所以两个人都不会先挑起话匣子解决气氛问题，在这样的氛围下两个人都会十分难受，所以每次解决矛盾之前总要经历一下这样的痛苦😔，时间从十几分钟到几十分钟不等，贼蛋疼。</p>
<p>我虽然是个男生，然而在感情上却是一个容易感受到细节的人，有时候也会想得多，往往就会想歪伤了自己的玻璃心，而她是认为自己没错就跟你死倔的类型，偶尔脾气会十分暴躁，我曾经被她莫名其妙凶了一两次。怎么说都好，两个人在感情方面毕竟经验都十分有限，我是初恋，她的感情经历也没多少，所以两个处理手法极其原始的人在矛盾下往往都会手足无措只能互相生闷气，沟通不知道怎么沟通，安慰也不擅长，更加可怕的是一些很危险的时刻随便说一句话可能对方就当真然后立马翻脸。</p>
<p>她说，很多时候我们两个人的角色仿佛互换，我更像一个女生，整天嘤嘤嘤动不动就流眼泪，她就扮演男性角色来安慰我。想不到我光明磊落堂堂猛男竟然在感情面前是这个死样🤣。我的爱情观不知道是不是特别奇怪，反正就跟其他男生不太一样吧（以下只是为了说明清楚才加上序号的，并不代表我斤斤计较）。</p>
<ol>
<li>这个社会给男女恋爱定下来太多规则，特别是网络上一些歪歪扭扭的爱情观，凭什么男生在感情面前一定要无条件大气、包容女方？</li>
<li>爱情讲究什么？互相付出。男生比女生付出多一些无所谓，但是为什么男生总要先付出才能获得回报，为什么一定事事都要男生主动？</li>
<li>女生是不是看霸道总裁看狗血爱情剧多了，总爱矫情还以为这是有深度？</li>
<li>一个劲追求浪漫？爱情与面包我选择面包，没有物质的爱情是假的。</li>
<li><a href="https://www.zhihu.com/question/264976486" target="_blank" rel="noopener">舔狗舔到最后一无所有</a>。</li>
</ol>
<blockquote>
<p>总结出来就是：男女生而平等，也许为了表现男子气概男方可以适度大气一些，但性别差异并不是一个要求男方必须得大气包容的理由。</p>
</blockquote>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%88%94%E7%8B%97-1.jpeg" alt="舔狗-1"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%88%94%E7%8B%97-2.jpeg" alt="舔狗-2"></p>
<p>基于以上爱情观，偶尔在发生矛盾的时候我会被她说我小气一点都不大方，当然这句话还伤不了我，往往最伤我的是在矛盾中她时而表现的破罐子破摔的态度，比如这一次同居事件，她说我在跟她斤斤计较，那就不要同居了。她可能意识不到这话多么伤，但是为了不加深矛盾，我也就没有接着反驳什么气话，做一个男生要理智，关键一击要扛得下来，撑过去了就好了，深呼吸一口，把情绪附着在二氧化碳上从口腔中一起排出去，呼~</p>
<p>以前的我，是一个比较享受独处的人，因为总有自己的方式可以娱乐，包括但不仅限于健身艹单双杠、打游戏、泡图书馆，工作之后一个人来到深圳，下班依然会经常锻炼健身，时不时看看书写写很low的代码，周末自己去图书馆逛逛，有时出远门到深圳其他地方感受一下，也很愉快。有了她之后，生活慢慢改变，独处的时间明显减少，爱情带来甜蜜的同时也带来了责任，意识到自己需要花时间好好珍惜维护爱情，有时候自己比较烦躁，就会把在爱情上需要投入时间这件事当成是一种负担。世界上哪里有呼之则来挥之则去的爱情，等价交换，想获得足够滋润自己一生的宝物，就得需要将自己最重要的东西<code>时间</code>投入进去，其实要考察自己是否真的爱惜一段感情，就看自己是否愿意随时投入时间去维护它就可以了。当然有些情侣相处的方式不一样，小别胜新婚，经受得了长期异地的情侣，自然也会发展处他们之间相爱的方式，这些我是真的很佩服，因为我不知道假使我和她突然长期异地，我要怎么做才能继续保持爱情的陪伴感和新鲜感。</p>
<h3 id="银弹？"><a href="#银弹？" class="headerlink" title="银弹？"></a>银弹？</h3><p>上面瞎说了一通，下面继续瞎说。</p>
<p>这一次矛盾的尾声，我跟她说，既然我们在发生矛盾之后都无法控制自己的情绪，要不尝试引进一些规则来硬性限制我们的行为吧？毕竟人的理性总有靠不住的时候，规则的介入可以给一个破冰的借口和处理问题的指导方针。</p>
<p>这个被她笑话了，因为我们最终也没有得出一个能够100%可执行的方案，我能想到的也只是我们两人一人轮流一次主动解决问题，下一次发生矛盾我先说话放下尊严和情绪解决问题，下一次是她……看起来似乎很可笑🤣，先试一下吧，沟通是解决问题<code>最有效而且成本最低</code>的手段，但是难也就难在如何沟通，希望这个规则能管用。</p>
<p>这次矛盾下来，我开始寻找一个问题的答案：<code>有没有可以解决情侣/夫妻矛盾的银弹？</code></p>
<p>之前在豆瓣搜过一次，其中两本引起了我的兴趣：<a href="https://book.douban.com/subject/5952488/" target="_blank" rel="noopener">《亲密关系（第5版）》</a>，<a href="https://book.douban.com/subject/6052834/" target="_blank" rel="noopener">《亲密关系（克里斯多福·孟 ）》</a>，前面那本已经买下来了，最近打算认真研习一翻，希望能学习到一些手段和理念吧。</p>
<p><strong>愿认真看完我这篇废话的人都能找到自己真正喜欢的伴侣。</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>我的童年记忆</title>
    <url>/2020/05/17/%E6%88%91%E7%9A%84%E7%AB%A5%E5%B9%B4%E8%AE%B0%E5%BF%86/</url>
    <content><![CDATA[<p><strong>元气爆发伏魔金刚</strong>，日本动画蓝光人系列的第二部，可能知道或者对这一类东西感兴趣的同龄人不多了，花了399在闲鱼上掏回来的童年回忆，这部动漫虽然没在香港电视台看过（我是地道广东娃），但小时候有见过或曾拥有过其中部分机体。买回来当天黄色狮子初次变型时就不幸断了两条胳膊，我 !@#$<em>#%^%</em>^​$&amp;()_*%……哎，RP不好，抽中了质量比较菜的批次，加上年代久远塑料变脆，里面的弹簧力量又大，啪一下就没了。</p>
<p>合体后大概有50 - 60cm高吧，把玩了俩星期，还是很满足的，这399元里面至少包含了299的情怀费，网上有些很富裕的玩家收藏着完美版的玩具，看着<a href="https://tieba.baidu.com/p/5901745199?see_lz=1" target="_blank" rel="noopener">别人秀的照片</a>真的羡慕妒忌恨。</p>
<p>这个是国产玩具（网上称祖国版），在我童年时（200x年）正是这些日本动画 + 连者 的合体机器人风行的时候，网上有说国产dx版（dx：Deluxe，豪华、高级），我不是专业玩家不太懂，大意应该是那个年代的玩具厂家都愿意下本钱把玩具质量提升上去，所以也叫国产dx版。整个童年就是这些机器人陪着我长大，自己考试成绩如果比较好，只奖励机器人玩具就行，别无他求，但是不买就哭😂。</p>
<p>在Youtube上可以看到日本dx版的机体，有不少专门发机器人玩具的up主，日本dx版用料水平和结构细节肯定是吊打祖国版的，国产版基本也就模仿或阉割日本版。</p>
<p>这个玩具本身的把完性是在于单个机体都可以独自变形，最后还能合体。这种复杂的（虽然一点也不复杂）结构才是吸引我的地方，帅（好吧也不算很帅）只是次要的，个人不太喜欢高达模型，感觉高达就是棱角分明的那种酷和科技感，拿来摆摆姿势还凑合，但是从变形合体的角度来说大多数高达模型基本没有把玩性🤔。</p>
<p>下面就是放图了，没有放特别的心思来摆造型，背景也比较糟糕，也没在乎什么特别摆位，留个纪念就可以了，毕竟不是专业玩家😂。</p>
<p>下面是3合1，老鹰、狮子、大象，分别是上身、中间、腿部。每个机体都能变型，3个一起可以合体。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/three_robot.jpeg" alt="3合一"></p>
<hr>
<p>这里是飞龙和蓝色狮子（随便叫吧），也是可以独立变型，蓝色狮子可以简单变身成一个大炮。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/two_robot.jpeg" alt="2合1"></p>
<hr>
<p>最后就是5合1了，3合1的机器人是核心，飞龙需要拆得四分五裂作为各种零部件，</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/all_robot.jpeg" alt="大合体"></p>
<p>以上。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>回忆</tag>
        <tag>童年</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018总结</title>
    <url>/2019/01/02/%E6%88%91%E7%9A%842018%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>已经工作一年半了，以QA的身份入职到现在，前半年跟后半年还是有不少变化的，看着一批老同事离职，包括自己的导师，有的QA同事转型成RD，有的跳槽去了更大更好的平台继续做测试，有的为了工作能轻松一些好带小孩去了传统公司，也有一些RD感觉到自己在这里到了瓶颈跳槽寻求发展。慢慢地自己变成了团队里一个老人了，开始独立负责一些项目的测试工作，角色开始从一个单纯的执行者稍稍往上走了一点，要自己出测试方案，要自己叫人一起来review，然后自己执行。以前在导师的荫蔽下，几乎把一切RD对接的沟通工作都省去了，自己安心做基础测试工作。那时候的自己浑然不觉，自以为完全handle了自己负责的那一部分，现在看来甚是傻逼。</p>
<p>前半年就是这样子的一个状态，接触了几个小型项目，有客户端的，有web平台的，也有后台的，前半年对于自己来说，这些不同的项目并没有什么根本区别，唯一的区别可能也就是功能和测试场景不一样吧，或者说仅仅局限于实现方式的不一样，现在回头看一下，这些项目从需求背景就完全不是一码事。以前自己好奇技术细节的实现，具体到单个功能的几个函数是怎么写的，用到了什么样的技术，而现在自己更好奇的是用什么方案来解决一个问题，其次才是具体的代码实现细节或者技巧。从环境上来前半年跟后半年是有明显区别的，增加了不少新同学只后测试工作负担少了很多，也终于拿到了一些对接项目的代码可读权限了，当自己对具体实现细节感兴趣或者遇到bug想自己排一下的时候就可以看一看。</p>
<a id="more"></a>

<h3 id="白天求生存，晚上谋发展"><a href="#白天求生存，晚上谋发展" class="headerlink" title="白天求生存，晚上谋发展"></a>白天求生存，晚上谋发展</h3><p>前半年跟着导师干活，后半年导师离职后隔壁组的QA leader过来一起管理我们的测试工作，客观评价一下两个人的工作作风区别。</p>
<ul>
<li>导师（女）属于那种雷厉风行，做事情不吭声，测试效率高的人，但是她不会去看项目源码，没有足够强的自动化意愿，在我看来是一个相对传统的QA。<ul>
<li>优点：<ol>
<li>一切的工作都是为了快速完成项目测试并保证基础质量，测试效率真的很高，测试速度得到对接RD一致好评。</li>
<li>场景覆盖较为全面，QA思维清晰缜密，相关类型的项目测试经验丰富（7年经验），可以及时发现RD的方案设计的不足之处。</li>
<li>工作真的负责认真，该周末加班时毫不含糊（有小孩的人）。</li>
</ol>
</li>
<li>缺点：<ol>
<li>更加愿意通过手工测试来完成工作，对于项目逻辑单纯听RD口述即可，从没听过她追究代码，100%黑盒测试，自动化的想法不足，更不要说最后落地的自动化方案，几乎为零。</li>
<li>对项目的owner精神不足，测试完一个提测（这边的项目迭代速度十分慢，一点都不敏捷）后基本不闻不问。</li>
<li>对复杂项目流程有着一定的厌恶，不主动推合适的测试开发流程。</li>
<li>对隔壁组QA测试的项目没有展现出任何兴趣（相反我倒是超级感兴趣的）。</li>
</ol>
</li>
</ul>
</li>
<li>新QA leader（男）RD出身，只负责在我们这边推流程，自动化意愿和想法极高（当然还是我们自己来落地），推动力较强，经常在RD之间游说新流程。<ul>
<li>优点：<ol>
<li>push我们落地新流程，包括详细设计评审会、case评审会、迭代分析会，提测流程等，虽然不是每个项目组都能接受所有流程，但是帮我们在RD leader层面解决了很多流程上的推动障碍，让QA有了更多可以介入的空间。</li>
<li>push我们做自动化，虽然没有强制我们做，但是一直给我们灌输想法，最后我自己做了起来。</li>
<li>一直push我们给项目做各个维度的质量保障，从基础的监控到CI到单测（emmmmm我没有去做）。</li>
</ol>
</li>
<li>缺点<ol>
<li>站着说话不腰痛，不了解项目的具体情况，按照他那边大项目的<strong>重型流程</strong>在我们这边的小项目组里做无意义的推动，搞得RD有点抵触情绪。</li>
<li>只说不做，给我们想法，具体落地完全只能靠我们自己。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>可能因为一开始只有我和导师两个人扛二十多个RD的测试任务，所以一直没有时间从各个维度去完善质量保障，那一段时间一个项目还没测试完就已经有两个项目在后面排着队，RD都让我的经理给我们加人力，确实没有时间去考虑什么自动化，只要保证项目上线不出问题就已经很不错了。但是这样测试得越久，我自己越来越难以提升，像一个测试机器一样来一个提测就测一个，这根本就不是我自己想要的发展道路。我尝试去向RD要项目源码来看，答复都是拒绝，都是让我去跟RD leader沟通，我tm怎么敢直接跟比我高几个级别的RD leader说我想看源码……导师自己本身对源码丝毫不感兴趣，所以也没帮过我。那时候的测试流程确实很原始，RD发一个提测邮件，导师再开一个测试方案评审会就可以开始测试，很多东西都是一边测试一边沟通，测试完一个项目还没来得及总结一下就下一个，日复一日这样我真的厌倦了，可能这种心情很多新人QA都可以体会到——发现让自己成长的平台并不如一开始想象得那么光鲜亮丽。</p>
<p>新QA leader对于我们的测试工作管得很松，所以后面基本上是我一个人去handle项目测试，多了一些新同学，测试工作也没那么恐怖了，大多数时间完全可以实现每天9点下班，甚至实现了<strong>白天求生存，晚上谋发展</strong>的理想状态。我开始给自己排期更多的时间，以了解项目同时自己积累其他方面的知识，后半年下来慢慢地觉得工作节凑开始走上正规了，在其位谋其职，测试工作当然依然有保证，那是职业道德，但是不能让自己的发展局限于目前的岗位职责，尽可能将自己的能力往上下游蔓延🤔。慢慢地自己对项目的owner精神开始加深，主动跟进项目各种情况，开始考虑项目测试的痛点，深入了解项目的各种细节，也感受到了自己跟以前有不一样的地方。</p>
<p>常常说程序需要健壮需要鲁棒性，后端不能相信前端传过来的东西，agent也不能相信server下发的东西，QA方肯定是需要测试这些边边角角的东西。然而问题是RD很抗拒添加这种健壮性的代码，如果项目赶工期的话可以理解，但是普通迭代并没有忙成什么样而且他们还有时间玩手机刷网页都不愿意改，虽然我有点站着说话不腰疼，但如果我是RD，我肯定愿意把自己的东西做得更好，况且还是别人给自己发现的问题。隔壁组有个93年的同事，传闻是高中毕业就出来打工，做过保安、在电影院做过检票人，最后自学了编程，在<code>吾爱破解</code>里做了一个模块的版主，最后被公司安全部门的人挖过来做开发，简直是励志。他是一个相对的完美主义者，自己写的代码，隔几天想到一种更好的实现方式就会自己重构一遍，跟他合作沟通都很顺畅，这类型的同事永远都是学习榜样。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/office.png" alt="我的工位"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>QA的工作内容相对来说都比较同质化，所有的工作内容无非围绕着项目的质量保障来做，细分包括流程、功能测试、性能测试、监控、自动化等几大类。</p>
<p>项目组里需要QA去推的流程可能包括各类评审会、CI、单测准入、上线会议、迭代分析等，可以看到这些流程其实都是给QA创造更多介入项目的机会。流程能否推动，QA只是一部分的因素，毕竟多数情况QA都不是跟着产品一起走的，是一个流动团队，体系跟RD数不一样的，所以你说的别人不一定听，推流程如果RD leader都不合作，那就不要想了。</p>
<p>功能测试是基础，重点是对项目功能的理解程度和场景的覆盖是否充分，QA做功能测试的目的不是要完整地覆盖各种代码分支，这些应该交由RD保证，我觉得更重要的是发现RD没考虑的逻辑分支和覆盖一些稀有、异常场景，需要的不是100%的覆盖而是针锋相对的用例设计，这样才能用尽量少的时间尽量多地发现问题，当然如果知道具体代码，就可以把预先知道一定pass的多余的用例去掉，这样会节省时间，叫合理的偷懒。QA做的是集成测试，很多时候到手的模块已经是一个整体，而不是一个一个给输入得输出的函数，很多东西会更加模糊，同时由于复杂度的提高，场景也会更加复杂，能否尽可能多覆盖到这些场景，而不是顺着正常数据流程一路走，这才是功能测试的重点（当然正常流程也要测试）。</p>
<p>性能测试我接触的实在太少了，只有寥寥几次，用Jmeter在多台电脑上搭建主从测试环境，一起发请求给sever压测接口，得出一些请求响应时间的数据做简单分析。性能测试我觉得主要是看三个方面，一是你会用多少工具来实现你的性能测试方案，二是你能设计出什么样的性能场景，三是你拿到性能数据之后如何分析得出结论。我感觉我三个方面都很菜，没啥实战经验……</p>
<p>监控、自动化属于一个QA其他层面的能力，一般大公司内部有监控平台可以直接对接，如果没有就要自己想监控方案，确定监控指标，从最原始的进程在不在、进程号有没有改变、cpu内存IO是否过高，到接口是否可用，响应时间是否合理等都是监控的指标。自动化就是业界经常拿来吹嘘的点，说我们的团队对业务做了多少百分比的自动化什么的，自动化也分半自动化和全自动化，半自动化可能是自动生成数据人工验证结果，如生成数据的工具；或者人工生成数据自动验证结果。这写我觉得都不算自动化，因为还是需要人为干预。全自动化在我对接的项目组里是0，也是我19年重点建设的东西，对接不同的端就有不同的自动化，web前端自动化可能要去到像素级别（这个估计业界做得不多），web后端或者server的自动化多数是生成数据发送接口然后验证数据库或者接口返回，agent端的自动化就繁杂一些，需要看具体的业务场景，比如我对接的一个内部macbook安全监控agent就需要通过GUI（操作鼠标点击拖拽）来实现自动化，麻烦多了。不过说到底，自动化的能力是衡量一个QA开发水平的重要指标，毕竟 <code>talk is cheap, show me the code</code>。</p>
<p>更好的QA，那可以是在项目架构上产生影响，审视的不再是项目的单个具体功能而是项目的不同模块如何协调、架构是否能承受未来多少时间内的业务量、是否具备足够的扩展性和维护性……越说越飘，还没到这个境界，</p>
<h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><p>说起源码，我对接的开发组也是够奇葩的，我了解到的很多业务线的QA都能有完整可读的源码权限，而在我这边RD就说代码要保密，QA对于RD来说仿佛只是一个工具，从心智上看RD就觉得QA只是支持作用，他们只应该黑盒测试，有需要就告诉他们业务逻辑而不是代码细节，RD不理解QA为什么非要拿源码看，为什么要参与debug，为什么要了解一个bug从出现到修复等等。QA为什么要这样，答案应该就是一个——更好地改善产品质量。很多东西，没有代码都是空谈，当然我自己有一颗日后转型RD的心，所以一直想多了解具体实现好让自己积累更多的代码基础，这里是有私心存在的，但是更多时候直接原因是QA需要完整知道一个bug的产生到修复甚至到预防的过程，以更好地覆盖测试不同场景，去发现和积累一些之前都没有想到的点，推动RD改进提测质量，从而保证项目质量。不仅很多老RD质疑QA做白盒测试的意义，也有应届跟我一起入职的RD不明白我对项目源码的执着。</p>
<p>对代码观念的改变，有一个小故事。当时测试一个agent端的时候，一个3年的RD让我别看他们项目源码，说他们的代码一点技术含量都没有，他自己都懒得看，让我还不如去<code>github</code>上找代码看，上面的代码强多了。这一个agent端是内网IDC上保证主机安全的，他说，项目真正值钱的地方往往不是代码实现，因为网上一搜多得是，值钱的是这个agent做的安全方案，它解决安全问题的思路和方法，它是如何将一些安全概念以代码的形式落地的。当时我没有理解，但是现在回想简直茅塞顿开，是的，其实最后的代码实现都是业务逻辑 if else for while 那种东西嘛，<strong>关键应该是这个项目背景是什么，安全概念是怎么来的。有什么样的安全意义，概念如何转化成具体可执行的安全方案，方案如何转化成需求，而最后一个环节才是代码实现需求，所以应该花更多精力去了解学习的是前面的环节，而不是最后的代码实现</strong>✨。</p>
<p>要深入理解一个项目，要能做到打破砂锅问到底，不要怕尴尬一定要问清楚，虽然真的会有RD觉得自己问的问题很低级，没办法自己掌握的信息实在很少。一开始接触项目代码的时候一脸懵逼，甚至连语法都看不懂，对接的项目开发语言有php、js、go、object-c、python，也只能硬着头皮快速过一遍语法后直接看，根据自己对项目的了解先从核心的代码模块和业务流程开始看，比较nice的RD会主动跟我讲一遍不同的代码模块和其实现的功能。边看边梳理自己已掌握的信息，最后将一个一个零碎的点整合在一起，整一个项目的业务和架构就会明朗很多。这里特别建议的一点就是根据问题去看代码，要有目的地看才会有收获，可以根据一个典型的bug来看，看bug是如何产生如何修复，足够典型的bug往往会涉及到多个模块之间的交互，这样走下来让人印象十分深刻🤔。</p>
<p>还有一件事一直让我十分惶恐，自从当上了QA之后，我就很少写代码了，或者说成体系写结构化的代码，而不是写那种辅助工作的只有百十来行的零碎的测试工具脚本。既然我心念念未来要转RD，代码能力就不能太弱，相比于天天写代码的RD，我们QA很多时候半年的代码量还不够别人一月多（虽然代码量不能代表代码水平，但至少是开发效率的一个参考指标），毕竟各有分工，这个是无法改变的事实，除非做的是测试工具研发类的测试岗位。我现在的岗位叫测试开发工程师，但是很多时候由于多个项目测试进度的压力，很多想法都来不及去实现，毕竟测试质量是最优先的，其次才是自动化。这个困境过了一年多，在这一个多月里终于开始改变了，因为项目空档期我差不多3周的时间闲下来思考项目测试的痛点，然后去实现我的自动化。我下定决心再也不接那么多测试工作了，相反，将更多的时间投入到开发维护自动化程序中去，虽然只是我的个人代码，没办法体会到团队合作开发的流程，但是我可以用更规范的形式去要求自己完善这个工具，代码库要有相对完备的<code>README.md</code>和<code>CHANGELOG.md</code>，代码要有适当的注释，文件结构和模块要整理封装，有好的想法出来就要去重构替换掉老的代码，即使未来可能并不会有人用，我也要以面向用户的标准去打磨它，把开发、维护这个自动化程序当成是我自己的一次修炼。</p>
<h3 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h3><p>12月份因为需要对上头的上头做一个业务分享会，分享我自己负责的一个相对成熟的项目。为了满足上头的口味，我那小段时间经常拉着将要离职的RD去会议室单独开小灶给我讲这个项目，幸好RD哥们也够义气，给我讲了业务的大流程、每个模块的功能、项目的基础架构、一些以前发现的重点bug和这个项目存在的一些问题，然后我自己再仔细理了理，把几个重要的代码模块通读了一下，在短时间内就对这个几万行代码的项目有了相对清晰的认识，然后再去做个ppt，根据需要自己再理了一下，发现以前自己完全不了解的地方原来是那么那么的多，可见以前的自己眼光是多么地狭隘，这是我这个阶段里一次很宝贵的历练了。</p>
<p>说起ppt，不得不说，我在的组对于汇报工作有着非同一般的“执着”追求，ppt稍微做差一些做得随意一些，就会在会议上受尽指点，跟同组同事精美的ppt一对比，简直惭愧得无法做人。还记得一个已离职的QA同事说，她的ppt能力在现在的公司排不上用场哈哈哈哈。会叫的鸟儿有虫吃，ppt只是一种汇报手段，无论什么途径最终还是要向别人展示自己的工作，要量化指标，要对比，要有逻辑，汇报得清晰才能证明自己的价值。在这个组呆了一年半真可谓把我的汇报能力强行拉了一个等级，还是得多感谢这个组这样疯狂地push我们😓（虽然很多汇报工作明显是多余的）。</p>
<blockquote>
<p>总结一句话，这一年来心态和思维成熟了很多，知道自己想要什么、缺什么、讨厌什么，开始明确自己的追求。</p>
</blockquote>
<h3 id="2019的FLAG"><a href="#2019的FLAG" class="headerlink" title="2019的FLAG"></a><strong><em>2019的FLAG</em></strong></h3><ol>
<li>亟需提升的是代码量，在2019年平均每个月可以产出<code>500行</code>结构化的代码，无论是工作代码还是个人代码都好，那种小脚本小工具不包括在内。</li>
<li>最高优的是<code>在安全方面打好基础</code>，熟悉web安全、Linux安全、汇编和各种工具的使用；另外Linux内核、游戏开发、二进制分析、渗透、病毒分析等需要入门。</li>
<li>一个一直都想点亮的技能就是学会1个web开发框架，自己写一个博客的前后端，或者搞一点有意思的小需求。确定选中<code>flask</code>，自己未来的主力语言应该是python，备选是go。</li>
<li>阅读至少<code>2个</code>大型开源项目的代码（python源码已经在清单之内）。</li>
</ol>
<hr>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>一定要说这一年最大的变化，那就是<strong>爱情</strong>。</p>
<p>自己的生活片段都是记录在微信朋友圈上，18年已经再也没有学校的片段了，自己只身来到深圳，本以为没什么朋友，自己一个人过着普普通通的假期和周末，很偶尔出去跟同事玩一下。结果一个大学时期隔壁班一起上课的同学开始约我出来玩，后面又有一个在深圳宝安中医院实习高中时期非常要好的老乡时不时叫我出去玩，最后是我的女朋友出现在了深圳。我们是小学同学，当时知道她在深圳，我以地主之谊请她出来吃饭，到慢慢爱上她表白，再到现在一起走了快半年的时光，她还会说我们两个人这样走在一起，她觉得很神奇。我自己单身了20多年突然生活里多了一个自己如此在乎的异性，生活也发生了翻天复地的改变。我开始为了引导她往好的方向走，为了让她可以过得更充实，教她python编程，科普她不少知识，给她工作上的建议，监督她改正坏毛病，这么多年来从未有一个人让我如此在意。为了记录我跟她的点滴，我多了写相处日记的习惯，将我们每一次见面都记录下来，从一开始的单纯流水账记录，到慢慢假如越来越多的细节，单篇日记可以四五千字以上，这占用了我大量的时间，极大地压缩了我的学习和锻炼的空间，她也讲了好几次，说我们每次见面其次都是重重复复那些事情而已，没必要一直写日记。然而，我认为这一切的牺牲都是值得的，这样的日记写到我们同居之后就不会再写了，约摸还可以写个小半年吧，到时候我要打印成小册子保存下来留念呢，想想我们以后还可以翻翻，就觉得很甜美~</p>
<p>常常说<code>work life balance</code>，在我的三观里我不认可为了工作把一切东西都放在其次，工作可以放在第一位，但是那只会在特定的时间段里（比如晋升期间）。对于我来说，爱情才是第一位，她才是第一位。她陪我度过了很多我的第一次，比如第一次有人关心我工作晋升情况、第一次有人专门为我庆祝生日（生日送fc游戏机你敢信）、第一次有人为我准备出游计划、第一次有人带着我到处吃吃吃，各种第一次多得我自己都记不清了，那种被她安排得明明白白的感觉真是太棒了……我们都为对方做出了不少积极的改变，我也不再像以前那样不修边幅了哈哈哈哈哈，我们会越来越好的！</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/play_games.png" alt="一起打游戏"></p>
<p>半年来虽然我们没有去过多少什么远方，说得上是出游的，就是国庆假去HK走了一天见了朋友，元旦假一起回广州玩了两天两夜，带她见了我的一个好朋友。本来国庆假是计划去湖南的，由于我们都很懒最后买不到高铁只能放弃，即便这样，每一次出游我们都十分珍惜，在出发前简单定一下行程，去到一个地方再定下一个行程，虽然十分粗糙，但是往往会在路上遇到惊喜。回想起来，正式表白后的一天出来见面她主动给我机会让我签她的手，在情人节那天交换了双方的初吻，还有很多甜蜜的回忆，也有一些争吵和阴暗面，各自都有自己的时间，精神上互相依赖缺不会一直粘着对方。从正式表白那天算起，我就在日历上勾出我们见面的每一天，现在一统计，原来<code>53.4%</code>的日子我们都有见面啊，意料之外的频繁呢~两人一路走来，虽然开心也少不了大大小小的矛盾，哭也哭过不少次，想不到我堂堂男子汉也会哭得稀里哗啦的，半年时间很不容易，倍加珍惜，<font color="red"><strong>感谢你</strong></font>☺️。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/she.png" alt="女王大人"></p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>2017年我在豆瓣上标记读过43本书，而2018年我在豆瓣标记的是看过20部电影，读过8本书。从18年开始我第一次在豆瓣上标记看过的电影，以前的我上是基本都不会去电影院看电影的，认知上就觉得为什么网上有高清资源还非要去电影院花钱看这么傻，然而有她之后就知道区别是什么了。自从恋爱之后，我的周末时间就再也不是单纯的看书学习，更多的是跟她见面约会一起去玩，最后一本书是我在8月份标记的，可以说我已经有4个月没有完整地看完一本书了，尤其是硬核技术书，一直没法坚持完整安心地看一本书，不少书反反复复看了一点就停了然后再看再停，自从毕业以后很多非常硬核的技术书就很难静下来心去啃了，也没有一个成小规模的个人代码学习项目，这让我很不踏实，害怕自己落后于别人😞。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/douban.jpeg" alt="豆瓣读书报告"></p>
<h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>健身习惯也有点变化，今年的最大变化是基本离开了健身房，走上了户外徒手锻炼的道路。10月份我的健身频率开始下降，在11月末脚踝痛风中断了整整4周的锻炼，整个12月份我几乎都没锻炼过！真是意想不到，对于痴迷健身的我竟然会中断锻炼如此之长的时间，手上的老茧都开始掉了。公司饭堂吃得也不好，营养跟不上导致体重还破天荒跌破大学时期最瘦的体重，这一切让我觉得我的力量和肌肉在日益萎缩，还有右肩的反反复复受伤，也使我偶尔不安。唯一值得开心的是，在8-9月份我终于完成了相对完整的<code>muscle up</code>，虽然要靠双腿摆动借力，不过算是有很大突破了，回想以前做个单力臂都要死要活的非常sloppy，自己一直在踏踏实实做引体向上慢慢积累基础力量和熟悉技巧，到最后完成完整动作的那一霎那，真的是有捶打胸口大吼出来的那种兴奋😆。</p>
<p>18年身体最好的状态，7月出差北京参加培训，在酒店的沙雕自拍 。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/body_best_of_2018.png" alt="沙雕自拍"></p>
<h3 id="老家"><a href="#老家" class="headerlink" title="老家"></a>老家</h3><p>2018这一年跟父母之间的关系也有了微妙的升级，明白父母为什么老是会想念我这个独生子（老家小镇独生子真的不多），为什么每次我回家他们都可以这么开心，以前以为自己本身就是个比较逗的人，所以回去后撩他们开心也是很正常的，其实远不止这个原因，最重要还是我是他们儿子的这个身份。每次回家都会和老妈晚上一起在小镇的河边散一次步，聊一聊我未来的打算，解释我为什么不愿意回老家买房子，我未来会在哪里发展定居，我的生活工作感情情况，我对生孩子的看法……每一次这样的对话，都感觉自己给老妈开拓了一些眼界，同时也能感受到老妈一辈子活在小镇，没出过省去过大城市见识的局限性，自己的担子不轻，为了美好的未来自己必须要成为一个相对优秀的人。</p>
<p>自从上了初中就一直寄宿在学校，在老家的朋友越来越少有联系。小学初中高中都是在老家上的，现在每次回到老家，小镇里就是那几个小学同学可以叫出来玩一下，初中同学除了继续成为高中同学的那些人外，全部断了联系（初中就是一段黑历史，宿舍里有个小混混头，把年级其他小混混招过来宿舍聚众吸烟，整天喊打喊杀讲江湖义气，也造就了我不沾烟酒的好品质🙂），高中也只剩下几个比较好的同学会叫出来一起浪。当然让我很欣慰的是，18年过年的时候一部分高中同学终于出来约了一顿晚饭，上一次约是15年了，还是那群比较活跃的人出来见面，大家还是很能聊，都是老样子。</p>
<p>回到老家很多时候需要帮父母干点重活，搬搬扛扛的，还记得高中还是大学的某一次回家，老爸让我扛了一袋很重的大米上楼，后来被老妈痛骂了他一顿说要是我的腰因为扛米扛坏了就绕不过我老爸，emmmmm作为一个初中就开始健身的人，我老妈待我如宝呢……自己一个人没事干的时候就会去镇里小公园锻炼一下，以前还有一点老年人保健器材在那里，勉强可以用来做一下臂屈伸，悬挂收腹等等基本动作，现在公园改造了，啥都没了，除了水泥路🙂。还有就是骑单车（自行车，粤语叫单车），两年多三年前花800收了一辆原价2k的二手Giant，有空就是拼命往深山老林踩，才知道老家虽然落后，但是好就好在自然风光还不错，自己方圆七八公里都踩过了，以前一点方向感都没有，现在脑里有点整合出一张小地图的感觉。特别喜欢在没人的路上狂奔，跟着耳机一震一震的鼓点，感受着从双腿蔓延出来的疲软，大口大口急促热辣地呼吸，真的是feel到自己很实在地活着。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/bike.jpeg" alt="小路与单车"></p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>18年后半年我几乎脱离了游戏。从小玩红警、CS、魔兽、各类网游，中学玩CF、DNF、各种单机、魔兽dota，大学还常常跟舍友一起魔兽，跟隔壁宿舍的肥韬开黑dota2打到深夜1点多的我，现在竟然对游戏如此佛性。手游玩着我觉得很不舒服，单机游戏越来越吃配置，我大学买的老神舟也跑不动了，关键是没有什么游戏的游戏性让我动心（玩起来还比较high的估计只有COD和Crysis了），还发现自己但凡玩游戏刷手机花的时间多了，会有一种恐惧想要尽快摆脱它们，于是乎这样也就渐渐告别了游戏吧，活得越来越不像个年轻人了，不过却有未来跟妹子一起合作开发点小游戏的想法。</p>
<blockquote>
<p>总结一句话，有了爱情，活得更完整，生活上虽然作了一些牺牲，但是都是为了更好的未来。</p>
</blockquote>
<h3 id="2019的FLAG-1"><a href="#2019的FLAG-1" class="headerlink" title="2019的FLAG"></a><strong><em>2019的FLAG</em></strong></h3><ol>
<li>结束目前奔波操劳的爱情生活，跟她一起同居，再也不用为了见面花时间在路上。</li>
<li>单次<code>pull up</code>达到25个，单次<code>dips</code>达到50个，<code>muscle up</code>脱离腰腿借力，完成<code>free handstand</code>、<code>front level</code>、<code>human flag</code>，体脂降到14%以下；带着她锻炼，让她获得川字腹肌。</li>
<li>豆瓣标记完成至少24本书，其中硬核技术书至少10本。</li>
<li>跟她一起远途出游一次。</li>
<li>工作日我可以12:30前入睡。</li>
<li>祈求痘痘再见😭。</li>
</ol>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个世界上钱不是最重要的，这个大家都知道。亲情爱情生活工作都很重要，但这个还不是最终的源头，最重要的只有一种东西，那就是<strong><em>时间</em></strong>。每一个人可以在各方面都有所不用，唯独相同的就是手上的时间上限，所以，给家人更多交流的时间，给她更多陪伴的时间，给自己的未来更多的学习和锻炼时间，最后的最后，其实都是为了一个更加美好的未来，这些愿望，全部都来源于一颗不甘落后的心❤️。</p>
<p>好在自己还有点自知之明，深知自己水平有多菜，自己大学4年，碍于狭隘见识和浅薄认知，没能把握好这个关键的蜕变时期，前2年半几乎都是做一个乖乖学生，完全束缚在二流学校的三流教学体系里面，只是在最后的1年才知道自己应该干些什么，然而都来不及了。<strong>努力最好的时间是前十年，其次是现在</strong>，B乎上不缺各种鸡血成才例子，别人是可谓下足了功夫吃透苦头才在4-7年内拿到令人羡慕的成就。</p>
<blockquote>
<p>不要用战术上的勤奋来掩盖战略上的懒惰。</p>
</blockquote>
<p>2019年年末再见，稀饭兄dei👋。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2019总结</title>
    <url>/2020/04/05/%E6%88%91%E7%9A%842019%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>妈耶，自己的博客坟头草就几米高了，上一篇文章已经差不多是1年前发的了😅（最近一篇博客其实是《<a href="https://zingphoy.github.io/2019/06/30/DIY装机小白科普-cpu篇/">DIY装机小白科普-cpu篇</a>》，前面的其他文章是后来补的）。没想到接近1年后发的文章，一发就是一篇年终总结，真正来动笔的时候，已经是2020年3月22日下午3点多，完成的时候已经在清明节假期了😂。为什么一直没写下来，一个原因确实是工作任务繁重，周末也要经常处理工作落下的问题导致没能起头，万事开头难嘛，不起头就干脆不写了，破罐子破摔，反正没人看，就不去花心血，我就是这么懒😂。</p>
<p>看了看时间，哇哦2020年都已经过去了1/4了，这年终总结再不写就真的是太过分了，还是决定动手来总结一下自己的2019年，顺便重新经营一下博客。</p>
<p>网上其实有不少大佬的博客，别人的年终总结是很明显看得出思考水平的，比如：</p>
<p><strong><a href="https://draveness.me/2019-summary" target="_blank" rel="noopener">https://draveness.me/2019-summary</a></strong></p>
<p><strong><a href="https://halfrost.com/halfrost_2018/" target="_blank" rel="noopener">https://halfrost.com/halfrost_2018/</a></strong></p>
<p>尝试写过博客就知道，要写出高质量的文章，除了肯动笔乐意分享之外，平时的刻意思考和训练是真的少不了，看看自己，自律能力还是差了太多，感叹连别人的屁股都看不到到的同时，鞭策自己赶紧跑起来。废话不多说，进入正题吧。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/wutongshan.jpeg" alt="梧桐山山顶"></p>
<hr>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>都是毕业3年的人了，生活中占比最大部分的肯定是工作，这一年完成了<code>百度安全团队 -&gt; 今日头条app</code>的工作变化。17年入职百度，眼看百度在18年达到市值巅峰接近1000亿美元，再到19年跌到300+亿美元，实在唏嘘不已；反过来，字节一直有着强劲增长势头，敏锐的国际化嗅觉，技术也有着足够的后起优势，没有太多历史包袱，团队年轻。确实印证了一句话：目标定得越高就越有可能做出更好的成绩。在各种权衡之下我选择了离开老东家去字节跳动。</p>
<h2 id="跳槽"><a href="#跳槽" class="headerlink" title="跳槽"></a>跳槽</h2><p>毕业在深圳百度呆了2年多，深感自己所在的团队以及周边团队规模太小，自知在发展上已经没有太大潜力，在2019年的8月份启动了面试找工作的“项目”，在10月底算起来也拿到了4个offer，最终在两个大offer之间选择了深圳字节跳动，从百度老咸鱼变身成字节加班狗🤣。最近跟一些前同事聊起以前的开发和测试团队，人也走了不少，剩下没走的说不定也蠢蠢欲动，世事无常，好聚好散。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/me_baidu_2.jpg" alt="百度纪念工卡"></p>
<p>公司都喜欢用这样的话来骗刚毕业的小朋友：<strong>多投入到工作，不要太计较加班，你能学习到很多东西</strong>🤐。会标榜说自己是一家技术驱动的公司，来到就会有很多大佬手把手将你带到行业的TOP，钱少一点不要在意。这些都是你懂我懂的毒鸡汤，但是毕业生一般没有这样的辨识力。世界上根本就没有技术驱动的公司，不论苹果还是谷歌，公司存活就要盈利，而技术只是商业化上的一个选择。对于毕业生来说，一个更大更好的平台，即使它的钱少几千（实际上往往平台越大钱还越多），也比任何其他工作更有潜力和发展空间。另外，技术人的成长极其依赖业余学习，如果加班太多，短期来说可能有正向作用，你会被迫接触到很多以前没做过的东西，但是长期来说，被工作牵着鼻子走并不会让技术人走向行业顶尖，没有人是因为多加班工作变成行业大佬（“加班”研究技术是另一回事），<strong>80/20定律</strong>就是一个参照标准，80%的工作量是应付繁琐零碎的东西，剩下的20%才有真正含金量。</p>
<p>算起来已经入职字节有5个月了，估摸着我的有效加班时长已经大大超过在百度2年多的有效加班时长了（有效加班时长：真正为了干活而加班），感同身受地说，加班并不会让人学到更多的技术，往往加班是因为效率低下，或者对外承诺太多，最需要花时间的是那些零零碎碎的问题，逼着人东一榔头西一棒子的。</p>
<p>字节跳动流传着一个文化：<font color="blue"><strong>成长看个人</strong></font>🧐。一个人的成长，除了外部环境氛围的影响外，更重要是看个人因素。生活中不乏各种家境优越，成长环境充满了资源的人，这种现象放到公司层面来，就是你的团队能不能给你提供更好的发展空间和成长资源，而你能不能更好地组织利用这些资源和渠道来滚雪球。人的成长并不是干巴巴的，就像人只要生存着就要消耗空气一样，你只要成长，首先要消耗的就是资源，资源的概念是抽象的，包括但不仅限于环境氛围、前辈指导、信息渠道、工作含金量等集合。这些资源质量越好，你越有可能在同样的学习强度下获得比别人更快的成长速度，这对以我来说，就是从百度走到字节跳动的最大原因了。</p>
<p>回头看19年在百度的工作历程，看着平淡也还是有一点收获。5月份起我在百度的工作内容发生了明显变化，脱离了业务测试岗位，跟leader做起了安全专项测试，专搞web方向漏洞挖掘，前后接了3个大型的内外部系统的工单，也是这个机会开始接触web的安全知识，入门Go并用它将一个C语言开发的<a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">开源CVE漏洞检查工具</a>重新实现一次，其中也用到perf工具做一些性能调优。这段经历给我的感受有三个：</p>
<ol>
<li>明白安全领域的不容易，决定放弃安全方向的深入学习：做安全如果不能早起步，在工作之后还想跨领域专精安全是比较困难的。因为需要很多时间投入来打安全基础，尤其是搞渗透搞逆向，更是要扔一把一把的时间来理解系统底层、软件设计、安全实战等。</li>
<li>白盒审计代码，是降维打击。先知道黑盒上的功能，直接点对点review代码，更高概率发现问题。表面看起来牛逼的项目，不还是代码一砖一瓦堆起来的。</li>
<li>学习一门新编程语言并不难，难就难在能否坚持用新语言做技术输出。</li>
</ol>
<p>这段搞web安全专项测试的窗口，给了我接触新技术的机会，有了一些时间去思考自己的定位和发展，知道安全并不是自己最感兴趣的方向，最终决定换工作。去到字节跳动也是有一定的偶然因素，一开始并不想去强度那么大的地方，甚至跟同事表达过不去字节高强度加班的观点，自己明白技术人没有时间自我提高是很危险的。然而在字节高强度加班offer和一家高时薪外企offer的对比之下，最终自己还是真香选择了字节🤣。字节的面试着实让我感受专业素质和到对人才的渴望，这也是我为什么愿意切换技术栈投入到移动端质量保障的原因。</p>
<p>来到字节跳动，对它的历史做了简要了解后，才明白一个很重要的道理：<font color="red"><strong>选择大于努力</strong></font>。为什么这么说，可以拿当下一些字节高层员工的工作历史来看，要做到财富自由，单纯从一家公司努力往上爬，在有限的十年中能去到顶端的人少之又少，因为坑就是那么多，占一个少一个，你要上去别人就得下来。而更好的机会，往往是藏在急速发展的小公司中，进入未来独角兽企业，伴随着公司团队一起发展，把先前积累的工作经验应用在当前团队，时势造英雄，这种环境下更可能成为公司的顶级人才，在上市的一刻实现财富自由。这里着眼点比较低俗，并不代表你占到坑就成功了，前提是你要具备对等的能力与潜力，机会也只留给有准备的人，满足这样的前提，就会有 <strong><em>猪站在风口上都会飞</em></strong> 的现象，抢占坑位与抢占市场是同一个道理，比的是谁更有先见之明。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>在百度里更多的是做被动测试的角色，安全产品的迭代速度很慢，约两周到一个月，RD来什么需求我就针对性做什么测试，在测试细节上做得还可以，能做百盒都尽量做，但是整体质量建设只停留在起步阶段，QA缺少大局思维，RD没有质量意识，也没有外力推动做建设。除了常规流程建设，没有自动化，半自动化也不成体系，公司很多能力也因为产品性质无法接入。总结一起来就是：对于QA来说，一直停留在单兵作战缺少大盘规划的感觉。这也给个人成长带来了明显的瓶颈，可以这么说，在百度的两年半里学到的东西，实质上用9个月到一年就可以完全掌握。</p>
<p>在字节的头条app的QA团队里，我的定位虽是测试序列，但是游离于业务测试、技术专项中，接触面远比在百度大，也有机会参与制定短中期规划，和比我工作年限高很多的同事共事，解决的问题也更多元化，让我看到除了常规业务测试外更多的质量保障手段，包括但不仅限于过程改进、线下自动化、线上监控、质量度量、竞品评测、专项建设等，每一个topic背后都是庞大的建设量。</p>
<p>至于当前工作的缺点嘛也是很明显的，比如：技术专项上的技术挑战还是稍有欠缺；工作量大导致无力顾及业务质量建设；加班严重极大压榨业余学习时间。除这里提及的缺点，对目前的工作满意度还算ok。</p>
<p>循例摆个工位图，传言屏幕越多，技术越菜，发现大佬们似乎都不爱用外接屏幕的🤔，<strong>顺带打个广告，字节跳动app质量保障团队很缺人力，业务也好技术也好，只要基础过关，统统欢迎</strong>🎉🥳。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/bytedance_desktop.jpeg" alt="字节工位"></p>
<h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>头条app的QA团队的结构看起来相对合理，由于我的角色定位，偏技术维度的事情更多由我来负责，同时也参与到团队目标设定、质量度量、氛围建设中去，经常是大家围一起商量探讨，一点一点迭代出方案或者对齐目标，有很好的参与感。最近有一件事让我很惊讶，上级的上级直接找到我来做QA方安全建设的规划，原因是整个QA团队只有我有安全背景，这除了说在大规划上是我的初体验外，也真真切切感受到敢用新人的文化，这是我闻所未闻的。</p>
<p>反观我的百度生涯，单兵作战小产品小团队的模式，一个人要对接所有信息，没办法做良好的信息筛选，也没办法做到各自分工，有好的想法因为人力问题导致无法开展。这种单人独立对接多个项目的模式真的空间太小，就像技能点各自只点一两级而且还有点歪技能的感觉。职场除了亲自做事是最好的学习手段外，看着前辈做耳濡目染也是十分重要的学习手段，百度生涯就是缺少一个资历丰富的前辈带着我做事，眼光和认知就局限在那么点空间，是很难突围的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个2019年里，百度生涯的技术成长速度严重不符预期，量变过少，质变更加没有。11月来到头条，过2-3个月后接手了其他人的代码，在上面做了各种优化让老方案焕发生机run起来，整个过程明白了QA岗位的一个要求：<strong>不需要QA写代码写得多溜，但是需要QA写的时候要能写出来</strong>。更高层面来说，做技术最重要是发现问题，然后是给出方案、如何解决问题，其次才是具体代码实现，解决实现细节问题。虽然QA也分不同领域方向，最终还是殊途同归，目标都是质量保障，只是达到目标的切入点各有区别，一切都是为了测试左移，尽快发现风险和缺陷。当然要追技术梦的话，肯定是开发岗起步更好，然而两者并不冲突，QA也可以做到技术专家，只是需要刻意做更多技术沉淀。</p>
<p>之前刷手机看到一个做算法的前辈说职业发展：</p>
<blockquote>
<p>一般3年或5年考虑一个大致方向，职业规划都是因人而异的，要考虑能力兴趣和短板，多找一些样板，大概比自己大5岁左右，当成自己下一个5年的参照对象，这些人是大家眼里成功的或者失败的，自己再换位思考，假设自己是ta，到底喜不喜欢ta的位置，心累不累，有意思没，自己最喜欢谁的位置，再一一补齐自己对应的能力短板。</p>
<p>对于自己的技术发展，要有一个 <strong>浅入深</strong> 或 <strong>窄变宽</strong> 的脉络，点亮技能树的各种分支，而不是一个系数的图上乱点技能，过一年又换，这种没有积累。没有做过的应用场景，多从数学问题本质思考，锻炼迁移学习的能力，养成好的算法思维惯性，不要被绩效、快速拿收益等完全带偏，先从数学建模角度思考，落地再做方案折中。</p>
</blockquote>
<p>方法论真的很重要，所谓经验，可能就是方法论的具象化。就像解数学题需要套用公式，方法论就是解决不同领域问题的工具。对于技术界，要解决一个问题，看看业界怎么做，看看学术界有没有研究，看看内部有没有现成的，能不能拿来主义然后做定制化，简单方案先轻量run起来，再一步步迭代完善，这就是常规的方法论，或者说是套路。</p>
<hr>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>19年做了人生中的第一次真正意义的手术，把拖了半年多的肩膀问题给治了——在18年11月因为练习双力臂，一边肩膀应力过猛导致受伤。本以为年轻人过一段时间就会好，殊不知过了大几个月，只要肩膀转到特定应力位就会明显疼痛，最后在19年7月份去医院做了个微创，前后3天2夜就出院了。距离手术完成已经过去了8个月了，肩膀大概康复了90%。在康复的这么长时间中，几乎放弃绝大多数的体育运动，也因为来到头条之后休息时间变得更少，感觉身体素质往下掉了不少，无论力量、速度、耐力，估计只有肩膀受伤前的70-80%吧，来到头条伙食实在太好了点，体重也到了历史新高<strong>140+</strong>😑，那些刚毕业的小朋友还天天嚷着饭堂很难吃很想念学校，看来他们是真的没吃过难吃的饭堂……</p>
<p>最近已经开始重新运动了，做不满20个臂屈伸就整不动了，而且还不敢太浪怕肩膀二次受伤，需要时间好好把以前的身体状态练回来。先从臂屈伸开始，接着就是引体向上，再来就是前水平和双力臂，健身跟技术，在过程上是一样的，都需要慢慢积累，时间长了效果就有了！</p>
<h2 id="老家"><a href="#老家" class="headerlink" title="老家"></a>老家</h2><p>今年爆发新冠肺炎疫情，回老家过年也很不一样，以前父母说啥我们都不听，现在我们说啥父母也不听🙃。这一年回老家特别没有过年的感觉（自从上初高中起年味就淡下去了），感觉爸妈又老了一年了，发现老家很多地方已经变了自己现在才知道，跟老妈外出散步时指着哪个地方说起小镇以前这里是什么那里是什么，是真的深刻意识到岁月的问题了！年后会深圳用百度地图查到15年老家的全景照片，当即拍下来发给父母看看，让他们回忆一下。</p>
<p>过年时掏起手机一顿乱拍：家里过年炒的菜、家里的每个角落，还有最重要，<strong>我们一家的合照</strong>❤️，我已经敲定了，以后每回一次老家，都要跟爸妈在同一个地方来一张合照📷，这些照片肯定是我未来最珍贵的宝物之一。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/new_year.jpg" alt="老家过年的9种食物"></p>
<p>在百度时回老家也就是一年三四次，来到头条假期少了很多也忙了很多，估计也就一年两三次机会了，2020年因为新冠疫情原因估计回家机会也不多，换成以前，清明节爬山祭祖我是一定会回去的，这一年我只能留在深圳宿舍里敲着博客想念老家……</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/hometown2.jpeg" alt="老家小镇"></p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>来到头条后，真的是<strong><em>再也没有再看过一本完整的书</em></strong>了，或者说，看书的总页数不超过40页😶，自我时间管理做得太差了，平时加班很晚一回来就瘫在那里，周末也选择了补工作而不是学习……翻翻自己的豆瓣记录，惨不忍睹，有种我后面几个月人间蒸发的错觉。剔除【物我之境】这本突然记起以前看过就随手标记的书，19年我只看了8本书，自从进到字节之后就彻底断掉了，时间是真的少很多🙂。不过对其他领域的书突然多了很大兴趣，以前看书可能更多的是为了刷指标，现在看书有种由内自外的驱动力，是真的很想了解某样东西才去看书，很想系统学习才去看书。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/20200405233938.png" alt="2019年读书清单"></p>
<h2 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h2><p>19年我终于跟女王大人住在一起了！搬到某个城中村30平小房里，在5月份一口气花了1w多买各种电器家具来布置我们的小窝。19年我们俩也和平了很多，记得以前是平均一个月就要炸一次，同居之后已经很少发生这种事了，不过最令人蛋疼的一次就是一起去顺德玩在路上生闷气打冷战了，那两天的游玩直接变成了冷战，别提多蛋疼。</p>
<p>在相处上我终于从钢铁直男开始转变了，每个男生总要面对跟女友相处的一些操蛋情况，即使是对方不讲道理，能不能摆下面子先安抚情绪就成了直男是否开始成熟的标志😅。</p>
<p>布置过的小窝还是摆个照片吧，过了几个月后桌面更多东西了，下图是最原始的样子：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/our_house.jpeg" alt="小窝"></p>
<hr>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><p>回过头来看<a href="https://zingphoy.github.io/2019/01/02/我的2018总结/">2018年年终总结</a>给19年立的flag，是一个都没达到啊😅：</p>
<blockquote>
<ol>
<li>亟需提升的是代码量，在2019年平均每个月可以产出<code>500行</code>结构化的代码，无论是工作代码还是个人代码都好，那种小脚本小工具不包括在内。【可能每月200-300行左右，大多数还是在换工作后才写的】</li>
<li>最高优的是<code>在安全方面打好基础</code>，熟悉web安全、Linux安全、汇编和各种工具的使用；另外Linux内核、游戏开发、二进制分析、渗透、病毒分析等需要入门。【彻底放弃安全方向，依然对安全领域有较强探索欲望，但是优先级会很低】</li>
<li>一个一直都想点亮的技能就是学会1个web开发框架，自己写一个博客的前后端，或者搞一点有意思的小需求。确定选中<code>flask</code>，自己未来的主力语言应该是python，备选是go。【用go重构了一个开源安全扫描工具，至于web后端，竟然还是tm零接触，失礼】</li>
<li>阅读至少<code>2个</code>大型开源项目的代码（python源码已经在清单之内）。【完全尼玛没读过哇……】</li>
</ol>
</blockquote>
<p>简直是一事无成……好好复盘一下，flag都没达成，要不就是目标定得太高，要不就是自己没有执行落地，很明显是后者嘛，关键问题还是去到自律与计划能力上，自己的潜力部分没激发出来。说到个人时间管理，这个技能在最近一个月有了明显长进，这里有一篇的文章需要引用一下：</p>
<p><a href="https://draveness.me/few-words-time-management" target="_blank" rel="noopener">如何管理自己的时间资产</a></p>
<p>软技能就是这样，它不像谋生的硬核技能那样，这么容易被发现或者总结，很多时候对软技能自己只是有那么点儿认知，说的好听就叫只能意会不能言传，实际上是还没完全弄明白，模模糊糊不能总结抽象出来。方法论其实还是有的，像上面的文章那样清晰表达出来，就是自我管理的进阶表现。</p>
<p>毕业至今，定过的所有KPI、OKR，全都像过眼云烟，定完就忘记了，没有周期check，没有milestone，最后就是完全走偏目标，弄不清楚自己干过了些什么，被牵着鼻子走，也从来没复盘过，最近对这方面有了更多的了解，认知才算打开来。年后简单实践了一下上面的方法论，虽然完全不够作者严格，不过确实有些效果，最大的感受就是进度可视化，而不再是模模糊糊难以言状，下面就重新定义<strong>🚩2020年的目标🚩</strong>吧。</p>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><p>首先大致方向有几个：</p>
<ol>
<li>学习一个不同领域的开发技能。</li>
<li>入门一个不同的技术方向。</li>
<li>掌握一种新的编程语言并应用。</li>
</ol>
<p>叠加工作因素与个人意愿，由上面的方向转化而来的目标：</p>
<blockquote>
<ol>
<li>熟悉后端python Flask + 前端（Vue.js or 其他）的开发能力，具备初级移动端Android / iOS开发能力。</li>
<li>阅读python Flask框架、requests库 &amp; 低版本MySQL源码。</li>
<li>掌握基本的ROP技术，能独立分析一个安全漏洞。</li>
<li>每月至少产出2篇优质博客。</li>
<li>至少阅读8本书。</li>
<li>体重保持在 70±2kg，解锁双力臂、前水平两个动作，俄式挺身不强求。</li>
<li>跟女王大人去国外溜达一次（视新冠疫情而定）。</li>
</ol>
</blockquote>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这种流水账式的无脑年终总结应该是最后一篇了，这一次换工作算是职业生涯中一次重大转变，百度是一个跳板，在字节的生涯发展得如何也说不好说。这小半年来意识到，自己很多潜在技能都有所长进，包括技术感知力、自我管理、自我定位、向上管理等，隐约预感2020年会是一个技术和能力上的质变年，希望自己能顶住压力上去。</p>
<p>19年整年来，亲人、爱人、朋友、同事，但凡每一种关系，都能比以前处理得更好。亲情和爱情更温和了，职场上也交了几个要好的朋友，本性收敛了一些，回想起刚毕业时的自己，沙雕青年口无遮拦大嘴巴子，惹人爱也惹人厌。</p>
<p>最后也没什么好说的了，期待2020年自己的转变😌 ~ </p>
<p>愿自己可以成为自己最喜欢的那一类人。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/hoishan_railway_2.jpeg" alt="老家火车站"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>技术驱动？</title>
    <url>/2019/12/03/%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>💻互联网公司招聘技术人，总喜欢自诩为技术驱动的团队，以此来吸引各路技术人才，技术驱动是什么定义？</p>
<p>参考知乎的一个<a href="https://www.zhihu.com/question/27455407" target="_blank" rel="noopener">回答</a>：</p>
<ol>
<li>能自动化的东西绝对不用人力堆。</li>
<li>效率提升重过业务增长。</li>
<li>跑得比别人快，哪怕你放开来让人抄，抄的了你的产品，抄不出你的发展速度。</li>
</ol>
<p>这个知乎<a href="https://www.zhihu.com/question/312019918/answer/608965942" target="_blank" rel="noopener">回答</a>也很到位。</p>
<p>公司可以有完备的工程师文化，内部可以崇尚技术，技术人员的数量可以占大头，但是技术最终是不能创造收益的，它需要落地到业务才有价值，它需要被应用到实际场景才能输出，技术并不是学术研究（学术研究有较强的前瞻性，但在大范畴下，学术也是被应用目标所指导的，还不是彻底的技术驱动，只不过学术过程是更为硬核的数理逻辑化）。</p>
<p>前两三年各大厂纷纷建立XX实验室，本质是希望技术可以走在业务前面，解决一些未来可预见的问题，甚至开创一个新领域，这包含很多的前沿技术研究，同时他们也要为公司积累技术影响力，吸引更好的技术人才来解决问题。但是归根到底，实验室本身也是为了业务线服务的，产出最终还是要落地到具体业务线，只是实验室可以更安静地研究技术而不必投入到一线业务，估计没有多少家公司愿意花几倍于普通工程师的钱去养活一群只看论文发论文参加学术会议的专家。</p>
<p>现在有很多to B技术解决方案的公司，如各种安全服务、数据存储服务、虚拟环境服务、持续集成服务等，它们已经便捷到只要按照文档的说明调几个接口，甚至是在web平台上配置一下一键点击就能run，看起来好像很黑科技，你就能说他们是技术驱动的公司吗？同理，不少大公司内部同样有很多提供技术解决方案的团队，做了很多公司内部的产品平台，推广宣传时也会说应用什么什么🐂🍺的技术，你能说他们就是技术驱动的团队吗？不要忘了他们绝对会讲他们这个方案解决了什么问题！这就是他们的业务。他们做的一切其实都是在服务客户，而这个客户可能是外头真实的用户，也有可能是内部员工，只不过在提供这些服务或做这些产品时，团队可以选择更好更火更高大上的技术。</p>
<p>技术驱动对于公司来说是不存在的，即便是世界级的Google、Apple、Facebook等。公司的本质是一个商业组织，如果认清了这一点，那么就不存在技术驱动还是产品驱动的公司了，不论是技术还是产品还是设计等，一定都是为了业务服务的，只是说在业务的后面，谁的能量发挥的更大一些而已。比如华为、阿里等不少技术大企业的文化都包含为【客户第一】，本身就说明了很多道理。</p>
<p>对于个人来说，确实存在技术驱动，但是对于公司来说，永远都会是业务驱动。</p>
<p>产品、技术、运营，这几块才是构成公司的主要模块。</p>
<p>产品，设计别人想不到的创意；</p>
<p>技术，构建起技术壁垒让别人抄不了产品；</p>
<p>运营，让别人抄得了产品抄不了流量。</p>
]]></content>
      <categories>
        <category>文化</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>技术驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>提测流程</title>
    <url>/2019/11/20/%E6%8F%90%E6%B5%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>以前的团队推的流程是一轮一轮的测试，举个例子，提前写好了30个case，第一轮先把30个case执行一遍，然后就有相应的bug出来，case哪些pass哪些fail，以邮件的形式通知相关人士结束第一轮测试，RD此时去统一修复bug，再次转测QA继续对接……</p>
<p>这样的流程显然是又笨又重的，它假设了RD不能灵活支持bug解决，并且QA可以短时间内完成case执行，抹杀了RD与QA之间并行的可能性。如果QA把case执行一轮的周期从一个早上变成一天甚至两天，那这个流程对于项目进度来说简直是毁灭性的，大概只适合在需求被拆分得很小的情况下才能有效率地开展。 </p>
<p>目前团队在推流程，需求沟通期QA都需要参与进去，然而（貌似）并没有机会参加详细设计评审，也不知道RD内部有没有这种正式评审。QA对于需求具体实现的疑惑，就会推迟到case评审甚至是测试执行的阶段才会暴露出来，增加了这两个阶段的沟通耗时和case返修量（往往在case评审时RD也不会很认真）。在测试阶段暴露出细节问题时才知道RD的实现方式，这本身就是一个测试风险，会拖长测试周期。我个人觉得详细设计评审对QA很重要，除非只想停留在黑盒层面测试，但是这里的团队没有详细设计流程，比较可惜，可能跟UI需求数量大无需做重评审有很大关系。</p>
<p>转测流程的推行，我觉得除了规范操作外，一个更重要的作用在于保护QA，让QA可以腾出更多的时间于常规业务测试之外，建设更多的质量保障工程。QA规范了流程保护了自己，踩低级坑所消耗的时间就去到了RD和PM身上，也就是为什么QA喜欢拥护流程并主导流程建设，RD和PM多数是配合。</p>
<p>当然，转测流程特指的是QA与RD、PM的合作关系，而RD与PM之间一般也存在需求流程，不过总体来说消耗更多时间的部分还是在QA测试这一块，所以RD与PM之间的流程往往不需要刻意地去建设也能轻松运转起来。</p>
<p>流程之所以存在，之所以有必要，是为了组织团队的运转可以是高效的，一般流程在刚施行的时候需要理解成本，这里需要一波推动力，当流程良好run起来之后，组织就已经可以内部自动维护这个流程了，也就是当流程深入人心的时候每个人都会是流程的拥护者。</p>
<p>然而实际上除了【要推动什么流程】外，【怎么去推动流程】也是一个难点，梳理一套流程，业界大把大把的方案可以参考，但是要怎么推动流程，为了让流程顺下去要配套什么样的工具链，各个环节如何打通使得每个信息孤岛串联在一起，我觉得这才是更难的问题。</p>
]]></content>
      <categories>
        <category>流程</category>
      </categories>
      <tags>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据是万能的吗</title>
    <url>/2020/04/04/%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84%E5%90%97/</url>
    <content><![CDATA[<p>不久前更新了安卓微信，昨天用微信的时候突然发现表情包可以在聊天窗口里直接删除或者置顶，当真眼前一亮，我本来就是个表情包重度用户，同时还有点表情包洁癖，表情包用厌了就喜欢删删删，现在终于发现一个好的入口让我管理自己的表情包了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/wechat_sticker.png" alt="表情包管理"></p>
<p>在我一边骂娘埋怨微信PM咋现在才出这个功能的时，我一边想这个需求不应该是大量用户都需要的吗？不排除是我先入为主，可能这个需求并不是什么重要的需求，不过这件事让我思考到另一个问题，PM是不是单纯用线上的功能使用量来判断某个功能是否需要进一步开发呢？</p>
<p>来说到互联网产品，PM的工作方式可能有很多种，但必然存在一种方式，就是根据线上数据的反馈来持续打磨产品。那套到上面那个例子，是否可能因为线上很少用户会主动使用表情包管理功能（删除、置顶等），导致PM对这个功能的挖掘优先级降低呢？再往下问一个问题，线上数据就真的能反馈用户的真实诉求吗，用户使用少是因为用户不在意这个功能，还是用户不知道这个功能，或者是功能不好用导致用的人少？</p>
<p>对于线上数据，除了冷冰冰的统计分析外，是否还需要引入更多的思考？PM要如何打磨产品，除了科学的数据统计外，终究离不开用户体验，这又来自于对生活细节的观察。</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>文档解决什么问题</title>
    <url>/2019/11/19/%E6%96%87%E6%A1%A3%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>📄今早组里的同事一直在问某个工具怎么用（内部的一个工具平台），这个工具对接到头条这边，目前只有三个员工有正式了解过，其他人是不知道的。工具的官方使用手册也着实写得差强人意，又长又臭😂，于是花了二十分钟写个科普文档从自己的认知角度来解释工具的作用，解决大家对工具的疑问。</p>
<p>想了想，到底什么时候需要来写文档呢？</p>
<p>写文档的目的，是为了解决某些需要反复沟通反复确认的问题，人脑是不可靠的，毕竟自己写的代码曾经理解过的东西，过一个月回来看可能就需要刻意回忆和理解了，文档正是以最简单明了的方式来唤醒人的记忆，或者直接并且不丢信息地传达思想。</p>
<p>给你一份文档你可以反复看，你可以过几天再看，反正你变着花式看都无所谓，有问题看文档，不用去打断别人的工作，这也是文档的好处。</p>
<p>不得不说，正是因为上面提到的原因，文档可能会发展成一种教条。凡是做出来的东西，都给写个文档出来，我不看具体的产出，我就看文档，我只需要通过文档去了解你的东西是什么……不仅仅是程序代码，文档虽然好使，但提供的信息毕竟有限，希望通过文档去获取到超越文档直至整个项目的信息量，是不存在的，这就是典型的本末倒置了，你总不能盼望我写一个程序，然后再写本书来解释程序的细节吧。</p>
<p>以前有个同事说过，文档只能反映项目当时的状态，它已经是历史。这句话是对的，文档往往较难随着项目一起迭代，如果人不参与进来，文档永远只能表达项目的历史状态，创作维护文档是需要成本的。工作经验教训了我，RD修改了代码，是不保证同步修改文档的，看文档不如看代码，看代码不如当面撕逼😂。同时文档又存在另外一个问题，就是它可能被一个不知情的人改坏了，或者有人悄悄把什么东西改了不通知大家，企图瞒天过海（功能有bug不符合文档描述，我把功能文档改过来，那这就不是bug而是feature了🤔）。</p>
<p>为了解决上面的问题，文档系统也开始进化了。出现文档历史快照功能，出现文档一经修改就群发通知的功能；开始提倡代码即文档，用代码生成文档；更新代码的时候应该同步更新文档等理念。这些东西都让文档越来越正规化，但是他们并没有增加文档的价值，只是在保持文档的价值不被各种骚操作抵消。</p>
<p>好像已经严重偏题了……</p>
<p>那什么时候需要写文档呢？</p>
<ol>
<li>项目前期沟通，将想法落地成可阅读可理解的文档，这样才具备多人可讨论性。</li>
<li>项目稳定时，应该把稳定的部分抽取出来整理成文档减少沟通成本。</li>
<li>需要大面积沟通同步时，传阅文档应该比开群会效果更好。</li>
<li>文档可以提前梳理好各种疑问，有时候比口头更加全面一点。</li>
<li>已经确认拍版的结论，最好让它变成文档成为证据。</li>
</ol>
<p>文档永远是个灵活的东西，不要给它的使用场景设限……</p>
<p>但是切记文档与手册的区别，就像书籍也分精读书、略读书、工具书一样，文档如果过大过全失去重点，也就失去了它本身的意义，甚至没有人再愿意提前阅读它。</p>
]]></content>
      <categories>
        <category>流程</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端压测怎么做</title>
    <url>/2020/04/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8E%8B%E6%B5%8B%E6%80%8E%E4%B9%88%E5%81%9A/</url>
    <content><![CDATA[<p>博文的内容并不都是我原创的，行文思路来源于一次内部分享，再结合网上众多参考资料总结出来的，算是一个学习笔记。</p>
<p>可能很多QA、RD同学跟我都一样，对服务端压测一直没有系统的认知，印象停留在使用压测工具如Jmeter对单接口发压，调整线程数和循环数来制造不同压力，最后计算一下TPS和成功率等就完事了？网上虽然有不少压测相关的文章，但多数是压测工具的入门级使用，有的是压测流程和指标的简单解释，或者就是几个大厂牛逼的全链路压测能力和压测平台的介绍。这些文章要不缺少系统性阐述，要不过于抽象不好理解，对没怎么接触过压测的同学不太友好。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/why_3.jpg" alt="我裂开了"></p>
<p>本文在QA角度梳理一次完整的压测过程，尝试总结更为普适的压测思路，给大家提供更有意义的参考。</p>
<hr>
<h2 id="压测背景"><a href="#压测背景" class="headerlink" title="压测背景"></a>压测背景</h2><p>测试分很多种，网上很多文章<a href="https://www.guru99.com/performance-vs-load-vs-stress-testing.html" target="_blank" rel="noopener">^1</a>会玩弄概念，搬出来3个名词：压力测试（Stress Testing）、性能测试（Performance Testing）、负载测试（Load Testing）。一般情况下并不需要做这么细粒度的概念区分，这3个概念我觉得是没办法完整区分各自边界的，至少在程序逻辑上难以做得到，更多差异只是来自于不同的压测策略，所以尽管忽略这几个概念的区别，都叫它压测或者性能测试即可。</p>
<h3 id="为什么需要压测"><a href="#为什么需要压测" class="headerlink" title="为什么需要压测"></a>为什么需要压测</h3><p>拿技术人熟知的阿里举例，应该是国内做压测最好的一个大厂。外界熟知的阿里2012双11活动，2012年11月11日零点，阿里各种系统报错、立刻下单报错、购物车支付报错、支付系统报错、购物车的东西丢失，系统显示交易成功率不到50%，产生了大量超卖，给阿里带来很大的损失。那一年的双11后，库存、商品、退款和相应数据库的同学，为了处理超卖导致的问题，没日没夜加了两周的班，同时给了用户不少糟糕购物体验。</p>
<p>为什么出现这么严重的问题？因为对整个全交易链路上的各个子系统的承受能力不清楚，并且错误预估了可能会达到的流量，也没有完善的预案，兵败如山倒。</p>
<p>2013年阿里首次提出了全链路压测方案：一方面可让链路的各个系统知道自己的承压极限；另一方面可让各个系统有个明确的优化目标，了解到整个链路的瓶颈并评估资源情况。</p>
<h3 id="单系统压测与全链路压测"><a href="#单系统压测与全链路压测" class="headerlink" title="单系统压测与全链路压测"></a>单系统压测与全链路压测</h3><p>为什么只做单系统压测还不够呢？</p>
<p>在活动开始的瞬间，各系统都面临自身服务的巨大的压力，而系统之间是有互相依赖关系的，单机压测没有考虑到依赖环节压力都比较大的情况。一个系统出现故障，故障会在链路流转过程中层层累加，会造成无法评估的影响。</p>
<p>所以最可靠的方式是完全模拟真实场景来压测，通过线上全链路压测提前发现问题。</p>
<h3 id="压测流程"><a href="#压测流程" class="headerlink" title="压测流程"></a>压测流程</h3><p>完整的压测流程一般包含下面几个步骤，引用自<a href="https://developer.aliyun.com/article/721643" target="_blank" rel="noopener">文末参考资料</a>：</p>
<ol>
<li>压测目标的制定</li>
<li>压测链路的梳理</li>
<li>压测环境的准备</li>
<li>压测数据的构造</li>
<li>发压测试</li>
<li>瓶颈定位及容量微调</li>
<li>压测总结</li>
</ol>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/strest_testing_flow.png" alt="常规压测流程"></p>
<hr>
<h2 id="压测目标"><a href="#压测目标" class="headerlink" title="压测目标"></a>压测目标</h2><h3 id="压测作用"><a href="#压测作用" class="headerlink" title="压测作用"></a>压测作用</h3><ul>
<li>新服务，无预估目标，需要通过压测得到服务基准数据或找到系统瓶颈进行优化</li>
<li>有明确的压测目标，需要通过压测确定服务的各项指标是否达标</li>
<li>常态化压测，为后期性能优化指导方向或提供参考依据</li>
</ul>
<h3 id="压测指标"><a href="#压测指标" class="headerlink" title="压测指标"></a>压测指标</h3><p>列举一些常用指标，并不一定都需要关注，根据业务考虑指标的细化粒度。</p>
<ul>
<li>QPS：Query Per Second，每秒处理的请求个数</li>
<li>TPS：Transactions Per Second，每秒处理的事务数，TPS &lt;= QPS</li>
<li>RT： Response Time，响应时间，等价于Latency<br>RT分平均延时，Pct延时（Percentile分位数）。平均值不能反映服务真实响应延时，实际压测中一般参考Pct90，Pct99等指标</li>
<li>CPU使用率：出于节点宕机后负载均衡的考虑，一般 CPU使用率 &lt; 75% 比较合适</li>
<li>内存使用率：内存占用情况，一般观察内存是否有尖刺或泄露</li>
<li>Load指标：CPU的负载，不是指CPU的使用率，而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，表示CPU的负载情况，一般情况下 Load &lt; CPU的核数*2，更多参考<a href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">链接1</a>和<a href="https://www.jianshu.com/p/02825a66e46f" target="_blank" rel="noopener">链接2</a></li>
<li>缓存命中率：多少流量能命中缓存层（redis、memcached等）</li>
<li>数据库耗时：数据库就是业务的生命，很多时候业务崩掉是因为数据库挂了</li>
<li>网络带宽：带宽是否瓶颈</li>
<li>接口响应错误率 or 错误日志量</li>
</ul>
<p>这里要说明一下QPS和TPS的区别：</p>
<ul>
<li>QPS一般是指一台服务器每秒能够响应的查询次数，或者抽象理解成每秒能应对多少网络流量</li>
<li>TPS是指一个完整事务，一个事务可能包含一系列的请求过程。举个🌰，访问一个网页，这是一个TPS，但是访问一个网页可能会对多个服务器发起多次请求，包括文本、js、图片等，这些请求会当做多次QPS计算在内，因为它们都是流量</li>
</ul>
<p>性能测试中，<strong><em>平均值的作用是十分有限的</em></strong>，平均值代表前后各有50%的量，对于一个敏感的性能指标，我们取平均值到底意味着什么？是让50%的用户对响应时间happy，但是50%的用户感知到响应延迟？还是说50%的时间系统能保证稳定，而50%的时间系统则是一个不可控状态？</p>
<p>平均响应时间这种指标，只有在你每次请求的响应时间都是几乎一样的前提下才会有一样。再来个例子，人均财富这个概念有多沙雕相信大家也明白，19年有个很搞笑的新闻——<a href="http://finance.sina.com.cn/roll/2019-05-16/doc-ihvhiqax9049380.shtml" target="_blank" rel="noopener">腾讯员工平均月薪七万</a>，明白平均值多不靠谱了吧😂。下图是现实世界中一个系统的响应时间柱状图，RT在前20%的请求数实际较少，而耗时特别短的请求拉低了均值（这些请求可能是命中缓存，也可能是快速失败），而大多数RT是在均值之下，那才是系统的实际性能情况。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/percentile_average.png" alt="均值并不能反映实际情况，引用自：https://www.dynatrace.com/news/blog/why-averages-suck-and-percentiles-are-great/"></p>
<p>所以说，<strong>我们不应看最好的结果，相反地，应该控制最坏的结果</strong>，用户用得爽他不保证会传播好口碑，但是用户用到生气他保证变为键盘侠肆意大骂，这也是为什么平均值无法带来足够的参考，因为happy的结果蒙蔽了我们的双眼，平均值在压测中丢失太多信息量。</p>
<p>总结一下，较为科学的评估方法应该将<code>指标-成功率-流量</code>三者挂钩在一起的：</p>
<blockquote>
<p>xx%的响应在xx毫秒内返回，其中成功率为xx%。</p>
</blockquote>
<p>根据这个方针，可以得到一些测试思路：</p>
<ol>
<li>在响应时间的限制下，系统最高的吞吐量（这里不对吞吐量做严格定义，当成是QPS或TPS即可）</li>
<li>在成功率100%的前提下，不考虑响应时间长短，系统能承受的吞吐量</li>
<li>容忍一定的失败率和慢响应，系统最高能承受的吞吐量（95%成功率，前95%的请求响应时间为xx毫秒时的最大QPS）</li>
<li>在上面的场景下还要考虑时间和资源，比如最高吞吐量持续10分钟和持续1小时是不一样的，不同的时间持续长度下，机器资源（cpu、内存、负载、句柄、线程数、IO、带宽）的占用是否合理</li>
</ol>
<h3 id="目标预估"><a href="#目标预估" class="headerlink" title="目标预估"></a>目标预估</h3><p>压测开展前是需要有目标的，也就是有期望的性能情况，希望接口或系统能达到的性能预期，没有目的的压测是浪费人力，下面给出几种目标预估的方法。</p>
<h4 id="历史监控数据"><a href="#历史监控数据" class="headerlink" title="历史监控数据"></a>历史监控数据</h4><p>已经上线并且有历史监控数据的接口，可以查看历史数据，找出峰值QPS和PCT99。🌰 若接口A已经上线并且做了监控，在经过某次大活动或者上线时间足够长后，存量监控数据就可以使用了。</p>
<h4 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h4><p>新接口或者线上未监控的接口，不存在历史数据，但存在类似功能接口的历史监控数据，可以通过类比得出压测的目标。🌰 假设上一年淘宝双十一下订单接口QPS=x，RT=y，这一年天猫平台整起来了，双十一活动与上年淘宝双十一活动场景类似，也沿用QPS=x，RT=y的目标（例子不严谨，理解即可）。</p>
<h4 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h4><p>新接口或者线上未监控的接口，不存在历史数据，且不存在类似功能接口的数据可供参数考，此时需要估算峰值，常用方法有<code>8/2原则</code>——一天内80%的请求会在20%的时间内到达。</p>
<p>top QPS = (总PV * 0.8) / (60 * 60 * 24 * 0.2)</p>
<p>RT如无特殊要求，一般采用默认值：</p>
<ul>
<li>单服务单表类，RT&lt;100ms</li>
<li>较复杂接口，RT&lt;300ms</li>
<li>大数据量或调用链较长的接口，RT&lt;1s</li>
</ul>
<p>🌰-1 电商秒杀活动，预估同时有1000w人参与，简单起见假设总QPS是1000w。由于前端不同的秒杀倒计时形式使得请求有2s的打散，再加上nginx等webserver做了20%几率拒绝请求的策略，所以下单接口总QPS = 1000w / 2 * (1 - 0.2) = 400w/s，最终压测目标为400w/s的QPS。</p>
<p>🌰-2 电商全天低价抢购活动，屠龙宝刀，点击就送，一刀99级，emmmmm跑题了。根据8/2原则，预估在午休（12-1）和晚上下班后（7-10）共4h是流量高峰，估算接口峰值QPS = 活动全天接口PV / (4*3600s)。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了前面说到的情况，肯定还有一些我们无法下手的三无接口，无参考、无预估、无历史数据，这时候只能一点一点来，慢慢把压力提上去的同时收集数据，最终得出接口的最优处理能力。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/system_performance_line.png" alt="常见性能折线图"></p>
<hr>
<h2 id="压测准备"><a href="#压测准备" class="headerlink" title="压测准备"></a>压测准备</h2><h3 id="压测场景"><a href="#压测场景" class="headerlink" title="压测场景"></a>压测场景</h3><p>压测是有目的的压测，也就是说不是随便找些接口发一通压力，而压测全部的接口也是做不到的或者说无意义的，得有压测的优先级，所以梳理压测场景是很重要的。高优场景主要有下面几个：</p>
<ol>
<li>高频业务场景（今日头条首页下拉刷新）</li>
<li>关键业务场景，使用频率低，一旦出问题就很严重（微信账号登录）</li>
<li>性能高消耗场景（淘宝下单）</li>
<li>曾经出现过问题的场景</li>
</ol>
<p>压测有分单接口压测和场景化压测，前者会简单一些，后者一般是多个接口混合操作以组成一个业务场景，两者在方法上是相通的。</p>
<p>梳理场景时QA需要与RD对齐，确认不同接口的RD负责人、需要压测的接口、系统性能现状以及压测目标；在确定每个接口的压测目标时，要考虑到压测对象是单实例单机房还是集群；在细节上也要确认是单接口压测还是场景化压测，每个接口的流量占比以及优先级，需不需要发足够的压力来触发系统的自动扩容或降级等更进一步的运维能力。</p>
<h3 id="压测环境"><a href="#压测环境" class="headerlink" title="压测环境"></a>压测环境</h3><p>在梳理完压测场景后，就要确认压测链路是否完整或符合预期。从一个服务到另一个服务，是不是链路上每一个服务都要压到？下游服务如审计安全等是不是已经考虑到？压测过程中产生的脏数据是否会影响线上数据？可能还要细化到具体下游某个服务不参与压测，如何处理呢？以上种种问题，可能需要推动整个链路相关的业务方进行对应业务改造来适配压测流量，改造完后还要自测验证才能正式开始压测，下面讲一些重点问题，部分内容引用自[文末的参考资料][全链路压测的大概思路]。</p>
<p><strong>脏数据问题</strong></p>
<ul>
<li>如果是在独立的一套环境中操作，不存在该问题</li>
<li>影子表：线上压测一般将数据写入影子表（在schema上与原数据表一致的不同名表，如user表对应影子表user_stress）而非原数据表，实现压测数据与线上数据隔离</li>
<li>白名单：指定测试id或者测试账号，在入库后通过统一id区分压测数据，统一处理</li>
<li>各类存储层的压测改造，包括缓存层、消息队列、离线数据库等隔离问题。常规方法在压测链路中<strong>透传压测标记</strong>（也叫流量染色，挺形象的），比如json数据中加<code>is_stress</code>标记，存储层根据标记区分压测流量，对压测数据添加指定前后缀再入库等特殊处理</li>
</ul>
<p><strong>不参与压测的服务如何处理</strong></p>
<ul>
<li>mock server：mock服务返回响应的时长应该遵循线上时延分布，对业务的代码实现无侵入</li>
<li>服务stub：针对压测流量做处理，类似单测stub，代码stub模拟服务返回response，需要修改代码</li>
</ul>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/pressure.png" alt="主流的业务架构压测图，引用自：https://lishoubo.github.io/2018/07/15/全链路压测的大概思路/"></p>
<p>可以独立部署一套线下环境进行压测。在不影响线上环境的前提下，确保机房，网络，存储，上下游服务与线上保持一致，部署一套独立的环境进行测试，机器与线上隔离，机器出问题不会影响线上。这种方式压测只是针对较少的几个系统进行，因为很难把整个链路所有系统都独立再部署一套，所以应用范围有限。</p>
<blockquote>
<p>备注：上游、下游如何定义？ <a href="https://tools.ietf.org/html/rfc2616#section-1.3" target="_blank" rel="noopener">RFC 2616</a></p>
<p>Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.</p>
<p>下游的输入来自于上游的输出，假设有服务A、B，A调用了B（或者说A依赖B），那B就是A的上游，A就是B的下游，因为A的输入来自于B的输出（A调用了B，获取B的输出）。</p>
<p>更简单地理解，越接近用户的东西，越是下游。</p>
</blockquote>
<p>更常见的方法是直接使用线上环境压测，在机器负载低的时间段（如深夜）人工发起或定时发起压测。</p>
<h3 id="压测监控体系"><a href="#压测监控体系" class="headerlink" title="压测监控体系"></a>压测监控体系</h3><p>确认好压测流程的技术支持和Mock数据的支持后，还要确认压测链路的监控体系是否完整，一来方便在压测过程中及时发现问题，二来是为了积攒历史压测数据，三来顺便确认监控系统本身是否可靠且全部到位。一般监控项包括（也就是压测指标）：</p>
<ul>
<li>核心接口和核心依赖的流量、响应耗时、成功率</li>
<li>消息队列、缓存、数据库</li>
<li>机器物理资源</li>
</ul>
<h3 id="压测数据"><a href="#压测数据" class="headerlink" title="压测数据"></a>压测数据</h3><p>压测数据其实没什么神秘的，网上说什么按照业务模型产出数据，表达上做了过度抽象反而不好理解，其实意思就是按照业务核心场景将所需要的数据构造出来。关键是要如何科学地模拟线上数据分布，引用<a href="https://developer.aliyun.com/article/721643" target="_blank" rel="noopener">文末参考资料</a>，阿里双十一大促中有如下的业务流量漏斗模型，需要给不同场景科学地分配流量比例，这个比例是分析出来的而不是拍脑袋的。可以想象，阿里大促的流量不可能全部最后都走到付款流程，必然很多流量会在前面的流程就结束了，也就意味着，你把全部压测数据都构造成【走到付款场景】的话，你的压测结果是不准确的。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/ali_1111.png" alt="阿里大促业务流量漏斗图"></p>
<p>为了更好模拟线上真实的用户使用场景和数据，dump线上数据用来压测是很常见的手段，有两种简单思路：</p>
<ul>
<li>直接回放提前录制的线上流量到压测链路</li>
<li>将现成流量copy一部分引流到压测链路</li>
</ul>
<p>数据dump下来是不能直接用的，一来没加压测标记会污染线上数据，二来涉及用户隐私数据。可以将线上数据作为数据源，经过采集、过滤、脱敏等操作后转变为压测数据，注意点有：</p>
<ol>
<li>确保数据已添加压测标记</li>
<li>账户数据要提前完成登录认证等准备工作</li>
<li>数据要尽可能跟真实数据保持一致，比如，价格，图片等</li>
<li>数据是否有不同设备型号等特殊要求</li>
<li>尽量保持和线上相同缓存的命中率</li>
<li>其他业务特性上的特殊要求……</li>
</ol>
<hr>
<h2 id="压测过程"><a href="#压测过程" class="headerlink" title="压测过程"></a>压测过程</h2><p>基本思路跟做质量保障是一样的，从细粒度开始慢慢集成到整个大系统，就像<code>单测-&gt;接口测试-&gt;集成测试</code>，压测也是先从简单的开始，一步一步走向全资源全链路，可以参考过程：<code>单接口单机-&gt;单接口1/4资源-&gt;场景化1/4资源-&gt;全量资源压测-&gt;拨测</code>。</p>
<h3 id="单接口单机"><a href="#单接口单机" class="headerlink" title="单接口单机"></a>单接口单机</h3><p>在单核（或物理资源少）机器上部署单个服务，排除外部链路、网络等因素，得出自身服务的单核性能情况（单位QPS/core），后续根据此单核性能指标结合压测目标值进行扩容。另外由于是压的单接口单机，无其他接口请求影响，上下游在足够资源的情况下也不会造成瓶颈，所以能确保服务的性能真实值。</p>
<p>单接口单机可以在正式开始大规模压测前提前发现问题，方便RD做针对的性能优化并快速检验优化效果。一部分问题会先在单接口单机压测环节中发现，而一些隐藏得更深的问题，需要延后到全链路大流量压测才能暴露。</p>
<h3 id="单接口1-4资源"><a href="#单接口1-4资源" class="headerlink" title="单接口1/4资源"></a>单接口1/4资源</h3><p>单接口单机压测环节，服务端已经完成了部分性能优化，接下来可以进入单接口1/4资源压测，这样是为了验证在单接口单机压测中得到的单核性能数据，在扩容1/4资源下性能是否会线性增长，是否存在性能损耗以及定位损耗源。</p>
<h3 id="场景化1-4资源"><a href="#场景化1-4资源" class="headerlink" title="场景化1/4资源"></a>场景化1/4资源</h3><p>单接口压测局限很明显，场景化压测由于引入了上下游服务的其他接口的因素，可以发现单接口压测无法发现的问题，更接近线上用户场景。</p>
<h3 id="全量资源全链路"><a href="#全量资源全链路" class="headerlink" title="全量资源全链路"></a>全量资源全链路</h3><p>全部资源到位后，预估的线上压力是否能承受，这一步也是内网压测过程的最后一步。</p>
<h3 id="拨测"><a href="#拨测" class="headerlink" title="拨测"></a>拨测</h3><p>除了做内网压测，还要进行拨测验证用户从客户端到服务端的整个带宽资源是否满足预期，内网压测已经确认了业务性能是否达标，因此拨测可以只选择了一个场景进行验证即可。（简单来说拨测相当于压测cdn，检查各地cdn节点资源是否充足）</p>
<h3 id="压测策略"><a href="#压测策略" class="headerlink" title="压测策略"></a>压测策略</h3><p>压测过程也要提前规划好，然后加入一定的人工策略调整。阿里大促还会有预热环节，预先跑一部分流量使得该缓存的数据提前缓存起来。正式压测时细分有几种压测策略，引用自<a href="https://developer.aliyun.com/article/721643" target="_blank" rel="noopener">文末参考资料</a>：</p>
<ul>
<li>峰值脉冲：流量是逐渐变大的一个小坡，还是骤升后保持高峰</li>
<li>系统摸高：关闭熔断降级限流等fallback功能，提高压力观察系统性能转折点</li>
<li>fallback策略验证：开启熔断限流等fallback功能，这些功能是否生效，系统是否还能扛得住</li>
<li>破坏性测试：主要为了验证预案的有效性，类似于容灾演练时的预案执行演练，验证后手抢救方案</li>
</ul>
<p>除了关注前面讲到的指标外，还需要关注各机房流量是否均匀（若不均匀要确认负载均衡是否work）。</p>
<hr>
<h2 id="压测收尾"><a href="#压测收尾" class="headerlink" title="压测收尾"></a>压测收尾</h2><p>发压环节的结束并不代表压测就到此为止。</p>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>如果使用了影子表，可能收尾工作会简单一些，只需要下掉影子表即可。如果数据直接落到了线上数据库，可能一大堆压测数据要清理，压测时会对数据染色（比如指定测试账号或流量携带压测标记），逐层透传，最后根据标志识别删除。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>举例一些可能会发现的典型问题：</p>
<ol>
<li>存在多余的http header，导致额外带宽占用</li>
<li>spin_lock对RT影响大，优化锁的方式</li>
<li>调整nginx worker数量可提高性能</li>
<li>不恰当的长链接数</li>
<li>代码实现上对象没有较好复用</li>
<li>cache命中率不符预期</li>
<li>业务流程上存在冗余</li>
<li>缺少一层cache</li>
<li>响应码or错误码可能要继续规范</li>
<li>下游服务资源不足（其他监控、存储）</li>
<li>内部系统对压测的限流，需要变更配置或者协商解除限制</li>
</ol>
<p>……</p>
<hr>
<h2 id="压测总结"><a href="#压测总结" class="headerlink" title="压测总结"></a>压测总结</h2><p>给出一个完整的压测过程例子：</p>
<ol>
<li>确定本次的压测目标，预估各项指标的达标值</li>
<li>根据服务接口的优先级和使用场景，确认出需要压测的接口</li>
<li>梳理压测链路上的服务，确认链路完整性</li>
<li>针对压测链路设计的服务进行压测改造</li>
<li>准备压测数据，确认压测策略</li>
<li>开始压测，监控各项指标，多轮压测检验性能优化效果</li>
<li>压测环境清理</li>
<li>压测总结报告输出</li>
</ol>
<p>压测最终应该输出一份报告总结，其实也就是把整个压测方案、过程、结论记录下来，写明压测目标、压测接口、压测数据、压测结论，给出发现的问题并提供优化方案。往往在压测报告完成时，性能问题已经基本被解决了，报告的意义在于梳理前面的整个流程，给后续的压测提供经验指导。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.toolsou.com/en/article/200293789" target="_blank" rel="noopener">performance index ：QPS,TPS, System throughput understanding</a></p>
<p><a href="https://www.dynatrace.com/news/blog/why-averages-suck-and-percentiles-are-great/" target="_blank" rel="noopener">Why Averages Suck and Percentiles are Great</a></p>
<p><a href="https://coolshell.cn/articles/17381.html" target="_blank" rel="noopener">CoolShell-性能测试怎么做</a></p>
<p><a href="https://lishoubo.github.io/2018/07/15/全链路压测的大概思路/" target="_blank" rel="noopener">全链路压测的大概思路</a></p>
<p><a href="https://developer.aliyun.com/article/721643" target="_blank" rel="noopener">独家揭秘 | 阿里怎么做双11全链路压测？</a></p>
<p><a href="https://m.huxiu.com/article/271340.html" target="_blank" rel="noopener">亲历流量尖峰时刻：一名阿里技术员工的双11十年</a></p>
<p><a href="https://reflectoring.io/upstream-downstream/" target="_blank" rel="noopener">What is Upstream and Downstream in Software Development?</a></p>
<p><a href="https://m.huxiu.com/article/270730.html" target="_blank" rel="noopener">一个阿里技术男经历的六年“双11”：技术改变阿里</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>推荐阅读</tag>
        <tag>性能测试</tag>
        <tag>压测</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>程序可测性</title>
    <url>/2019/12/06/%E7%A8%8B%E5%BA%8F%E5%8F%AF%E6%B5%8B%E6%80%A7/</url>
    <content><![CDATA[<p>什么是可测性？我的理解，可测性可以指代一个功能的测试切入点、验证点的多与寡，测试过程的简单与复杂。</p>
<p>测试切入点简单点说，就是能否更加全面地掌控数据的流转，举个例子，现有有一个类要测试，整个类</p>
<p>只给你暴露一个接口，你只能针对这一个接口给它输入验证它的输出，除此之外你无法获取更多信息，你不知道数据运算中间状态对不对、不知道过程有没有异常被错误捕捉、不知道数据有无完整落盘、不知道资源消耗是否不符预期……尤其是中间出现ABA的问题，是完全无法辨别的。这就是一个十分没有可测性的例子，是测试切入点太少，可验证性太差。</p>
<p>再举个例子，如果测试一个功能，你通过N步前置操作终于触发了这个功能，此时你还需要N步操作才能去验证这个功能是否正确，然而这个只是一个比较简单的功能，没有包含太多的复杂流程逻辑，那也是没有可测性，这是测试过程过于复杂，可操作性性低。</p>
<p>其实上面说的，都可以叫测试手段。不同的需求会导致不同的产品形态，不同的产品形态又会有不同的测试手段，测试手段的多与少就会影响可测性。</p>
<p>咱们改一下，对于一开始的那个类，如果它从只暴露单一接口改为提供多个debug接口，或者拆分功能让我们自己调用中间过程，或者提供了详细日志跟踪中间状态，可测性就有明显提高，这就是增加测试切入点；如果还是只暴露单一接口，有了自动化框架只需要简单添加配置文件就能自动灌数据验证结果，这就是降低测试过程复杂度。</p>
<p>这里列举一些增加可测性的方法：</p>
<ul>
<li>可验证性<ul>
<li>添加必要的日志</li>
<li>因输入导致变更的点就是输出，输出全部可查看（正例：中间数据的落盘）</li>
<li>提示信息可读，意义明确且唯一（反例：返回码意义不明确且多个不同错误用同一个返回码）</li>
</ul>
</li>
<li>可操作性<ul>
<li>简化测试准备和测试清理（正例：几个flag变量组合的条件判断，一键完成flag变量设置）</li>
<li>测试过程有易用的配套工具</li>
</ul>
</li>
<li>可控制性<ul>
<li>所有影响输出的因素都可控（反例：多线程死锁，难以构造死锁现场；难以构造的内部错误）</li>
<li>可直接控制中间状态的数据</li>
</ul>
</li>
<li>可分解性<ul>
<li>大系统中可以针对小模块独立测试</li>
</ul>
</li>
<li>可理解性<ul>
<li>文档明确且随时update</li>
<li>提供修改背景和影响范围</li>
</ul>
</li>
</ul>
<p>QA拿到测试需求，在了解完需求背景和功能点后，最先要明白的就是可测性，尽量在case评审之前摆平可测性低的问题，这样测试过程才流畅。所以，反过来往往需要我们在case编写时就对被测对象有清晰的了解，才知道要怎么测它，而不是模模糊糊只有个概念，或者到了评审完case真正开始测试时发现不少case因为自己不了解细节而写得不到位（必须要抛弃觉得RD会指出case遗漏的侥幸心理）。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/wangjinze_test.gif" alt="不测完我不吃饭"></p>
<p>当然可测性还有更多的拓展意义，比如文档友好、接口清晰、模块解耦、数据可控blabla，甚至可以反过来指导RD编写具备可测性的代码，存在有效的中间过程记录，复杂流程适度拆分，让功能模块之间尽量做到职责单一，某种感觉上是<strong>软件工程在QA视角的映射</strong>。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>可测性</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次e3装机心得</title>
    <url>/2019/06/11/%E8%AE%B0%E4%B8%80%E6%AC%A1e3%E8%A3%85%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小学六年级升初中的假期家里买了一台台式机，还记得主机+屏幕+外设+电脑桌整一套下来一共5700+，奔腾cpu，具体啥型号也不懂，内存1g，硬盘不足200g，完全不知道是什么独立显卡，在大学的时候50块钱除了电脑桌外整套卖给了亲戚。大一依然没有自己的电脑，拿的是表弟玩剩的三星笔记本，只记得是2g内存，拿来玩dota2都时不时掉帧，可是相对我以前的台式机来说性能已经好很多了。到了大二终于买了自己的第一台电脑——服役到现在的神舟战神K650D-i7。又是几个年头了，也给老神舟加了120g的msata的SSD和4g内存，虽然胜任日常工作，但是畅快一点的影音娱乐依然有心无力。</p>
<p>出来工作两年了，搬家也稳定下来，终于打算自己DIY一套配置出来，这是一件很让人兴奋的事情，还是说男生总是喜欢折腾乱七八糟的电子产品😂。刚开始是打算正儿八经在6.18组一个中高性能主机的，配置是 <code>r5 2600x + 微星迫击炮B450m + 迪兰rx588 2048sp + 8g*2 十铨 + 酷冷至尊550w + 大霜塔散热器 + 西数黑盘500g</code>，在JD和Tmall上看配件就好像一些人经常喜欢翻淘宝一样，一看不可收拾，有空就会拿出来看一下，彷佛马上就要买一样。后来看的资料多了，慢慢意识到二手配置性价比有多高，又接触了一些矿卡的资讯，来到了图拉丁吧，在公司内网发个帖子收二手配置还来了一位高级垃圾佬聊天，最终成功误入歧途……贪便宜的心越来越重😄，虽然没有DIY过主机，没真是踩过坑，但是却想花更少的钱来达到更高的性能。</p>
<p>于是重新审视自己的需求，其实<code>e3 1230v2</code>即可满足我的需求——写写代码轻度影视娱乐游戏，开始了我的菜鸟装机历程。</p>
<a id="more"></a>

<h2 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h2><table>
<thead>
<tr>
<th>配件</th>
<th>具体</th>
<th>价格</th>
<th>购买渠道</th>
</tr>
</thead>
<tbody><tr>
<td>cpu</td>
<td>e3-1230 v2</td>
<td>388</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>主板</td>
<td>技嘉 B75M-D2V</td>
<td>223</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>显卡</td>
<td>讯景 rx570 4g 黑狼版</td>
<td>423</td>
<td>淘宝二手（矿卡）</td>
</tr>
<tr>
<td>内存</td>
<td>金士顿 8g * 2</td>
<td>Null</td>
<td>存货</td>
</tr>
<tr>
<td>SSD</td>
<td>三星 860 EVO 250g</td>
<td>Null</td>
<td>存货</td>
</tr>
<tr>
<td>HDD</td>
<td>西数企业级硬盘 1TB 7200转</td>
<td>198</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>电源</td>
<td>酷冷至尊 gx450</td>
<td>256</td>
<td>JD全新</td>
</tr>
<tr>
<td>cpu风扇</td>
<td>九州风扇 玄冰400</td>
<td>82</td>
<td>Tmall全新</td>
</tr>
<tr>
<td>机箱</td>
<td>先马米立方</td>
<td>156</td>
<td>JD全新</td>
</tr>
<tr>
<td>机箱风扇</td>
<td>乔思伯日式plus 红光 * 3</td>
<td>50</td>
<td>闲鱼</td>
</tr>
<tr>
<td>其他</td>
<td>主板电池1粒+硬盘数据线1根+网线1根</td>
<td>4.9 + 9.9 + 7.9</td>
<td>JD全新</td>
</tr>
<tr>
<td>显示器</td>
<td>dell U2417</td>
<td>850</td>
<td>闲鱼</td>
</tr>
<tr>
<td>显示器支架</td>
<td>AOC SBX03</td>
<td>124</td>
<td>JD全新</td>
</tr>
<tr>
<td>总价</td>
<td></td>
<td>2782.7（主机1808.7）</td>
<td></td>
</tr>
</tbody></table>
<p>这个是在<code>2019.6.18</code>之前组装的机器，因为急于组装在<code>6.2</code>就下单了，当时是因为<a href="http://www.g4560.cn/" target="_blank" rel="noopener">图拉丁之家</a>推荐低价渠道，当时怕优惠一下子跑了急火攻心不等6.18就当场出了一套配置（实际上我想要的东西也不知道6.18是否真的有折扣），我自己都不敢相信我会决定的这么快，e3 cpu和b75主板这些才刚了解就不管三七二十一买买买，大家都不要学我了😂。上面的清单已经把运费和折扣都算进去了，我自己有一个cherry青轴键盘，鼠标本来也想买但是一看感觉好的要190太贵了就放弃了。如果算上二手内存和地全新低端SSD的价格，估算总花费2700左右。</p>
<p>下面就是全家福，就差电源还没到货！！！</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/all-together.jpg" alt="配置全家福"></p>
<h2 id="挑配置"><a href="#挑配置" class="headerlink" title="挑配置"></a>挑配置</h2><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>整套配置其实是围绕cpu组装起来的，不少地方的言论就是<code>e3 1230v2</code>是i7阉割核显后剩下来的东西，可谓性价比极高，我没有去考究真伪，反正我信了😄。也有不少人推荐<code>e5 2637v2</code>，最大睿频3.8GHz，淘宝不足300块，但是这玩意儿是个电老虎，耗电要电源加功率不说，发热也更强，主板价格也更高，虽说支持双路cpu（也就是一个主板上两个cpu）然而并不适合我这类入门级家用电脑，在我的应用场景来看性价比不高，最后还是选择e3邪教，参考<a href="https://ark.intel.com/content/www/us/en/ark/compare.html?productIds=75779,65732,75792" target="_blank" rel="noopener">1230v2，1620v2，2637v2对比数据</a>。</p>
<p>另外，这种古老二手cpu的价格很不稳定，<a href="http://detail.zol.com.cn/310/309339/param.shtml" target="_blank" rel="noopener">e3 1230v2 参数点这里</a>，大概是13年上市的cpu，我在6月11日看同一家店，<code>1230v2</code>的价格降了10块，从<code>¥375</code>变成<code>¥365</code>。</p>
<p>cpu是直接从福田华强东发货的，我就住在福田，后天到货之后拆开看看，作为新手的我看到cpu背面左上角针脚有几块地方是黑黑的，还以为快递运输出问题方的一b，最后上机正常点亮才松了一口气。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu-front.jpg" alt="e3 1230v2 正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu-behind.jpg" alt="cpu  e3 1230v2 背面，看到左上角针脚有黑点"></p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p><code>1230v2</code>是1155针cpu，这个U其实市面上还是比较多货的，主要是支持1155平台的主板难掏，想要便宜的主板，华南金牌这种寨板也不是不可以考虑，只是你要知道b75主板芯片组早就已经停产，要新的芯片组是不可能的，也就是说那种号称全新的寨板，是从其他拆机版上把芯片组用热风机等其他手段搞下来后拿过来装在自己的pcb板上。寨板的质量情况大家都懂，你RP好并且动手能力强，出问题可以自己给修回来，钱你就可以省下来了，如果像我这样才入门不久没怎么见过世面和<code>j（奸）s（商）</code>套路的，还是老老实实买贵一些的拆机板的吧，很多论坛平台都推荐技嘉b75，内网认识的一个垃圾佬也推这个，我也就只考虑这个板子了。</p>
<p>后来搜主板才发现技嘉b75还分好几种，有D2V、D3V、D3H……这时我犯的一个大错就是没有好好考虑他们的区别，简单看一下就拍了尺寸更小的D2V，后来装机发现机箱还有不少空间都没利用上，主板过小不仅影响美观，原件密集还会影响散热，极度后悔……</p>
<p><a href="http://detail.zol.com.cn/ProductComp_param_309878-341022-386819.html" target="_blank" rel="noopener">技嘉b75主板参数对比</a></p>
<h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><p>我买的是<code>讯景 rx570 4g 黑狼版</code>，那时就是因为看到这个显卡比较满意就把整套配置给临时配出来了。IO接口生锈黄得一b，一看就知道是矿得不能再矿的显卡（因为矿卡挖矿是不需要接屏幕的，而且环境恶劣，IO接口一直不用就很容易生锈，这是分辨矿卡的凭据之一）。之前也在图拉丁发过一帖（不知道为什么被吧务删了），被一堆老哥劝退，要不就说加几百上全新rx588，要不就退货换另一张……也没给我什么具体的建议，基本没有什么可行性，果然贴吧不好玩，帮人解决问题的帖子越来越少了。</p>
<p>显卡正面与背面，我这是第一次摸带壳显卡你信不信😄。IO接口暴露了矿卡的身份，淘宝卖家也不给擦一擦，用指甲抠或磨砂纸打磨才能去掉，而磨砂纸又会刮花挡板，干脆不管了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/graphics-card-1-1.jpg" alt="显卡正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/graphics-card-2.jpg" alt="显卡IO接口"></p>
<p>另外，都是来买amd的二手显卡，想买到普通玩家自用卡，我觉得蹲几个星期闲鱼都不一定能蹲到，可遇不可求，都这个价格了还要什么自行车。有心蹲二手配件行情得花太多时间，毕竟二手价格直接受到供求关系的影响，如果放在几个月前可能就便宜几十块。</p>
<p>也可与考虑换成rx 580 4g，8g显存太浪费了，根本用不完。我在这套配置上跑孤岛危机3，除了<code>抗锯齿x2</code>外全部都是最高特效，显存也就占用个一g两g，连4g都用不玩还买8g就过分了。孤岛危机3毕竟是13年的神作，优化应该是极好的，可能这一两年的大作对显存的需求完全不一样了吧，所以组装电脑还是要case by case，对于我，4g显存绰绰有余。</p>
<p>网上各类测评rx580性能大概比rx570高10%，差距不大，换成580多花100我觉得不值。不过580可以买到18年出厂的显卡，即使是矿卡挖矿可能也就半年多，有底气长命一点。</p>
<p>其实我也想过要不要退掉这张矿卡，因为这卖相实在让人 不舒服，打电话问客服是17年11月出厂，质保6个月早已过保，连骗一下自己都不行🤣，分分钟挖矿一年多，寿命可能已经不多了。玩十年前的游戏《死亡空间》，显卡电流声啸叫很明显。不过看在它有完整背板，简单拷机六分钟温度84°C也还能接受，娱乐大师是跑分也正常，就留下它拼拼运气了看我能用多久不坏了。虽然店主说3月保修，这些话嘛权当谎言听听就好，不要信这种二手倒腾矿卡的卖家在保修上的任何言论。还是建议大家选购二手显卡要卖家给SN码，最好查过这些信息再考虑买不买：</p>
<ol>
<li>此卡是否在保，还有多久保修？</li>
<li>如果坏了，联系不到商家，能否个人送保？</li>
<li>此卡是否有过维修历史？</li>
</ol>
<p>不过既然想买便宜卡，可能上面一个条件你都满足不了，就像我这张卡一样😄，得看你有多少耐心蹲闲鱼了。</p>
<h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>电源算好功率买就好了，网上计算整机功率的算式五花八门。二手电源选好牌子，问题不大，垃圾应该也比较好捡，我是因为第一次装机，电源估计还会一直用下去，毕竟电源才是整机最关键的地方，它出问题其他配件可能跟着就烧坏，数据无价，boom了小命都没，就选择一个全新电源，这点钱加上去我觉得还是值得的。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/naked-2.jpg" alt="裸奔尝试点亮"></p>
<p>尝试点亮机器，没加cpu风扇，在bios cpu就爆到96度，手贱摸了一下cpu顶盖，酸爽😭。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/temp.jpg" alt="BIOS界面"></p>
<h3 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h3><p>先马米立方机箱是很久以前就挑上的，没有仔细看接口参数，只看颜值，结果踩坑，前面板只能装2个120mm风扇或者1个200mm风扇，并且由于是平躺放主板的设计理所当然没有背板走线……一开始看上这个机箱是因为它可以平放主板而且3面侧透另外还相对便宜，不像一般机箱主板竖着放，我怕cpu风扇这么重会伤害主板，其实是我想多了。</p>
<p>后来知道有个<code>启航者s3</code>机箱，我喜欢小一点的机箱（MATX主板），感觉它结构良好，走线也方便，不过看到有帖子说散热不太好，我觉得应该不是问题，那么便宜的机箱你也不会去配多么高端的配置，散热够用就行。</p>
<p>觉得自己的机箱只有一个赠送的前面板200mm风扇和自己买的cpu风扇，觉得单调得要死，忍不住还是上闲鱼掏了几个带光的风扇让自己嗨一下，机箱其实也可以去掏点垃圾，分分钟附送几个风扇给你，都不用买了。</p>
<h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器在闲鱼上还是比较好掏的，我是孤身到龙岗工业区上门验收回来的ips 24寸dell屏幕，现场检测没有问题，以6折的价格把一个8.5成新的屏幕买回来，是这套配置里面我觉得比较值的一个东西😀。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>强烈安利显示器支架，找个好的牌子，然后哪款便宜买哪款就行。</p>
<p>至于硬盘，最好买个新的，存储设备买二手风险比较大，数据（小姐姐）无价，除非你像我一样存的东西一文不值，丢了也不心痛😄。</p>
<p>最后再补几张效果图。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/naked-11.jpg" alt="灵魂走线，尽力了"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/front.jpg" alt="主机正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/top.jpg" alt="主机顶部"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/left.jpg" alt="主机一侧"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>捡垃圾入门易精通难，需要花很大精力来熟悉市场价格走势和老配件的参数，这样才能有敏锐的嗅觉知道哪个垃圾捡起来更香。</p>
<p>如果要捡垃圾，先从cpu主板开始，确认自己要在哪个平台上攒配置，特别是对于小白，cpu和主板并不是都配套的，以来分平台（intel 和 amd），而来分接口类型。如果不会组装机器的，多上网搜搜一大把资料，b站的视频教程多得是，最好看两三个，这样自己就很有把握了，切记安装时不要大力出奇迹，硅胶tm不要给我涂到主板针脚上😂。</p>
<p>上面的配置，其实电源、cpu风扇、机箱这三样都能缩水一下，大概可以再省150 - 200元，我的cpu风扇和电源其实不太搭这套配置，钱稍微有点浪费了。在图拉丁吧中有类似配置的主机1000 - 1200就有人凑出来了，机会可遇不可求，便宜一去不再来😂，反正嘛，捡到便宜自己开心。</p>
<p>普通用户，选择机箱其实无所谓散热和材质，只要风道合理，结构良好和走线方便即可。特别是MATX主板以下的尺寸，这类小机箱其实无所谓高度，最重要的是长和宽，考究的是摆在桌上占不占地儿，我这个机箱就买得有点失败，又宽又长除了3面侧透没啥优点。</p>
<p>最近6.18 ddr4内存掉价特别恐怖，不少垃圾佬都在囤货了，如果你是一名像我一样的普通玩家直接忽略就好，如果你是有强烈DIY爱好，手头有两三台主机的金主，赶紧去捞便宜吧😜。</p>
<p>另外还有部分劝退心得😄：</p>
<ol>
<li>不要以为买一个多线程的cpu就觉代码跑多线程更high，你下班后根本不想再写代码，休息都来不及。</li>
<li>不要以为买了一个2000大洋的显卡就能好好玩3A大作，过了那个年纪再这样玩游戏会觉得很空虚。</li>
<li>总结：不要太高估自己的需求，特别是幻想中的需求。</li>
</ol>
<hr>
<p>上面就是我的首次装机历程，这里最后的内容是在装机大半年之后回来写的。装机完成才用了几次就开始频繁无法开机，当时初步怀疑是主板老化接触问题了，每次开机都要拆机箱插拔配件折腾，最后嫌麻烦800便宜卖了。也就当做是一次玩机经历吧，这样的操作让资深图拉丁玩家看到免不了一脸鄙夷哈哈哈哈，在此也奉劝大家捡垃圾怡情就好，不要花大把大把的钱，除非你要搞商机😝。</p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>电脑配件</tag>
        <tag>DIY</tag>
        <tag>图拉丁</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读代码小感</title>
    <url>/2019/11/24/%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%84%9F/</url>
    <content><![CDATA[<p>📚入职几周以来主要对接了两个技术需求，为了测试两个技术需求（也为了满足我的好奇心），有去看过相关的代码。第一个需求是sdk，跟头条app相对独立，所以代码看得比较舒服，第二个需求是一个二期技术需求，还得把一期的一些代码甚至头条app的一些基础lib了解一下，看得就比较广，印象浅。</p>
<p>两个需求下来，回顾自己工作以来代码写得其实不多，但是也算看过好些代码，各式各样，有粗有细，再加上网上别人总结的一些方法论，也算有点自己的心得。</p>
<p>一般理解一个程序，首先得知道这个程序是干嘛的，黑盒流程怎么跑，对于稍微规范一点的代码，main函数会大致描述程序的核心功能。规范的代码应该是通过命名自描述的，应该是一个函数只干一个事情，大流程有相对统一的入口，而不是随便抓一个函数就是功能大杂烩，又大又全包含各种i判断分支，面条式代码为什么难读，因为它尝试在一个函数里处理尽可能多的事情，也有可能是作者本身没有抓住流程逻辑的本质而妄想用条件判断来覆盖所有场景。</p>
<p>我看过最舒服的代码，是在函数前写清楚函数的流程步骤，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 啥啥</span></span><br><span class="line"><span class="string">2. 啥啥啥</span></span><br><span class="line"><span class="string">3. 啥啥啥啥</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">( )</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>像这样先把函数流程事先解释清楚，然后在一些细节上添加注释，特别是比较trick的步骤或者核心代码上。每一个代码块用两个空行隔开（而不是一个空行）。这样下去几乎都不用看具体代码，看注释就明白在干什么，快速获取我想知道的信息。</p>
<p>在大层面上明白程序的结构和设计思想后，source code的精华已经掌握一半了，之后根据需要再继续往下抓细节，一层一层往里剥，最底层便是学习别人的编码技巧、结构运用和算法思想了。<strong>忌讳不抓结构抓细节，只见树木不见森林！</strong></p>
<p>带着问题去读代码，比随意从一个入口往里跳着来读，一般效率会更高一些，可以先在已知的功能代码上寻找阅读切入点，<strong>阅读代码先一块一块地读，再一行一行地读，先读自己想读的，再读自己需要读的</strong>。</p>
<p>看代码时肯定会在一块逻辑里面同时出现好几个需要跳转继续深入阅读的地方，可以先在代码旁边打几个标记（IDE打断点就不错），提示自己读到这里，后续从跳转进去的细节出来之后起码可以快速切换回现场继续往下阅读，而不用花时间找自己先前看到了哪里。</p>
<ul>
<li><strong>【方法】</strong></li>
</ul>
<p>有一些代码阅读的<strong>方法论</strong>，知乎的帖子里有不少人提及到，比较常见的是top-down + bottom-up的结合。首先top-down由上往下一层一层记录函数调用关系，然后bottom-up把底层的函数由下往上阅读（因为越是底层的函数功能越是单一，逻辑越是清晰易辨认），在两种模式间反复切换，不断细化两种模式的理解，最后就能出现比较清晰的代码理解路径。</p>
<p>另一种方法（<a href="https://www.zhihu.com/question/21186887" target="_blank" rel="noopener">轮子哥</a>）则是基于文档出发，从文档中了解程序的背景需求后，我们可以去猜代码的实现，猜它怎么解决这个问题，这种方法需要更多的经验和更强的代码能力（反正我还不行😷）。如果没有文档，那就看测试case，因为测试case是基于文档编写的，而不是基于具体代码实现写的。</p>
<p>不得不强调，读代码是一个输入的过程，有输入就得有输出，而阅读笔记、注释就是我们的输出，读代码时做笔记很重要！笔记大大降低回忆复习成本！有时后看了这个文件回去看那个文件忘记了意义重头再看再理解一遍真的很烦！</p>
<ul>
<li><strong>【步骤】</strong></li>
</ul>
<p>如果要具体到可操作的步骤，更理想的是：</p>
<ol>
<li><p>搭建环境，将代码跑起来</p>
</li>
<li><p>利用各种手段进行调试，追踪数据流转</p>
</li>
</ol>
<p>很多时候往往第一步就无法成立，代码来到自己的本地环境跑步起来是常态，干巴巴地读确实有点朴实无华且枯燥。假设真的可以跑起来，我们可以把无关的流程代码忽略掉，尽量缩小自己需要理解的范围，减少心智负担。</p>
<p>打点调试是超级重要的事情！如果不方便断点调试，只要能跑起来，那也可以添加调试日志来对保持数据的跟踪关注。</p>
<p>如果实在跑不动代码，肯定也还有办法，一种是已经十分熟悉程序的功能和黑盒表现，然后以单个场景为基础逐步由点到面地理解代码；另外一种是将要理解的那部分代码函数给抽取出来，mock上下文数据（可以拿原程序运行时产生的真实数据）作为输入，再观察输出来理解代码。前一种方法十分契合QA的工作方式，从单点功能入手慢慢铺开理解面，因为QA对于程序的场景很熟悉，而后者适合用来分析一个复杂的函数流程，知道它的输入输出却不清楚数据的中间状态转化，就可以这样操作。</p>
<ul>
<li><strong>【工具】</strong></li>
</ul>
<p>阅读代码需要好的工具， 你拿个记事本来看代码，没人会说你强，甚至觉得你像个山顶洞人，读代码至少得有一个方便跳转的ide或者编辑器，比如Android首选android studio，vscode也比较不错。</p>
<p>ide可以帮你整理出当前符号的声明，查找符号被引用的地方，又可以列出当前源码文件中所有类、函数、成员变量，方便调试时监控变量，jetbrain全家桶公司正版是真的香😂。</p>
<p>个人不推荐为了高大上而强行去玩vim、emacs，编辑器只是效率工具，说到底哪个用得更熟手哪个就更适合，不参与无畏的编辑器圣战，有时单纯为了配置个vim就可以忘记了自己本来要干什么。</p>
<ul>
<li><strong>【意义】</strong></li>
</ul>
<p>作为QA，以阅读代码的方式辅助测试，我觉得不用执意去理解代码逻辑细节，而应该以业务场景为单位去一块一块逻辑地理解它，进行“情景分析”，我们不是来白盒找bug的，是为了提升测试效率，避免测试盲点才来读代码，为了读代码而读代码，读了一天代码结果连case都没执行完，得不偿失。</p>
<p>了解了RD的实现，很多本不理解的行为就会清晰了。比如配置下发，为什么要重启app？因为只有重启app时才有配置字段初始化赋值的流程，此时才有机会使得新配置生效；为什么清空数据重启app就crash？因为程序直接使用对象而没有进行判空或者判0长度的操作……这类黑盒有时不太好理解的原因，一看代码有时真的简单得不能再简单，恰恰很多bug也正是这种简单得犯错，越是简单人花的心思就越少，也就越容易犯错，哈哈哈我也有一样的毛病😂。</p>
<p>实践出真知，多写多看多思考，延年益寿身体好！</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>白盒</tag>
        <tag>测试</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2020总结</title>
    <url>/2021/02/13/%E6%88%91%E7%9A%842020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>2021.02.13 下笔， 2021.02.23 完成。  </p>
</blockquote>
<h1 id="前言废话"><a href="#前言废话" class="headerlink" title="前言废话"></a>前言废话</h1><p>本以为今年年终总结不会再写流水账，还是没能摆脱这个怪圈，重要的事情应该提前留下记录，这样在总结的时候就不用回忆得那么吃力。大家的年终总结都是在2020年底就完成，我故意放到春节假期期间再开始，希望给自己一个远离工作的环境和足够的时间（然后磨蹭了8天才写完），静下心不再满脑子想着如何学习、如何进步、如何成长，好客观地回顾一下2020年。</p>
<p>2020年是我的成长元年，包括工作、生活、认知。回顾2019年的自己似乎还是不谙世事，“被任务赶着走”、“只会做很明确的事情”、“没有思考和分析”就是自己当时的状态。2020年历经了角色转变，自己的责任更重，时间也稍稍宽裕了，才开始感悟人尽皆知的那么点道理，挨过打才知道痛。</p>
<p>另外开始更科学地看待自己，以客观现实的情况评估自己的水平，摒弃对自己不存在的“潜力爆发”等期望，不会再给自己规划得太多太满最终又无法实现挫败军心。</p>
<p>自己还是要多看看别人的年终总结，多学着点吧。</p>
<hr>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>2020年是我在今日头条QA团队的第二个年头，也是我工作的第四年。想不到四年会过得这么快，刚毕业时看着工作五六年的同事，还感叹年龄gap好大，终于自己身边开始成批出现98、99、00年的同事的那天也来了 _(:з」∠)_。</p>
<h2 id="工作性质"><a href="#工作性质" class="headerlink" title="工作性质"></a>工作性质</h2><p>在深圳头条的这一年多来看到很多新东西，因为本身呆过的地方少，只能跟上一份工作对比。上一份QA工作给我的最大感受是接触到了不同端的测试体验（质量保障真的说不太上）以及公司传统内部安全体系的建设。头条QA工作性质跟以前的工作区别很大，从需求、开发、测试、灰度、监控等各个环节都是全新体验。我个人认为toC与toB较为明显的区别就是toC更讲究科学的数据实验与更紧凑的节奏，因为toC分析大数据获取结论是核心手段，而toB视角中，需求可能更多收敛到部分大客户里头。</p>
<p>后半年定位成专项测试QA，深度参与到今日头条稳定性专项测试中，虽然没有做出什么有技术含量的东西，好在接触到各个方向的同学，包括业务RD、系统平台RD、测试工具平台RD、业务QA、专项QA、发布QA甚至PM&amp;DA等，可以观察在某个问题上基于他们视角提出的观点，体会每个角色在职能上的区别以及各自的优势，这些信息汇总在我的脑海中，让我对某个事情的看法更加全面，这整个过程是一个很新奇的体验。同时也能感受到自己被其他同学所需要（需要我打杂😂），某种意义看有那么一点点点点的成就感。</p>
<img src="/2021/02/13/我的2020总结/team.jpeg" width="500" height="400" title="拍得很丑的自己人">



<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>2020年年初，我刚入职头条没多久，彼时还投身在搜索评测中，从外包同学手头接来的烂摊子，主要工作是基于内部封装的 UiAutomator2 写脚本，UI层面完成一些简单的搜索场景来产出头条和竟品的搜索性能评测数据并做分析给评测结论。对于那时的我来说还很新鲜，其实任务链路不过是jenkins，调一下云真机平台api跑起脚本，到视频分帧解析，再到产出数据自动检查分析。然而，流程虽简单，实际历程却很坎坷，那段时间就是救火员，这里那里出点问题就要赶紧去看去修，因为评测数据一断就是缺一天数据，一周才多少天啊。后来各种重构修bug整个流程做稳定，依赖服务靠谱下来后，终于交接出去送了一口气。这段经历在2019年12月到2020年4月之间，以执行角色为主，首次接触数据分析，但是没有形成数据驱动的思想。那是开搜索性能周会，自己的评测结论要说给一堆从百度跳槽过去字节的搜索RD听，还跟从谷歌来的超级大佬廖宝华一起开会交流，实属紧张刺激。</p>
<p>2020年5月起投入到app端稳定性专项测试中，听起来是专项测试，实际上是解决问题缺哪补哪的笼统角色。测试工具平台不是我做的，测试链路也不是我搭的，我要做的是基于现有基础，寻求能进一步提升线下移动端稳定性测试效果（后来深化为线下移动端稳定性测试方案）的方法，包括但不限于给工具平台找出痛点和方案、完善现有测试链路和服务、梳理评价指标、推广线下测试方案等。从我一个人到现在三个人再到2021年计划扩充至6个人，我担当起app稳定性测试的owner，这看起来是循序渐进的过程，虽然我觉得依然无法胜任依有点惶恐，但整体是在慢慢适应和趋好。这里不得不感谢一手带我的<code>王小黑🌚</code>同学，从他身上学到了很多软技能，对我的成长极为有利。</p>
<p>2020年也强行做了一些规划，规划确实不是容易的事情，观察别人的规划总结出如下几个步骤：</p>
<ol>
<li>预期是什么样，vision或者愿景具像化出来，比如具备什么能力，达到什么指标</li>
<li>现状是什么样，定性定量表达出来</li>
<li>基于数据和事实分析，现状和预期对比，存在什么明确或潜藏需要解决的问题，解决后得到什么结果</li>
<li>为了解决这些问题，应该做哪些事情</li>
<li>如何度量评价这些事情完成与否，做得好还是不好</li>
</ol>
<p>上面是规划的常见套路，但是具体到每个环节中都需要大量工作量，以前我一直是执行角色，不知自己做的只是冰山一角，很多时候上头交过来的工作，ta不一定会携带清晰的背景，需要自己去询问去分析去理解，甚至可能会发现这个工作从一开始就不是在往正确的方向走。举我的真实例子：</p>
<blockquote>
<p>app的灰度质量各项指标不理想，灰度过程很坎坷，经常在灰度期间出现事故或者严重线上问题需要紧急拉人解决。以上是背景，RD和QA本能都认为是线下测试回归阶段对app的质量把控不足，测试不全，最终导致外发灰度的app质量本身就很低。</p>
<p>但是经过数据分析后发现，线上很多高优先级的稳定性问题，更多是因为灰度期间的代码合入造成的，并非是原先直觉的线下质量差，所以工作方向可能需要调整成如何把控好灰度期间代码合入的质量等其他课题。</p>
</blockquote>
<h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>随着组织架构调整，原本的专项测试小组独立成一个部门，转而面向整个大部门发挥价值。毕竟现在才十来个人，而且很多是应届生或工作小于等于2年的同学，换做是以前的我，肯定会觉得架构调整是多余的。很多职场新人可能不关注组织架构调整有什么作用，因为基层员工还是在做一样的事情，但是存在即合理，既然要调整组织架构背后肯定有相关动机，我认为主要有两点：</p>
<ul>
<li>组织对团队的定位和期望产生变化，从而做资源调配明确责任分工</li>
<li>组织层面为了资源更高效的利用，将团队合并或拆分方便精细管理</li>
</ul>
<p>第一点比有代表性的案例是调整完之后部门职责变大了，可能以前工作输出面向单独业务线，调整之后需要面向多个业务线输出，很好理解；第二点常见案例如：内部做相似但不相同平台的技术团队整合在一起，或本身具备协同串联作用的多个技术团队整合在一起，或随着团队规模越来越大承担过多职能的大团队进行拆分下发职能到不同方向的团队等。</p>
<p>说了一些不太相关的，想表达的是要多关注一下身边的环境，它的变化跟当下或未来工作密切相关，多了解这些变化背后的逻辑，会让自己对工作有更清晰的认识，是能否自我认可工作的重要因素。</p>
<p>另一方面就是带新人的体验，下半年连续做了3名新人的导师，有校招有社招。关于如何带人，这里有一段<a href="https://www.zhihu.com/question/68467783/answer/514866051" target="_blank" rel="noopener"><strong>十分好的总结</strong></a>可以借鉴。谈到我的体会，关键是：首先对齐工作理念，然后传授工作方法。听起来抽象，我自己也在一段实践中才逐渐明白过来，对于新人的培养，更多的不是重在技能磨练（可能跟岗位角色相关，这里仅指代QA），而是解决问题所需要的结构化思维、工作习惯、分析能力。编码向来不是最难的事情，最难的事情应该是找到并且定义问题，只要能明白问题是什么，那总能慢慢摸索出解法。而良好科学的工作习惯对“找到并且定义问题”有绝对的增益效果。</p>
<p>再者，什么是理念？理念就是原则，比如专项测试QA团队的职责定位就能指导日常工作开展，违背团队定位去做事情可能需要谨慎或更成熟的思考，假如这样一个原本定位是BP测试方案落地的团队，发展成另一个横向的测试能力团队，只给别人提供测试能力而不帮助别人落地，那就是违背初衷。</p>
<p>结构化思维、分析能力这些就不说了，网上多得很，关键是数据驱动、足够务实，谋定而后动避免自嗨。作为owner，要学会定目标拿结果，过程要适度跟进但是得留空间给新人发挥，保持固定的 1 on 1 沟通，自己抛问题或者让新人提问题，说出自己观察到的现象但不要说出自己的判断，引导新人思考让他顿悟获得答案，这样新人一般都成长得比较快。如果新人自身缺少积极性，则需要反思是否新人不合适做这些事情，是否要引入变化做出调整，有时候带新真的会很气人，特别是遇到恨铁不成钢的场景，这时要调整心态深呼吸清空脑袋和情绪，告诉自己不能带有色眼镜去看待新人，用行动来改变新人的问题。</p>
<img src="/2021/02/13/我的2020总结/8abs.png" width="200" height="100" title="装逼">



<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>跟不同角色的RD和QA打交道了解别人的工作和规划，接触自己视野之外的东西，是一件很有趣的事情。我工作很大占比就是协同落地，因为人力和技术问题，本身也难以独立做出足够分量的创新，所以必须寻求合作。而合作的大前提，就是要让对方认可这个事情，让对方理解这个事情的价值。</p>
<p>我遇到不少case，如果自己掌握的信息跟对方不在一条线上，对方可能不理睬，或无法建立稳固可靠的合作关系。这时要主动收集信息，需要做的可能是了解对方规划，或基于数据分析当前问题，以此判断对方有无潜在合作可能性，辅以数据说服对方。确认合作关系后，要对齐信息和目标并做好双方的任务拆解，这里有一些常规运营手段，如成立虚拟组织定期碰头各方工作进展、抛出难解问题、对齐数据信息，同样道理，定目标拿结果，各自制定一个目标并承诺交付deadline。</p>
<p>同事曾经跟我聊过，说在上家公司，一步一步把东西做出来，再到使用和推广，全程自己参与。但是来到字节，很多事情没法自己一个人做，不少资源会掌握在他人手里，要跟各方合作共建，很多时候对别人提供的能力又难以全面理解，结果是合作做出来的项目不完全是自己的，就会觉得很虚很飘，没有底气，把控力不足。这点我非常同意，公司文化不一样导致做事方式不一样，字节是一家发展极快的互联网公司，常规痛点大家都能看到，很多人都会做一部分但是做不全，当自己参与到里面来，在时间进度压力下，从头开始做未必能做得比别人好，但是共建又会依赖别人的进度和支持，是难调和的，只能靠自己发挥主人翁意识主动去把控项目方方面面。</p>
<p>大公司内部总是充斥着各种相似但不相同的轮子，就这个问题下面引用一些有分量的看法：</p>
<blockquote>
<p><strong>质量技术大佬的观点</strong>  </p>
<ol>
<li>公司的发展速度，是不等人的，业务是不等人的。以前业务小而少，所以冲突overlap少，现在变多了，形态需求和信息同步速度都不同，需要大家自己跑得更快。要么吃掉别人，要么被别人吃掉。  </li>
<li>团队内聚焦做高杠杆的事情，而非大而广的事情。  </li>
<li>共建，需要优异的框架设计，对大家的技术能力要求很高，如何成为真正的开源社区，开放平台，在系统设计之初需要提前考虑。  </li>
<li>加速re-org。  </li>
</ol>
<hr>
<p><strong>公司高层大佬的观点</strong>  </p>
<ol>
<li>需要通过overlap进行补位，而不是双方空缺导致真空。但是从公司组织角度，会根据情况加速re-org。  </li>
<li>加速，加快沟通，希望大家自治地去解决overlap的问题，加速共建。但如果真的出现大面积冲突和重叠，需要上升到leader和部门层面，放在台面上拍。  </li>
<li>阵地意识，而非领地意识。  </li>
</ol>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这一part没想好要写什么主题，但是又想加点什么，前面几部分都有提及一些点但说阐述过于简单，想在这里补充一下。</p>
<p>第一点是工作的习惯，观察过合作的RD同学，发现大家常常也是在摸索，路都是越走才会越清楚。不过RD的工作已经渐入深水区，做的东西属于新的探索倒也只能步步为营，QA侧还是有很多明确可以做的点，同时人力严重不足，所以需要更成熟的思考和分析才能下手，这就强调了前期调研&amp;数据分析的重要性，弄清楚问题在哪里才有往下进行的可能，这个步骤跟写代码时要设计先行是一个意思。</p>
<p>第二点是技术认知，写代码真的不重要，起码最低限度说，能百度谷歌搜索出来的技术都不会是核心技术，相反，隐含在技术实现背后的解决方案和思考，才是真正有价值的东西。解决方案包含发现问题、定义问题、拆解问题等核心脑力活动，这些产出依赖技术视野、工作经验、业务知识，而不是写代码写得熟练与否实现得优雅与否的层面。代码能力随着代码量的积累，总是会有正向提升，因为写代码的锻炼机会多，但是想方案需要面向具体问题和场景，同时还存在一定的压力，并且要有真实落地验证迭代的过程，这种锻炼机会明显是比写代码更稀缺的。</p>
<p>第三点是广义的换位思考，这点我做得还很差，经常会自以为然地判断某个事物（已经被王小黑多次批评了…），没有尝试切换一个视角来重新审视事物，也没有去质疑自己判断正确性客观性，最终下了一个错误的结论。需要多留个心眼，逼迫自己反复去思考，主动去质疑自己的结论，把怎么佐证这个事情、怎么做某个事情、做这个事情会遇到什么难点等问题想个明白，这样应该会有进步，只是过程肯定是痛苦的。</p>
<p>第四点是不畏难，去做真正有挑战的事情。拆开来是两句话，分别出自两个高阶同学口中，对我有很好的指导意义。因为专项测试QA人力不足，所以已经习惯了去找ROI更高并且需要QA人力更少的事情来做，于是产生挑软柿子捏的现象，本能上也会更加依赖合作方的产出，对于QA自身是缺失核心竞争力的（不过一时半会还没办法扭转现状，需要资深同学补位）。2021年，希望QA能聚焦在高杠杆的事情上，并且做出自身的创新力和不可替代性，正如大佬说的，“聚焦在高杠杆的事情，而非大而广”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工作中合作的同事有着让我敬佩的工作专业度，ta们能精准抓到痛点，给出完整体系的解决方案，并且方方面面都有考虑，很多地方值得我深入观察和学习，我会把他们当作是职场的标杆和假想敌人，努力追上他们的脚步。</p>
<p>一方面更多尝试理解别人的全套方案，包括背景、痛点、分析过程、解决方案、技术实现、效果评价、最终收益、未来展望等，花更多的时间去思考完整的事情，事情从来都是做不完的，要从事情完整的呈现来下手，Think big and act small。另一方面更积极地与别人沟通自己的想法，即使想法被毙掉也没关系，因为思考过程本身就是一个排雷的过程，无法正向找到想要的答案，也可以通过排除法逐个筛选得到最终解。</p>
<p>最后，保持好奇心，摒弃技术唯上的观念，对技术带上批判的眼光，先审视应用场景与效果，再来说具体解决方案和技术实现。</p>
<p><code>还需要感谢 王小黑🌚 同学对我的耐心指导，他是这一年来对我产生影响最大的同事兼朋友。</code>自己会经常犯蠢，好在有他在背后替我兜住一些问题，是强有力的后盾，不禁对他给出了网友的认可。</p>
<img src="/2021/02/13/我的2020总结/yes.jpg" title="网友的肯定">



<hr>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p><code>不要把自己变成一个脾气暴躁的工作受虐狂，把休息视为失败，将同行的成就视为自己的悲剧。</code>这句话出自《优秀到不能被忽视》，对自己有不小的冲击力。实际上，从前的我是有点小焦虑，我会天天惦记着学习知识吸收信息，生怕一停下来很快就会被前排优秀的同学越甩越远，同时也不愿意承认自己比别人差。这样导致了我贪多嚼不烂的行为模式，冲量第一，消化第二，有资料都拿来看一遍，看不完先摆一边放着有时间再看，理解与否不在意看过就算知道了，更不说实践和应用，也不管效率高低。最终效果可想而知，连同事都知道我是蜻蜓点水大王，事情都知道一点点，但是问深点啥也答不上。不仅如此，我还会告诉自己，自己是一个不热衷外出游玩的人，好让自己在假期宅起来多看点东西，慢慢的似乎就真的不爱出游了（大学不说，工作后也是有了女友之后才开始出去玩），实现自我麻痹的效果。在写这篇总结时，还是觉得以前的自己蛮病态的🤣。</p>
<h2 id="老家"><a href="#老家" class="headerlink" title="老家"></a>老家</h2><p>不知道为何今年觉得父母老得特别明显，老爸老妈都已经很多白头发了，网上学到别人每年会跟父母在某个固定的地方用固定的姿势拍照来记录生活，我也有了同样的念头，于是在21年春节期间一起跟我爸妈说这事，奈何爸妈跟自己的日常时间线不太一样，而且他们的配合意愿一般，最终比较仓促的拍了21年的第一张正式合照，而我倒是帮妹子和她父母给认真拍了合照。抖音的<strong>“记录美好生活”</strong>，快手的<strong>“拥抱每一种生活”</strong>，以前我是没get到这些slogan的生活意义是什么，现在忽然明白了——<code>若干年后如果年迈的父母和一把年纪的我还能有一个窥探过去岁月的小窗口，其实是一件很开心的事情。</code>用手指头算一下，一般我一年就回老家三到四次（清明祭祖、中秋团圆、春节过年必回），如果不去刻意记录时间，它真的会逐渐逝去，所以今年我开始经常拍父母的照片或视频，不过暂时局限在炒菜、祭祖、出游等特殊节目上，以后得拓展一下素材范围，可能得买一些稍稍靠谱点的装备了。</p>
<p>除父母外，我也开始关注周边的亲戚，从小到大我都没怎么留意过亲戚的生活，不懂得亲戚对自家的意义，因为知道亲戚过往的黑历史，即使在当下也总会有利益纠纷或者互相看不惯的地方，同时各家家庭情况存在差距，大家在互相交往时就会产生别样的想法。不过自从工作之后，我更愿意主动维系在我印象中较为友善的亲戚，所以今年主动让爸妈带着我去串串门，也跟长辈们聊聊天让他们了解一下深圳的情况，多拉拉家常，跟他们的小孩玩一下。</p>
<p>再一方面就是老家的朋友们，因为初中就离开小镇到寄宿学校里头去了，小镇的同龄人本就没认识多少个，所以小镇里还能玩在一起的老朋友不超过5个，而县城里认识的朋友稍稍多一些，不过能叫出来的也是屈指可数。学生时代大家约出来还是很容易的，因为各自交友圈还比较窄，而且学校生活这个共同话题讲不腻，到了毕业工作之后，大家的圈子越发分散，大家的社交性格也逐渐成型，各自找到了更亲密的朋友，慢慢地再也叫不出来了。所以啊，朋友真的不在多，关键时刻能帮上自己的朋友，有那么几个就够了。</p>
<img src="/2021/02/13/我的2020总结/2021-friends.jpeg" width="500" height="400" title="老朋友们">



<h2 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h2><p>疫情持续那么长时间，口罩戴了一年多都习惯了，但是国家在这方面把控得好，人民也努力憋着不到处跑，经历年初两个月在家办公没有私人时间的折磨后，妹子决定这个国庆跟我去四川来一次国内长游。我不得不承认自己是个土包子，这是我第一次为时这么长的主动出游。印象中，另一段长游的是在毕业前抱一个同学大腿俩人去了青海西藏，那时还是学生不愿意花钱而且时间有限，最后好像玩了七天其中有3天在火车上，花了大概2500，很多地方没体验对，倒也不后悔，当时自己想感受的也感受到了（最傻逼的是自个儿在拉萨大昭寺的“全民健身体彩公园”里做单双杠锻炼，好体验高原地区是怎么流失体力的🤣）。</p>
<p>说会国庆出游这一次，我是大菜狗一条，妹子也不是积极做旅游计划的那类人，所以理所当然选择跟团啦（还认识了不错的导游小姐姐）。旅游确实是一个掏钱吃苦的事情，跟团那些天基本都是早起晚归，不过那时候我还在玩王者荣耀，白天到处玩累了，晚上回去旅馆如果有时间打上一两局，也觉得很享受。</p>
<p>去的是四川，从成都出发，路线是<code>都江堰-&gt;九寨沟-&gt;黄龙-&gt;峨眉山-&gt;乐山</code>。都江堰由于现场混乱没听到导游介绍所以基本无感，就是只能感受到水哗啦啦地流但不明白有什么工程技术含量这样。九寨沟第一次看到真的很兴奋，不知道是我去的时间不对还是咋地，反正没网图那么好看，网图色彩饱和度高，颜色都快要流出来的样子，我当时没有感受到。在黄龙是我和妹子俩广东人首次亲手摸到雪❄️的地方，上山前专门有人上车推销所谓抗高原反应的功能饮料，100块一瓶，因为她说得很可怕谁谁谁因为高反没了性命什么的，主要是怕妹子出问题我选择交了这个智商税，后来发现真的是没必要买，对正常体质的人群来说只要不在高海拔地区作死（剧烈运动蹦蹦跳跳）最多就是喘一些体力差一些而已。峨眉山感受到当地恶霸猴子的嚣张气焰，还在万年寺里悄悄地帮咱俩家人给做了价值1200元的功德🤣（我承认有点头脑过热），运气很好到了峨眉山金顶天气很棒。乐山没多少东西可看，算是跟团旅途最后休闲娱乐的三个来小时。</p>
<img src="/2021/02/13/我的2020总结/me.jpeg" width="500" height="400" title="峨眉山金顶，穿着羽绒服的我">



<p>跟团前后在成都玩了一些时间，成都的绿化惊艳到我了，好多楼顶都种上了花草，空间利用得很好啊，我们只在锦江区一带活动，那里的发达程度蛮高，吃了宽窄巷子里不好吃还贵的东西，吃了蜀大侠火锅，吃了导游推荐的情妹妹干锅锅，看了芙蓉国粹（听说蜀风雅韵更好），在酒店里叫了深圳窑鸡外卖，喝了书亦烧仙草😂，整体对成都的印象很好，尤其是在我知道成都房价后，跟深圳一对比简直眼泪掉下来。如果我毕业就在成都工作，我肯定会选择定居在成都。在这一趟出游前，给妹子过生日咱买了个二手微单瞎玩弄起来，也正好带过来旅游到处拍，一下子就是两三百张照片😂。虽然拍得水平很低，不过也留下了属于我们的出游记忆。</p>
<p>另一个让人兴奋的事情是妹子晋升了（emmmmm妹子不是程序员也不在互联网公司）☺️，对她的职业生涯来说是一次突破。妹子的工作领域是越老越吃香的那种，不像程序员那样疯狂内卷吃年龄红利，但是她的工作最大缺点就是强度高，比我还高，加起班来比我还狠，而且周末还经常被人找，周末可以从早上十点多一直加班到晚上七八点……得亏她的上司比较好。希望她在团队中能发挥更大的作用，工作时间松弛有度，也希望我自身的职场经验能够帮助到她。</p>
<img src="/2021/02/13/我的2020总结/girl-friend.jpeg" width="500" height="400" title="在老家跟朋友们野餐，被我打码的妹子">



<h2 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h2><p>2019年的年终总结中这部分标题还叫【健身】，今年就改成【身体】了，get到区别了吗？😂</p>
<p>自2019年7月做了肩部手术，健身就开始抛到脑后，时至今日，感觉动刀子的地方还没痊愈。2020年一年下来，体重净增接近10斤，我真是A你B个CDE🙄。疫情前虽然也是干到差不多10点才有时间去一下公司健身房，但起码不强制关门我可以锻炼到晚一点，疫情后公司严格卡10点健身房关门赶人走，原本就没什么时间去健身，制度还要再加上限制，最终我一周也就只能去个一两次健身房，每次快速练上个15分钟，即使work out组间休息很短但强度还是上不来。结果是啥？结果是我获得了这样的体重，要是我买的基金能这样涨就好，低风险高回报🙄。</p>
<img src="/2021/02/13/我的2020总结/my_weight.jpeg" width="300" height="200" title="无解的体重">



<p>跟公司健身房的教练也熟了起来，教练观察了我的锻炼过程说：“其他同学即使瞎练，但好在负荷轻所以不会受伤，但是你做的负荷高重量大，动作还不标准，你很危险啊”……被教练这样点一下，我开始留意动作标准程度和受伤风险，因为从初中开始就健身（少说健龄10年），自我感觉良好，所以总会急功近利想快点回到以前的身体水平，尽可能冲重量而不顾质量。尤其是最近左手手肘做引体向上后会痛（停训两周不痛后再练还是会痛），更加让我关注起自身安全。肩膀废过，又有点潜在伤病，实在是不敢继续用这种关节肌腱受伤风险高的方式练下去了。除了肌肉掉肥肉增，今年身体素质直观上也差了，以前一直保持健身续命，今年随着工作强度上涨，锻炼时间被无限压缩，锻炼强度根本不够，熬夜的负面效果越发明显。学生时代即便搞到2点多睡，第二天早点起来除了睏就跟没事一样，现在要是连续2天都2点多睡，隔天上班头绝逼会疼……</p>
<p>2021年得好好利用一下出租屋旁边的体育公园，让人蛋疼的是作为一个体育公园它竟然没有单双杠……</p>
<p>以前热衷街健，在单双杠上使劲练，但忽视了一个基本点：靠身体自重是不够的，想要稳定且高效的力量增长就要添加额外负重。后来肩膀练伤了，最近手肘也有受伤风险，暂时又回去安全地撸铁了。（过年在家老爸给我擦没长毛的小老鼠泡出来的药酒，那药酒的样子估计很多女生受不了🤕）</p>
<p>这让我思考起两者的区别，街健炫酷，它讲究身体的综合力量以及肌肉把控度，对场地和环境要求低，但是一上来就是自重训练，难度陡峭，门槛高，成长速度慢；撸铁往往是不同肌肉独立做功，各练各的，在仪器的帮助下很快能掌握窍门走上轨道，受伤风险小一些，但是对场地有要求。这么一衡量，我似乎更加喜欢两者结合，做个两栖选手才有自己的特点o(<em>￣︶￣</em>)o。有简单看过cross-fit的视频，也是很酷的一门锻炼艺术，可惜场地要求高，我手比较小，四肢也短 凸(艹皿艹 )，挺举动作似乎无法完成。</p>
<p>参考<a href="https://www.zhihu.com/question/49611095" target="_blank" rel="noopener">这个帖子</a>制定了今年的身体目标，以自重75kg算，要让自己达到中级水平：</p>
<ul>
<li>卧推：70+kg？ -&gt; 95kg</li>
<li>深蹲：80kg？ -&gt; 115kg（传统弱项，练的时候很喘很难受，软脚虾😂）</li>
<li>硬拉：120+kg -&gt; 150kg</li>
</ul>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>2020年全年完整读完的书共6本，实在没什么内容可以展开，就水一下这几本书吧：</p>
<ol>
<li>《<a href="https://book.douban.com/subject/26951247/" target="_blank" rel="noopener">测试架构师修炼之道</a>》：被书名吸引了，翻开一看内容太片面也太理论化，没有大公司该有的全局视野，这个架构师是假的吧</li>
<li>《<a href="https://book.douban.com/subject/27070239/" target="_blank" rel="noopener">停止盲目努力</a>》：鸡血书，案例比较极端，咨询者的主观能动性较差，可参考意义小</li>
<li>《<a href="https://book.douban.com/subject/30396635/" target="_blank" rel="noopener">这就是OKR</a>》：实际企业实践案例为主，但感觉没总结到OKR的本质与核心</li>
<li>《<a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">算法图解</a>》：算法入门书籍，只适合入门或快速复习</li>
<li>《<a href="https://book.douban.com/subject/26781120/" target="_blank" rel="noopener">优秀到不能被忽视</a>》：工作和自我提升的方法论为主，一本好书，需要仔细消化并应用</li>
<li>《<a href="https://book.douban.com/subject/10789820/" target="_blank" rel="noopener">Node.js开发指南</a>》：作者非常牛逼，但是书的内容已经严重过时（Express 2.x版本），不建议看</li>
</ol>
<p>要是回顾这一年的阅读情况，时间是最显著的问题。19年及以前，我还有机会在工作日下班之后认真看一会书，但是现在经常10点多下班，回到家里就接近11点了，有时候坐下来玩玩手机，简单做些锻炼，洗完澡出来11点半一点也不奇怪。这时总会有一种<code>干啥都时间不够，干啥都要因为到点睡觉而中断</code>的烦躁感，于是都会选择去做一些更散碎的事情，比如看看文档，写写碎片化的代码等，总结起来就是因为时间不足故意逃避高强度的脑力活动，去选择更轻松的事情。这是一个致命问题，无法在专业领域中投入足够的时间和强度，就无法沉淀出有高度的东西。跟RD交流知道别人业余三个月就能读完一本CSAPP，还是自驱问题。</p>
<p>那我是不是就没有其他阅读呢？也不全是，上班地铁通勤25分钟，步行15分钟，我还是会利用一下地铁时间看点东西，之前用kindle在地铁中看书（上面有3本就是这样看完的），后来也试过在地铁中看纸质书《<a href="https://book.douban.com/subject/26832468/" target="_blank" rel="noopener">Go语言学习笔记 </a>》，但是效果不好，因为书本传递的知识本身是结构体系化的，用碎片的时间去理解体系的东西，我很难消化，而且手边没有电脑，又缺失了一个实践环节，效果再打折扣。最后我选择在地铁里看文章，这里安利工具app<a href="https://qingmang.me/app/" target="_blank" rel="noopener">轻芒杂志</a>，它是一个<strong>现代化的RSS订阅器</strong>，可以订阅公众号以及网站RSS，可惜目前只有移动端没有PC端，不然我肯定装一个在电脑上。微信公众号不乏优质内容，但是公众号本身的特点就是知识碎片化，很多时候技术文章是基于某个具体问题开展的，这样传达的知识很明确，但也丧失了很多拓展空间，对比之下我还是更喜欢看个人技术博客网站。</p>
<p>阅读归阅读，看进去了但不一定入脑，一本书看是看完了，但是过了一些时间只能留下点影子，技术书籍更是如此。2021年在阅读上最大的任务不再是读多少本书，而是学会如何读书，《<a href="https://book.douban.com/subject/1013208/" target="_blank" rel="noopener">如何阅读一本书</a>》必须得好好研究，先研究怎么把书读薄再说读厚的事情。为此也做了简单的铺垫，买了iPad上的 MigratNote3 和 GoodNotes5 这两个app来当成学习阅读工具，估计够用了，接下来就是逼迫自己去学习阅读并做总结分析，慢慢成为技能，最后形成习惯。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>2020年的生活多了一分姿彩，对一些事物有了新的看法，或许以前的自己真的太稚嫩，没有留意身边发生的有趣事情，也没有去尝试理解，所以就会活得没心没肺，自以为潇洒自在。成年人的世界确实不容易，但是也很有趣，交心朋友还是那么些，跟妹子慢慢到了谈婚论嫁的年纪，天天嚷着要减肥好拍结婚照但还是快乐地吃喝，虽然留有一些遗憾，但不足以使我后悔。</p>
<p>有时会感叹人的一天只有24小时不太够用，人越是活着就越是能感受到活着的滋味，可能是这一年我变老了，怀旧情绪竟然上来了，做的一些事情就是为了寻找童年回忆，那时就能感受到岁月变迁，人在的话物已经不在了，物在的话人或许联系不上了。希望未来大家能聚在一起再度诉说当年往事吧。</p>
<hr>
<h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><p>有一些东西归类到工作或者生活都不太合适，这里再整一个分类来放吧，以只言片语的感悟居多，<strong>有时写文章不是给别人看，只是在跟自己对话的过程中就找到了答案</strong>。有时自己面对一些难题无法解决或者想不出答案，可能文字记录过程中就能悟出关键点，还不行，等以后解决了问题再回头看，回顾自己是怎么越过这个坎，也蛮有意思的。</p>
<h2 id="岗位认知"><a href="#岗位认知" class="headerlink" title="岗位认知"></a>岗位认知</h2><p>相信读者肯定参与过大大小小由高层组织的全体会议，高层在会上就一些问题发表看法，其实这是很有营养的内容，但不一定适合不同阶段的人吸收消化（在大佬发言时你有认真听的请扣1🌚）。对于刚毕业迈入社会的QA同学（实习也算）其实会对QA岗位有很多疑惑，我也是这样“迷茫”过来的，答案会散布在大佬的发言中，恰恰是新人最容易忽略，最容易当耳边风的话。以下是内部质量技术大佬的观点，新人QA渴望明白的或许是下面这些问题吧：</p>
<blockquote>
<ul>
<li><p>测试等于QA吗？QA等于质量吗？</p>
<p>这个等式肯定是不成立的，质量涵盖了QA的一部分工作，QA也涵盖了测试的一部分工作，测试只是非常小的一部分测试执行动作。QA本身还要做很多事情，包括从需求到发布，质量其实是内建在整个项目迭代过程当中，它并不只是QA的一个职能，或者是RD的一个职能，或者是产品的一个职能。</p>
</li>
</ul>
<ul>
<li><p>QA的价值究竟如何体现？</p>
<p>QA的价值体现在对整个项目中“问题的洞察”。如果用一个比喻说明，优质的质量保障工作应该是一个像八爪鱼一样的东西，触角可以伸到项目的每一个环节，感知每一个环节可能发生的问题，并且能够通过这些问题去驱动项目解决问题。</p>
</li>
</ul>
<ul>
<li><p>个人能力重要，还是质量意识更重要？</p>
<p>觉得两个要结合，才能保证项目质量。当团队规模比较小，也就是20人左右的时候，需要成员在个人能力和质量意识上非常出色。等团队规模越来越大，注入了能力和质量意识更强的新血液后，其实工具跟流程就显得很重要了。你需要在大的团队协同状态下，协同工作。当然，我们不可能抹灭大团队下个人能力跟质量意识的一些作用，但更需要通过工具平台去约束一些东西，达到协同合作的状态，快速交付任务。</p>
</li>
</ul>
<ul>
<li><p>遇到研发团队配合不理想，应该如何推进QA流程？</p>
<p>配合度不高，很多时候是因为这个工具流程不好用。再一个就是，你提出的配合对其他人来说是有侵入性的。如果我是开发，你让我去提交代码的时候还得关联一下bug，我就不愿意配合。怎么解决这个问题呢？实现“提交代码就自动关联bug”，配合度会大幅度提升。</p>
</li>
</ul>
<ul>
<li><p>新人入职之后，如何解决“我要干啥”的疑惑？</p>
<p>其实最关键的一个点在于现状的梳理。现在业务到底发展到什么阶段？现在完成了哪些工作，没有哪些？这个可能听起来非常笼统。思路可以是看需求阶段现在到底发生了什么？然后研发阶段到底发生了什么？测试阶段发生了什么，然后发布阶段到底发生了什么？解决每一个阶段，要解决哪些问题，需要一个什么样的团队，这是我当时思考的一个关键的思路。敢想敢做！（大佬的回答，删减了大量敏感信息）</p>
</li>
</ul>
<ul>
<li><p>我的开发能力不足以支撑我做RD，是不是还能做测试工具平台的QA（测开）？</p>
<p>部分同学更擅长业务测试，部分同学更擅长工具平台开发。但是不要把业务测试当成简单的功能测试，测试广度、深度、可测性理解起来，不比理解业务系统代码架构简单；也不要把工具平台开发变成退而求其次的选项，“我做不了业务研发，也不想做业务测试，还是开发点平台攒攒经验”，好用的平台工具，能带来巨大的业务价值，也需要人才本身强大的技术架构能力，但是半吊子的平台不但带不来业务价值，反而给团队和个人减分。</p>
</li>
</ul>
<ul>
<li><p>QA如何进行技术成长？</p>
<p>针对业务测试技术本身，深度是必须的，核心原理、架构设计、设计模式、语言基础是必须的；业务的技术本身，抓关键点做取舍。</p>
<p>测试技术：对于这个维度，毋庸置疑，希望投入精力做，就把这个事情做到彻底。还是拿我经常举例的自动化来讲，行业的自动化测试是真的QA必备的技能，但是有几个真正意义上理解自动化的框架原理、封装逻辑？摆着手指头都能数得出来。出现这个问题的原因是对自动化价值本身的定位本末倒置。做自动化，是为了更好更快的发现问题，那就需要稳定的框架和用例，这一点，是对写自动化的QA有极高的能力要求的。从driver到元素封装到PO封装到组合操作再到断言再到重试和日志服务，这里面用到了非常多的技术细节。如果这些细节没有把握，那自动化这件事情是做不好的。围绕测试技术本身的深入理解，是必须投入精力做的。</p>
<p>业务技术：对于这个维度，需要做一定的取舍。为什么这么说呢？因为大部分QA参与的项目，不太可能仅涉及一种技术栈，比如测试视频功能，可能需要了解安卓渲染模型、视频编解码、CDN、存储转码等等，这个背后可能还涉及非常多的基础设施（包括web框架、容器、存储、网络传输等）。但是回到研发角度，他可能关心一到两个点就可以完成日常的研发任务，所以取舍是必须的。但是一个比较重要的点是，必须把关键技术掌握清楚，还是以视频为例，安卓的surfaceview是怎么渲染的，客户端编解码的基本原理， 主要的视频数据下发结构，后端web框架，CDN存储拓补结构，转码存储的原理（核心是队列和重点转码逻辑），以及视频的主要后端存储结构的理解。这些关键点是必须在业务测试过程中逐步花时间弄清楚的。</p>
</li>
</ul>
</blockquote>
<img src="/2021/02/13/我的2020总结/QA.png" title="QA">



<p>QA岗位在不同公司的含义不一样，一会是测试工具平台的开发（测开），一会是常规业务测试的测试人员。对于QA的定位经常没有公开清晰的阐述，而且不同团队中的QA工作含金量有很大区别，是无法避免的。在我的理解中，QA是质量保障的角色，Quality Assurance，应该聚焦在<strong>“质量保障”</strong>这个词上。质量保障的含义极其丰富，基于产品体量&amp;团队规模，在不同阶段质量保障会有不同的手段和优先级。</p>
<p>现在多数人对QA岗位的认知，不对，是对测试岗位的认知普遍是觉得没技术含量，Web端或者移动端统一称呼点点点。在我看来，这是测试岗位门槛低、测试培训班泛滥、测试同学在技术进取上积极性弱共同导致的错误认知。QA岗位的核心竞争力是什么呢？可以先看这个岗位是怎么来的，首先“测试”这个动作本身是在产品研发过程中自然产生的，RD写完代码肯定得测试通过才能交付，但是随着团队变大，开始对生产效率有更高要求，随之而来是分工细化，那么“测试”角色就诞生了。产生这个角色时，一方面是职能转移，更全面可靠的测试工作交由“测试”角色来完成，另一方面也产生了新角色的核心竞争力，就是利用技术手段来做好质量保障使得产能效率更高。需要搞明白这一点，我们做QA，如果是单纯成为“职能转移”的下游角色，必然会被鄙视为没有技术含量，因为测试门槛真的很低，不学习各类开发专业知识不需要技术也能测试，但最多也就单个产品测到六七十分，但如果提供的是测试能力，让大家（包括RD）更高效地测试，我们的角色价值和核心竞争力就产生了。这里已经不是前后端测试，也不是工具平台开发的问题了，而是比拼技术架构、业务场景、典型问题的理解思考深度。</p>
<p>各种大厂亿级DAU的产品，RD和QA其实都忙于业务迭代，人力不足时必然是优先保业务增长而不是质量，随着人员补齐会开始加大在质量上的建设。具体到QA团队中，大家都知道要做测试工具做测试平台做自动化，但是人力严重不足，无暇顾及长远效率和收益，来一个需求最自然想到的还是手工测试。</p>
<p>那为什么说手工测试不靠谱？因为手工测试是靠人，人的能力本身就有差别，不同的人测试效果不一样，今天ta来测质量没问题，明天换一个ta来测还能否保证质量过关？同时，人是会失误的，面对重复机械的劳动人总会出现漏洞。综上，最终产品的质量就会参差不齐，哪个产品的QA能力好一些，哪个产品质量就好。从这个角度看，QA技术产出的本质就是将优秀QA的测试经验转化为固定的工具平台，从而抹平不同技能水平的QA对产品质量的影响，大范围传播优秀质量。QA很多时候更像一种可移动的资源（你会发现很多大厂QA跟业务是不在一个部门下的），不一定是闭环在产品里，哪里需要QA就调配过去支持，<code>从这个角度来思考，QA团队的终极目标或许就是通过技术产出来沉淀优秀测试经验（这里的经验一定是基于实际业务沉淀的，甚至走在业务前面），使得产品质量成为一种可以快速复制的东西，其中流程化、平台化、服务化是核心发力点。</code>这只是一个终极目标，实际情况下面对的问题，也许转化为<strong>如何在有限的人力或时间下，做到更好更快的质量保障，尽可能降低产品的质量风险</strong>。有些事情做到60分也可以，但是在同样的条件下如果能做到70分或者80分，那就是额外的价值。当内部把这些事情都做满了，技术产出甚至还可以对外开放，考虑商业化的toB，从成本中心转化为利润中心。</p>
<p>现在常规业务测试岗位已经越来越外包化，需求本身的质量仅仅是单点问题，靠人力保得了这个需求不一定能保下个需求，而手工测试的工作交由熟练的外包完成，解放正式QA的精力来分析问题做深度建设，这是业界越来越普遍的做法，所以长远来看，国内大厂QA的门槛会不停提高，测试外包的规模也会越来越大（外包也会越来越专业），测试平台也会越做越强，世界顶尖的Google、Facebook很多团队就是这样的模式运作，国内市场肯定也会成熟起来（大家都说使劲内卷，我觉得倒还好，内卷归内卷，但确实会使得优胜劣汰提高行业门槛促进行业“改革”）。</p>
<p>再来说一下测开角色（测试工具、平台的开发岗），他们一般在单独的工具平台团队，不在具体业务团队之中，这是能力中台化必然的过程，同时也出现信息gap的问题。谁都想开发工具平台秀技术，开发出来的工具平台是否真的对业务线有用，是否真的对生产效率有正面意义？技术人员很容易产生技术唯上的观念，因为技术圈就讲究技术认同感，“看一个人技术好不好就得看他的代码”等类似的观念满天飞可见一斑。所以测开角色在很多人眼中是一个香饽饽，既避开业务压力，又有一定技术造诣，看起来对技术生涯发展有利。不过我观察到的现象是，在体量大业务迭代迅速的产品里，测试能力不是天花板，反而是业务团队的问题消费能力。工具团队在那里一个劲地造工具想要发现更多问题，<code>潜在矛盾是落地了工具平台发现问题了后，他们却不对问题是否具备修复价值负责</code>，分析问题的压力会落到业务团队。这样就出现很明显的角色对立，一边是工具团队铆足劲造工具提更多的问题，一方面业务团队看到众多问题产生心智负担的同时对工具越来越麻痹（因为发现很多问题线上不出现就觉得没必要花精力解决，直接当成无效问题）。</p>
<p>很多时候，鲜有人能站出来审视这一痛点。</p>
<p>说实话，以前我很想成为工具团队的一员，觉得对自己的职业生涯更有帮助，甚至旁敲侧击看能否拿到源码来研究，或者有活一起分工合作好学习学习，后来当他们真的来找我“分工合作”了，要不就是技术含量的工作还是在他们手上，只是把脏活累活分过来，要不就是做的事情对于我们性价比太低投人不值。虽然最后做成了也是功劳平分，但审视后如果发现收益对己方不大，那就应该像前面我说的那样，含金量低、不用动脑的工作，能不干就不干，避免成为别人的工具人，认清问题做好判断。另外，有些事情QA和工具平台团队都能做，但是他们具备技术和人力的双重优势，就会出现经典的抢活干现象，蚕食对方工作空间，现在不是要跟你谈合作，而是要吃掉你。虽然带着这样的恶意去看待人家是不好的，但是不得不留个心眼，<code>诉求可以细聊，方案可以一起探讨，事情也可以合作共建，但是QA一定得清楚要解决什么问题，是在解决“他们的问题”，还是在解决业务真正需要解决的问题</code>。</p>
<p>说到底，要做什么才能提高测试研发效率提高产品质量和体验？这些真的是很难的问题，QA在思考，RD也在思考，产品负责人也在思考。</p>
<p>最后一点就是要对部门团队有足够的耐心。看过内部2021年质量保障规划，其中总结了QA团队从2019到2020年的阶段性变化，对我很有启发：</p>
<blockquote>
<ol>
<li>业务勉强支撑阶段<ol>
<li>QA人力严重不足</li>
<li>质量保障手段单一</li>
<li>测试有效性偏低</li>
</ol>
</li>
<li>头部问题治理&amp;质量体系初建阶段<ol>
<li>业务原因引发严重事故下降和收敛</li>
<li>核心场景质量保障手段丰富</li>
<li>版本Delay得到大幅改善</li>
</ol>
</li>
<li>全面开展平台化建设阶段<ol>
<li>……</li>
</ol>
</li>
</ol>
</blockquote>
<p>上面单纯这样列罗列看不出多少感觉，这些点只是结论，后续展开说明才是精彩的部分。在这里我想表达的是，每一个团队都有它自己一步一个脚印的历程，有的团队顶着光环招人速度爆表，也有的团队持续缓慢吸纳新成员，各自有各自的节奏，自己需要给予更多的耐心，跟随团队一起成长，学会用长远眼光来判断团队的好坏，更多还是从文化、价值观、做事方式、规划来评判，可能自己在前期（半年到一年不等）的工作含金量偏低，随着团队成长人也会水涨船高，工作方向持续深化，这时你已经跟同事和上级建立了良好互信关系，反而更容易争取自己想要的工作。</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>业余方面，以前跟同事聊过，自己研究技术专注度最高的应该是在毕业前夕搞毕业论文的时候了，那时候啃《<a href="https://book.douban.com/subject/3735649/" target="_blank" rel="noopener">Orange’S:一个操作系统的实现</a>》真的是高度专注，以后再也没试过计算机方面这样强度的脑力理解了。在自己快餐式学习的模式下，本身就没法达到这样的理解强度，于是今年年底尝试了另一种方式，也是最正常最基本的模式：一边做一边学，问题驱动的学习。（某个时期试过刷leetcode，但算法题离实际工作还是有距离，不适合我现在去投入时间）</p>
<p>本来是期望在工作的三人小组内部以技术课题的形式激发一些技术讨论的浪花，前期确实达到了效果，但是到后期讨论得差不多要开始着手花业余时间来实现了就会出现问题，毕竟不是每个人都愿意使用本就没多少的私人时间泡在代码中，同时这种来自于工作场景的东西给别人的感觉更加像是任务而不是兴趣小组，最终事情黄了，那就我自己来搞呗，于是从11月底开始一直用业余时间磨蹭，懒惰导致进度龟速。讨论的技术话题真的很浅《微信朋友圈后端的简单实现》，为了跟工作扯上关系，用Go基于Gin框架来实现，遇到很多自己没想过的问题。技术难度其实很低，毕竟没有写商业级代码的基础和觉悟，代码实现就是纯粹没难度的堆逻辑，需要的是时间而已。对于我这种疏于编码的人来说，真正的难度在于如何保证代码量增长的同时使得代码理解成本控制在一定范围或者控制成线性增长，具体就是一堆编码规范。让我认识到技术是分维度的，有的是创新思路做得很黑科技，有的是旧方法做到极致一样屌，有的是规范良好落地工程效果强（好啦好啦，你们一定嫌弃我很菜，给点时间我追一下嘛🌚）。</p>
<p>这个玩具项目就是常规应届生水平而已，但是对我的意义比较大，现在还在做，希望2月能完工，到时候又能水一篇博客并开始下一段旅途了，链接是<a href="https://github.com/Zingphoy/Moments" target="_blank" rel="noopener">微信朋友圈后端简单实现</a>。下面这张图对我有些纪念意义，其实我从来不在github上提交代码，一方面是自己疏于撸码，另一方面一直都没意识到github它是个宝藏，以前注册的github账号只是一个摆设，后来知道github page可以做博客就权当成是静态博客来用，现在终于算真正用起来了，开始像一个常规程序员了，从此心头多了一片绿油油的心愿。</p>
<img src="/2021/02/13/我的2020总结/my_github.png" title="gayhub提交历史">



<p>工作方面，技术的广度上有了一定的拓展，内部不缺高大上的技术方案，出自资深甚至工作过十年的技术大佬。因为工作需要我走的是移动端路线，有机会窥视到今日头条RD为了极致性能以及稳定性做的一系列工作，虽然还没很好消化（也很难消化，移动端基础太弱），但是足够我在2021年吃得很饱了。</p>
<p><strong>“离开了业务，技术就没有价值”</strong>，这一年理解了这一句话。以前是有点技术唯上，觉得别人做的东西好牛逼，用的技术很尖端新锐，就会看好它。这一年来见过太多自顾自做技术方案，最终难以落地业务产生价值的案例，有些时候业务团队同学说天天写业务没技术，但其实工具平台的同学也提心吊胆怕做出来的东西没人用，当然，一般在工具平台团队中，不杠业务压力，技术性质和时间确实会多一些。</p>
<p>今年开启了更多渠道用于收集信息和知识，以前局限于搜索引擎&amp;工作接触的资料，现在开始稍稍留意Twitter、Github、Hacker News、Reddit等一手消息。关注学术界，关注头部企业，关注尖端技术，这反过来需要一个高效的信息渠道与聚合机制，希望未来养成习惯，给自己的脑袋注入多元的新事物，让它们混合爆炸💥。</p>
<p>蹭公司经费参与<a href="https://www.bagevent.com/event/6699721?bag_track=th_top_topic" target="_blank" rel="noopener">深圳MTSC 2020年</a>，这类带点商业性质的行业大会是秀肌肉第一，挖人第二，很多议题其实是新瓶装旧酒，只是大家做的程度不一样，真正的技术大会还是要看世界级的行业大会，不过在MTSC上还是看到了不少自己没见过的方案如单测生成，甚是有趣。</p>
<p>下面这一张图对我来说冲击力很大，这张图很久以前（两年多三年吧）就在某篇公众号文章中看到，当时不知道为什么顺手就把那篇文章收藏了，后来翻看的时候觉得这张图挺有道理，就下载到手机中。那会儿还没意识到这张图说的真理就是那么简单，简单得让人不以为意，然而往往大道理大智慧就是蕴含在最简单的东西上，我自己总是要经历过吃过教训才能理解，今年我自己就经历了一个碎片知识到体系化结构化知识的小过程，当自己停下来把以前知道的东西重新梳理汇总一遍之后，猛地发现从前一直不理解的东西就这么串起来，显得十分理所当然了！知识总是需要一个总-分-总的学习过程！</p>
<ul>
<li>总：首先学习知识脉络，知道整个知识体系中大概哪些节点，每个节点大概承担什么作用</li>
<li>分：如果可以的话基于问题和实践驱动的学习效率会更高，挑选单个节点逐个学习理解</li>
<li>总：单个节点已经理解完毕，此时不依靠外力帮助，独立重新把节点串联在一起，着重观察节点之间的联系和相互作用</li>
</ul>
<img src="/2021/02/13/我的2020总结/knowledge.png" title="体系与结构">



<p>学习过程是分阶段的，不同的阶段使用不同的策略，这才能达到最高效，就像健身锻炼，同一块肌肉需要换着方式来练习，从不同角度给肌肉变着花样下刺激，它才能保持很高的生长效率，这又是一篇出自大佬很好的总结《<a href="https://www.douban.com/note/702002484/" target="_blank" rel="noopener">2018年&amp;从业10年总结</a>》。</p>
<h2 id="带新"><a href="#带新" class="headerlink" title="带新"></a>带新</h2><p>引用一段内容：</p>
<blockquote>
<p>曾经在一个沙龙上听到一位70后的领导叫嚣：“我招来应届生后，先让他从端茶倒水和扫地拖地开始做，一个连小事都做不好的人，谈何做啥大事”。</p>
<p>看似意识正确，被广大管理人员奉为圭桌的真理，充满着可笑的逻辑错误，你要做的小事，是你工作领域的小事，是帮你在你专业领域打基础的事项，如果我是做老板的行政秘书的，那么端茶送水扫地拖地也无可厚非，如果你是做金融交易，管理咨询，甚至营销策划岗位，那么这些东西对你的专业领域没有丝毫卵用，反而是浪费时间。</p>
<p>尤其是刚刚毕业的那段时间，可以说是成长最快的一段时间，在这段时间里，你更要一头扎进去，心无旁骛的研究你的专业知识，形成你的差异化优势，而非在细枝末节和繁文缛节上被束缚住。</p>
<p>我很难去理解有着如此僵化管理思想的人，管理观念是如此的落后，殊不知，对下级的尊重是作为管理者最基本的素质。</p>
</blockquote>
<p>我十分同意，还是那句话，能挑更有含金量的活就必须要挑，人的成长本身就是消耗资源的过程，有含金量的工作内容就相当于更多的资源，吸收更多资源来成长，自然就能长得更快更高。一码归一码，揠苗助长那是不行的，在什么成长阶段就要做什么事情，跳阶段本身就很危险（自我感觉跳过了编码积累阶段，所以基础不牢靠，现在追赶得很蛋疼），你总不能让一个刚毕业的新人来设计架构吧，还是得让他先从小需求然后到功能模块再到组件这样的路线来培养。</p>
<p>跳出舒适区，承担稍稍超出能力上限的工作，人就能高效地成长，然而现实中很少具备这样的条件（尤其在业务团队），你会有很多事务性的工作需要处理。综上，在带新方面，有条件的话我会尽量把新人喂饱，先让他承担一些事务性工作（其实也是在帮我分担），定时给予他有一定挑战性的工作，同时放开让他自己发挥，中间保持固定的review排除风险，新人自己不蠢，有问题能及时反馈请求帮助，然后基于具体命题给予新人理念和方法的引导，这样新人一般都有比较符合预期的成长速度。</p>
<p>不久前我有这样的疑惑：<strong>“我把有挑战性的工作都给了新人来做，那我做什么？我靠什么支撑自己的成长？如果只是一味做统筹、资源协调、任务分配、规划等抽象工作，缺失了实践环节，最后发展的能力模型不就是畸形的空中楼阁吗？”</strong>。答案如下：</p>
<ul>
<li>自己已经解决过的，同时也知道怎么解决的问题，放心交出去</li>
<li>自己没有解决过的，只知道理论的，有条件自己来做，或者跟新人一起去做，由自己把控细节，新人落地执行</li>
<li>自己没有解决过的，也不知道怎么解决的，一定要逼迫自己面对（自己解决不了的难道新人就能解决？如果答案是yes，那自己就很危险了）</li>
</ul>
<p>之前面试了一位刚上大四的实习同学，入职之后他分配到了业务QA组，在里面呆了一个星期后他来找我聊天，说自己很迷茫，感觉这一星期下来就是对着手机点点点，感觉不到技术成长，跟自己放弃其他offer进来这边的工作预期不一致。这是一个最常见的疑问，很多同学以测开身份招聘进来可能以为日常工作有60-70%都是开发工作，其他的才是业务测试工作，实则不然。说实话，如果对自己的职业规划或预期是要做纯粹的技术大佬（往往毕业生都这样想），那QA岗位肯定是不合适的，直接找测试开发或开发岗就好了（不少大厂岗位是叫测试开发，但是不区分测试QA和测开岗，面试前一定要问清楚定位）；如果想多元化发展，想找更多的出路，除了技术外在业务理解力、问题分析能力上走得更远，那QA岗是一个门槛比较低但又不会很差的选择，也就是性价比高，因为QA真的可以接触很多东西。还有一次，也是跟这位实习同学交流，讲到给他的成长建议时我的观点是<strong>编码并不重要，技术能力其实是很广泛的概念，它除了具体编码实现外，还有问题分析、方案设计、执行落地等能力</strong>（个人感觉，做业务负责人远比做技术难度高得多，不展开了）。实习同学表示在腾讯实习时leader也是这样跟他说的，来到这里后的新leader还是这样跟他说的，就连我也是这样跟他说的。他还没能理解这句话的含义，但是已经记住，觉得这句话很厉害🤣。其实，我为了理解这句话，何尝又不是花了3年时间呢。</p>
<h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2><p>不知道是我以前没留意还是咋地，后半年陆陆续续关注到很多同龄人甚至超级后浪的技术公众号，公众号内容和运营都做得颇好，很快就能有显著💰收益那种。虽然他们口中说靠公众号月入xx万在我看来充满了微商气息，但是估计不假，因为粉丝数够多只要发一个广告恰一次饭就是几千块起步，他们还会结盟互相推广搞活动，确实有点手段。不过不得不说，有些公众号确实恰饭太急，没多少篇好文积累就开始恰饭，我有留意几个（后来陆续不关注了，对我干货有限），因为他们不是那些工作七八年的资深人士，项目经验和技术深度都有限，所以他们涨粉往往需要一到两篇爆文，粉丝特征会比较单一。他们的技术话题方向相似：面试题解析、编程基础技术深入、常见框架源码解读、数据结构&amp;算法讲解。本质共同点就是：问题偏向基础与通用、相关资料容易获取、话题经常被广泛讨论、具备一定挖掘空间、炫技大于实用等，在技术新人眼里就会显得特别高大上。他们的爆文也有一定相似性，比如：学校突出的奋斗历史、offer收割机般的面试经历、足够全面细致的源码分析。技术公众号现在风气就是这样，想要受众广并且持续产出文章保持更新频率，这些方向是更高概率成气候的，而越是尖端越是复杂越是冷门越是专业的文章，受众面会急剧萎缩，阅读量和粉丝数难免增长缓慢。</p>
<p>这也一定程度提醒了我搞副业的可能性，其实程序员做副业多数都是搞技术变现，不外乎几种选择：</p>
<ul>
<li>各个平台的公众号（微信、掘金、头条、简书、B站、知乎、博客园、SegmentFault等），个人博客引流与广告</li>
<li>知识付费，付费咨询</li>
<li>外包服务，接开发私活</li>
<li>开发独立程序，上架卖钱</li>
</ul>
<p>第一种应该是最常见的，门槛也是最低的，只要文章更新勤劳，有稳定的活跃粉丝数，就能有相对稳定的副业收入。不过副业道路千万条，在公司内部有个超级内推达人，自己做了一系列自动化手段，维护N个微信群，通过内推入职赚了大量内推费（肯定是十万为单位），分分钟效率比猎头和HR高。抓住机会把事情做到极致，做到没有竞争对手的地步，这个难度可不小。</p>
<p>偏题了偏题了，这里其实是想做个人的技术影响力，因为这个才是一切的源头，没有影响力何来流量？所以计划着2021年除了打好自己的基础外，要开始给未来的影响力做一些铺垫，最简单的是沉淀更多有干货的技术文章，像<a href="https://draveness.me/" target="_blank" rel="noopener">Draveness</a>这种同届灯塔性的技术巨佬，如此令人发指般勤劳还能保持爆表干货，我是臣妾做不到，退一万步来说，一月出两篇还是可以的，只需要最入门的时间规划能力就能实现。另一条容易想到的道路就是在做出有代表性的个人作品放到Github或者给一些有影响力的开源项目做贡献来赚取影响力，这个有门槛但也不是非常高，需要较强的自律能力。所以总结下来，2021年的重点是自律能力的培养，再抽象一些其实是习惯培养。</p>
<img src="/2021/02/13/我的2020总结/senior.jpg" width="400" height="300" title="我离大佬只差这么点">



<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p><em>高杠杆</em>这个词经常被大佬们提及，我便也学会了这个词🌚。理解起来很简单，就跟投资中的杠杆概念类似，比喻事半工倍，多数指一些前期投入高但是完成后收益长远的重要工作。这类所谓的高杠杆工作含金量会比日常事务性的工作高（事务性工作指日常琐碎的事情），在面试的时面试官也更希望听你阐述高杠杆工作🌚。如果有条件能挑更好的工作那一定要挑，不要任劳任怨，最后只会感动自己。但矛盾的是，有含金量的工作不一定能分到自己手头，因为总会有更强的人拦在你前头，所以切忌好高骛远，先踏踏实实把手头的工作做好（要说做到极致其实是地狱级难度），跟同事和上级建立好信任关系，这样就有空间来争取更多更好的工作内容。</p>
<p>在投资方面，自己还是个彻头彻尾的小白，18到20年，自己的存款最多是流去了P2P，不过后期投得比较谨慎所以没有踩到雷，P2P在我看来就是小白的投资神器，刨除暴雷风险，什么都不管就能拿到不差的利率。但是自从20年P2P开始受到严格管控后，我的存款就开始从里面一点一点拿回来了，转而放到类似余额宝等原始的货币基金（甚至都不能叫理财）。自己也意识到理财的重要性，靠着死工资是不可能发达的，这辈子都不可能靠打工拿工资发达的，跟妹子商量一下，决定俩人正式开始学习基金股票相关的投资知识，目前正在制定具体可落地的学习计划，搜罗知识获取的渠道和方式。</p>
<p>目标管理方面，2020年主要是体会了理论到实践的过程（阶段目标、阶段动作、里程碑），而在实践中会反过来深化理解，一些高级同事口中经常说的方法论，就顿悟了。不过在2020年里，没能把个人的生活也安排得充满目标感，目标管理还是做得很菜，生活总是这样，自律力差的人就得接受生活和工作的安排，难以获得让自己满意的主动权。</p>
<hr>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p>又是Flag环节，今年的Flag跟上年的Flag制定的形式开始不一样了，上年根本没看到自己的问题，只是单纯想到啥些啥，所以Flag体现不出目标上的压迫感和实在意义，最终黄了。今年把Flag分成几部分，大多数是早有预谋的事情，希望2021年过去，完成度能达到80%以上。</p>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><blockquote>
<ol>
<li>熟悉后端python Flask + 前端（Vue.js or 其他）的开发能力，具备初级移动端Android / iOS开发能力。  </li>
<li>阅读python Flask框架、requests库 &amp; 低版本MySQL源码。  </li>
<li>掌握基本的ROP技术，能独立分析一个安全漏洞。  </li>
<li>每月至少产出2篇优质博客。  </li>
<li>至少阅读8本书。  </li>
<li>体重保持在 70±2kg，解锁双力臂、前水平两个动作，俄式挺身不强求。  </li>
<li><del>跟女王大人去国外溜达一次（视新冠疫情而定）</del>  </li>
</ol>
</blockquote>
<p>事实再次证明，没有自律和规划能力的人，就无法掌控自己的生活，我就是活生生的反面教材。除了第7点算擦边完成外，其他的都不ok，要不就是完全没进展，要不就是“中道崩殂”。反复的打脸也暴露出自己的问题，目标即使定得很低很低，没有具体的落地计划，没有定期的review和跟进，就是一塌糊涂😠。</p>
<h2 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h2><p>2021年还是以务实为原则，20年年底正视了自己的好高骛远三分钟热度的问题，找到了一些调整方法，如<a href="https://www.zhihu.com/question/305507128/answer/559161157" target="_blank" rel="noopener">肉体控制精神</a>。很多时候我们无意使用了这些方法，只是没能意识到这些是已经沉淀下来的有效方法论。</p>
<p>2020年下半年已经制定了一版三年计划，具体到2021年实际上有两个方向的事情，第一是技术开发水平对齐工作2-3年的测开同学，第二是培养良好习惯，第三是身体素质的逆转。转化为具体Flag的话有下面几个自己比较期待的事情：</p>
<blockquote>
<p>继续保持对一切事物的好奇心，包括工作、生活、技术、人际关系 =￣ω￣=</p>
<p><font color="red"><strong>技术开发</strong></font></p>
<ol>
<li><strong>P0 结合开源以及内部的测试工具，自己独立开发一款完成度较高，可用易用的测试工具（客户端+后端+算法端+Web端）</strong></li>
<li>P1 Android/iOS端，能理解内部RD的专项技术和测试工具，并且消化一部分核心技术方案，转化为自己的实践小Demo</li>
<li>P1 熟练开发Web后端且源码级理解某后端框架，前端不做太多要求，只需要具备基本开发的能力</li>
</ol>
<p><font color="orange"><strong>习惯培养</strong> </font></p>
<ol>
<li><strong>P0 每月至少输出两篇技术博客</strong></li>
<li><strong>P0 每月至少完成一本技术书籍并总结脑图，整理出阅读学习笔记</strong></li>
<li>P1 每月至少阅读6篇领域相关paper</li>
</ol>
<p><font color="blue"><strong>身体素质</strong> </font></p>
<ol>
<li>*<em>P0 卧推上线提升到95KG，深蹲115KG，硬拉150KG，引体向上18个，臂屈伸35个  *</em></li>
<li>*<em>P0 体重还是不做控制吧，体脂小于等于18%就不错了  *</em></li>
<li>P1 1000米重新跑进3分45秒，400米达到70秒  </li>
</ol>
</blockquote>
<p>2020年看的一本鸡血书里写的东西还挺有道理的。</p>
<blockquote>
<p>精力 = 优势 + 价值 —— 很多人在职业中感到精力不足，通常的原因，要么就是这份职业并不能发挥TA的优势能力，要么就是这份职业虽然能发挥优势能力，但无法满足TA的核心价值。</p>
<p>专注 = 兴趣 + 能力 —— 一个人能对一份职业保持专注，不是靠天天打鸡血喝鸡汤就可以专注下来的，而是首先要有兴趣，同时能力恰恰能匹配这份兴趣本身。</p>
<p>比如，有人喜欢唱歌，很多数人的唱歌只能算作嚎叫，根本不叫唱歌，但也有少数人具有唱歌的天分，这种能力得到过行家的认可，自然就会专注与歌唱事业中。<strong>如果一个人光喜欢唱歌但五音不全，TA的专注很容易被焦虑打破；如果一个人对唱歌不感兴趣，压根不会有专注的意思</strong>。</p>
</blockquote>
<p>现在是2月21日，昨天周六还是法定工作日，今天周日休息，在吃外卖的时候看完了这个给我很大冲击力的视频《<a href="https://www.bilibili.com/video/BV1Bb4y1R7WQ" target="_blank" rel="noopener"><strong>一个百大UP主的创业故事</strong></a>》，而且最近何同学的《<a href="https://www.bilibili.com/video/BV13v411v7Zo" target="_blank" rel="noopener"><strong>整理自己的生活</strong></a>》附上库克采访也很火。看完之后意识到了一些新的点，一个人之所以突出或者优秀，会是因为什么呢：</p>
<ul>
<li>这个人<strong>具备天赋</strong>，在某个领域内的效率是普通人的若干倍</li>
<li>这个人很<strong>硬核</strong>，在某个领域内高效专注的时间投入量非常人所及 </li>
</ul>
<p>另外还看了《<a href="https://www.bilibili.com/video/BV1UE411W79t" target="_blank" rel="noopener">关于Vita君你想知道的差不多都在这里</a>》，最近关于8岁小孩教swift编程这件事很火，小孩的数理编程能力很强，了解了更多背景信息后发现他父亲是很多著名图灵出版社日文技术书籍翻译作者，现在对小孩家长的素质要求都这么高的吗😂？</p>
<p>努力观察身边优秀的同事，设置好自己5年、7年的职业模板参照，自勉吧少年。</p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>年初二晚上呆家里没外出，跟老爸一起 喝啤酒看电视，父母不太会玩手机，不会通过网络看综艺娱乐节目，就只能在电视上看看非诚勿扰这类节目娱乐，当时的男嘉宾问女嘉宾一个问题：“如果时光可以倒流，你想回到什么时候”。</p>
<p>说我没有做过让自己后悔的选择，那是不可能的，不过这里就不写这种题外话，我时常会想，自己在百度呆了2年4个月，到底有多少含金量。以前我总是会自我否定，认为自己那2年多就是虚度光阴混吃等死，自己比别人输在了职业前期，在写这篇总结的时候再想了一下，或许没那么糟糕，因为觉得周围人做的事情都比自己手头的牛逼，反过来培养了自己的好奇心，让自己有主动获取信息的习惯。</p>
<p>感谢你阅读到了最后，碍于我的水平，这篇年终总结有点流水账，前后内容存在重复，文章质量我其实不太满意。不管你是一字一句读到这里，还是跳跃着读到这里，抑或直接拉到了最后，㊗️你在2021年龙马精神、阖家安康、心想事成，恭喜发财🧨🎉~</p>
<img src="/2021/02/13/我的2020总结/2021.jpeg" width="400" height="300" title="2021新年快乐！">

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>

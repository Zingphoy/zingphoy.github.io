<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019清明节</title>
    <url>/2019/04/05/2019%E6%B8%85%E6%98%8E%E8%8A%82/</url>
    <content><![CDATA[<p>2019年第一个假期，一年一度的清明节，我妈提前告诉我要周四休假回家，周五一定要爬山祭祖不能再拖，最晚清明节当天扫墓，一再强调传统里没有人会清明节之后才扫墓。在这样的”命令”下，周四我从深圳坐大巴出发，在路上折腾了7.5小时后才到家里，睡一晚在清明节当天中午12点多就回村子准备爬山锄草扫墓。</p>
<p>老家这边还是相当传统的，只是一个小镇，老人去世了都会选择回到乡下下葬，提前找看风水的挑一个山头找个位子当自己的坟墓，去世之后火化将骨灰埋在乡下山头。清明节放假之前还跟来自五湖四海的同事说了我们这边的传统，估计现在还会爬山亲手用锄头镰刀锄草割草扫墓拜祭的人已经不多了，城里的都会选择公墓，去到直接放点花啊水果啊烧个纸钱就可以了，这边可不会这么简单。传统流程是要爬山，山里的墓（或者称为坟头）过了一年遍地是草，可别说草可以长到膝盖那么高，要扛着锄头镰刀爬上山头找到坟墓，把所有的草除掉，然后摆好蜡烛、香、各种拜祭用的食物，拜祭完再烧纸钱，最后放一个鞭炮，这才算结束，最后得收拾和检查鞭炮是否彻底熄灭，<strong><em>谨防山火，要不牢底坐穿</em></strong>。</p>
<p><strong>多图预警。</strong></p>
<a id="more"></a>

<h3 id="村里"><a href="#村里" class="headerlink" title="村里"></a>村里</h3><p>12点半左右到村里，iphone信号直接变成 <code>E</code> ，无法登录微信收发信息，只能打电话。村里依然比较原始，也是这几年来才陆续接上自来水，现在村里加起来可能也不够十户人家了，农村$\to$小镇$\to$当地城市$\to$大城市$\to$一线城市→出国 的趋势无可逆转，村里已经见不到年轻人了。</p>
<p>正宗走地鸡😌。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%9D%91%E9%87%8C.jpg" alt="正宗走地鸡😌"></p>
<p>破烂的泥田拖拉机。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%A0%B4%E7%83%82%E7%9A%84%E6%B3%A5%E7%94%B0%E6%8B%96%E6%8B%89%E6%9C%BA.jpg" alt="破烂的泥田拖拉机"></p>
<p>黄牛和水牛是农村里最常见的生物之一，我长这么大还没摸过一次😅。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E9%BB%84%E7%89%9B.jpg" alt="黄牛和水牛是农村里最常见的生物之一，我长这么大还没摸过一次😅"></p>
<h3 id="山里"><a href="#山里" class="headerlink" title="山里"></a>山里</h3><h4 id="山头1"><a href="#山头1" class="headerlink" title="山头1"></a>山头1</h4><p>在村里简单准备一下后，4个人扛着3个锄头一把锯子就往山里出发了，把第一个最远最难搞的坟墓给拜祭了。带路的长辈认错路，以往爬上山头虽然要翻草丛，不过还是会有一条人常走的小路留出来的，这一次走着走着不知道路在哪里，我作为队伍最强壮的年轻人(一个50岁的叔叔，一个在读大学的1米5+小女生，一个在读初三的男孩)，扛着锄头，锄柄上还挂着两瓶大瓶怡宝，用肉体在前面开路，一脚深一角浅，靠蛮力把草和树枝给踩下去，那种感觉估计跟绑着大轮胎走路差不多了。每一脚都缠上很多长得跟人一样高的叫不出名字的杂草，有一些还特别坚韧，横在路上扯着你的大腿摆脱不了完全无法向前再挪一步，就像缠上蜘蛛网一样，只能停下来稍稍后退高抬起脚把它踩下去才能通过。有时候脚下不知道怎么横着一跟大木头，直接绊倒，整个人趴在草丛上的感觉，又热又闷，长年没翻过的草丛满是尘，吸一口神清气爽，我甚至把小树叶都给吸到喉咙里，很难受😷。</p>
<p>钻完草丛裤子就变成这样了😶。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E9%92%BB%E8%8D%89%E4%BB%8E.jpg" alt="钻草从"></p>
<p>山里往下拍的感觉，iphone7就给拍成这样了，拍不出人眼看到的绿色。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%B1%B1%E9%87%8C.jpg" alt="山里"></p>
<p>我们上来之后，后面的几个长辈挑着担子把拜祭用的东西挑上来了，包括纸钱、元宝蜡烛、米酒、筷子杯子、烧鹅、甘蔗、鸡蛋、各种糍……墓前的草都已经末膝盖了，还有一颗树倒了下来压在旁边，几个长辈又是锯又是搬才把它推走。作为新生代爬山扫墓主力，基本上手里不是锄头就是柴草，锄累了就搬杂草扔掉，恢复十分钟拿过锄头继续干，我右手都给磨出一个小水泡来了😂。顶着太阳一路干，真的有榨干的感觉，锄不到5分钟就得休息一下，体力流失很快，两个学生就站在一旁看着，果然爬山锄草这种粗活，还是由我们这些长辈(包括我)来干。我也是这几年来才开始接收锄草工作，好多操作和术语都听不懂，浑身除了蛮力之外也没什么排得上用场的东西，不过还是要尽量输出一下自己的力量多做点贡献。</p>
<p> 一路“披荆斩棘”的山路，看一下根本不知道路在哪里😅，偶尔会出现一些比较好走的地方，那是别人先前走过的，要找自家祖先的墓，走的路基本要自己开辟一次。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%8D%89%E4%B8%9B.jpg" alt="草丛"></p>
<h4 id="山头2"><a href="#山头2" class="headerlink" title="山头2"></a>山头2</h4><p>小分队过来把最远最高的山头墓给拜祭完了，把东西扛回村里接着下一个山头，一共有5个地方要去，这才把第一个给整完了，不过剩下4个家里花钱叫人帮我们给锄草了，很专业，也很便宜，500元清理4个墓（绝对友情价），两人干了两天，要是让我来干double价格我都要考虑一下🤔。挑担子可以说真的很难受，担子两端绑着的篮子甩来甩去的，挑久了肩膀还会被摩擦得很痛，沉是一回事，但是摩擦到痛就不能忍了，不停在两个肩膀换来换去，直到都给摩擦到通红，皮都擦掉了，摸一下有股辛辣的感觉，就是痛🙄。</p>
<p>担子另一端还提着一个篮子，像我这种N年不碰重活的，胆子卡在肩膀上是挺痛的。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%8C%91%E6%8B%85%E5%AD%90.jpg" alt="挑担子"></p>
<h4 id="山头-x"><a href="#山头-x" class="headerlink" title="山头$x$"></a>山头$x$</h4><p>这是最后一个了，一天搞下来已经5点，晒到脖子都痛(我真的很容易晒伤🙄)。山里被人开发，树全都锯掉了，可以看到跟之前的照片对比这里就是光秃秃的，长辈们说这挺好的，这样这个山头以后清明就更好走了，我心里的滋味倒是不一样，不知道以后这一片山林会不会就这样慢慢消失……</p>
<p>这里过去原本是个茂密的山林，最近几个月出现了开发商承包山头不知道搞什么开发，现在看过去什么都没有了，整个山体都是裸露出来的，肉眼可见的山地，没有树木挺立起来。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%8E%9F%E6%9C%AC%E6%98%AF%E4%B8%AA%E8%8C%82%E5%AF%86%E7%9A%84%E5%B1%B1%E6%9E%97.jpg" alt="原本是个茂密的山林"></p>
<hr>
<p>一天下来所有的墓终于都拜祭完了，按照我们的方言叫【所有嗰山都行完了】，大伙凑在一起就可以狂吃一通了。一个亲戚说，<strong>在外面工作做梦都想吃这些，然而现在吃几块又腻了</strong>🤣，全场爆笑。里面的不少东西在儿时一点都不喜欢，觉得那是大人才喜欢的东西，现在越是长大越是发现自己喜欢吃，这是一个魔咒？在深圳是不可能吃得到的，所以这些地方食物基本是一年只能吃一次。吃的时候有个亲戚又挑起话题问我怎么不带女朋友过来爬山，有个女朋友而已又不是我中了100万彩票，我就是要带别人也不愿意来呀🤣。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%87%86%E5%A4%87%E5%88%87%E8%82%89.jpeg" alt="准备切肉"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%88%87%E8%82%89ing.jpg" alt="切肉ing"></p>
<p>袋子里装的是我的最爱：糖水糍、白松膏、软饼(从左到右的方言称呼) ，其中前两者在顺德又叫伦教糕，引入到我老家再经过口味改良就变成爬山祭祖专用的食物了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E6%88%91%E7%9A%84%E6%9C%80%E7%88%B1.jpg" alt="我的最爱"></p>
<p>再补几张路过时留下来的照片，留个念想，感受一下那慢腾腾又很规律的生活⏱。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E5%B0%8F%E8%B7%AF.jpg" alt="小路"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%94%B0%E9%87%8E1.jpg" alt="田野1"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E7%94%B0%E9%87%8E2.jpg" alt="田野2"></p>
<p>留意到远处的山头也变得光秃了……开发商的功劳。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>爬了半天的山，一年一度的清明节就这样结束。按照我们家的习惯晚饭都会在大排档一起解决，毕竟搞得这么累谁还想回去做饭，我做了个小程序员老妈好像特别自豪一样说今天让我请大伙吃饭，我😕？？？</p>
<p>先回家洗个澡，家里干净的地边被脏兮兮的我一踩就黑掉了，脱下鞋子终于可以安静地坐下来，把里面的树叶沙子给倒出来，在爬山的时候一只脚还陷到泥水坑里不过幸好没怎么进水，只是表面湿了。</p>
<p>两双鞋这样摆在一起，左边那双是今天爬山穿的，高中时候的旧鞋，右边那双是从深圳穿回来的，平时穿着上班。我看到了两个”我”，一个是作为父母儿子，希望父母安好开心的一面；另一个是在深圳发展职业生涯，一心想成为某个领域技术专家的一面。</p>
<blockquote>
<p><strong>人的本质是一切社会关系的总和。</strong></p>
<div align="right">——马克思</div>
</blockquote>
<p>回到老家想父母开心，我总是会潜意识想方设法多讲一些好玩的东西让父母笑，老妈说，每次我就快要回家的时候，老爸就跟她说很开心很开心，自己在深圳发展职业，走了程序员这条路就注定最后是不可能回老家发展的，时间上确实没办法多陪老人，总是想着在其他方面弥补。比如多买一些东西给父母用用，时间这块补不上来了，真的只能用物质来补；多教教他们用手机，让他们跟得上时代；多跟他们讲讲微信，让他们知道我在这边一切安好……</p>
<p>深漂，虽然从事的工作岗位没有说得上喜欢，但是也尽量在业余时间让起步落后于别人的自己多充电，趁着热情还在多多学习和实践，当然那一面我是不会跟父母说太多的，毕竟也不是什么健康的生活习惯。自己能做的就是驱使自己更多更高效目的更明确地野蛮生长，希望在未来可以有充分的物质生活，才能让父母享受到跟他们现在辛苦程度相匹配的快乐晚年生活。</p>
<img src="/2019/04/05/2019清明节/两个我.jpg" title="两个“我“">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>假期</tag>
        <tag>感想</tag>
        <tag>记录</tag>
        <tag>家乡</tag>
      </tags>
  </entry>
  <entry>
    <title>cvechecker调研分享</title>
    <url>/2018/08/02/cvechecker%E8%B0%83%E7%A0%94%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="cvechecker"><a href="#cvechecker" class="headerlink" title="cvechecker"></a><strong>cvechecker</strong></h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h3><p>cvechecker是一个工具，会根据你提供的软件列表自动确认装在本机的软件的相应版本，然后跟网上的在线数据库（database of potential vulnerable software）进行漏洞与软件版本的匹配，发现可疑漏洞会报告。</p>
<br>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h3><ul>
<li><strong><em>CVE</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>V</strong>ulnerabilities and <strong>E</strong>xposures：通用漏洞披露（维基百科）</p>
<p>CVE：A list of entries — each containing an identification number, a description, and at least one public reference — for publicly known cybersecurity vulnerabilities. </p>
<p>格式：CVE-YYYY-NNNN；YYYY为西元纪念，NNNN为流水编号</p>
<p>例子：2014年发现的心脏出血漏洞（Heartbleed bug）编号为 CVE-2014-0160</p>
<ul>
<li><strong><em>CPE</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>P</strong>latform <strong>E</strong>numeration</p>
<p>一种结构化的命名规范/标准。</p>
<p>例子：</p>
<p>规范的版本较多，对于一个这样的信息：<br>[part=”a”,vendor=”microsoft”,product=”internet_explorer”,version=”8.0.6001”,update=”beta”]</p>
<p>CPE格式可以如下：</p>
<p>cpe:2.3: a:microsoft:internet_explorer:8.0.6001:beta:*:*:*:*:*:*</p>
<ul>
<li><strong><em>CVSS</em></strong></li>
</ul>
<p><strong>C</strong>ommon <strong>V</strong>ulnerability <strong>S</strong>coring <strong>S</strong>ystem：通用漏洞评分系统</p>
<p>它是工业标准，用于描述安全漏洞严重程度的统一评分方案。</p>
<a id="more"></a>

<hr>
<h3 id="cvechecker的安装"><a href="#cvechecker的安装" class="headerlink" title="cvechecker的安装"></a><strong>cvechecker的安装</strong></h3><ol>
<li>官方下载压缩包解压</li>
<li>进入cvechecker的根目录，运行 <code>./configure</code> 开始配置</li>
<li>运行 <code>make</code></li>
<li>运行 <code>make install</code> </li>
<li>完成安装</li>
</ol>
<p>注意点：运行 <code>configure</code> 不成功的话，可能先需要解决一些依赖问题。cvechecker默认使用sqlite3来管理cve数据，支持sqlite、sqlite3、mysql，如果使用mysql需要做一些额外的配置，具体可以参考<a href="https://www.zhihu.com/question/37822443" target="_blank" rel="noopener">这个链接</a>。</p>
<br>

<h3 id="cvechecker的使用"><a href="#cvechecker的使用" class="headerlink" title="cvechecker的使用"></a><strong>cvechecker的使用</strong></h3><ol>
<li><p><code>cvechecker -i</code></p>
<p>在本机初始化数据库（默认使用sqlite3），用来存储网上下载到本地的CVE，在我的ubuntu上试验的时候，初始化数据库会在目录 /usr/local/var/ 中创建名叫cvechecker文件夹，需要root权限来运行。当然可以直接修改cvechecker根目录下conf文件夹中的 <code>cvechecker.conf</code> 文件来改变数据库存放的位置</p>
</li>
<li><p><code>pullcves pull</code></p>
<p>该命令会自动从网络下载CVE数据，存到数据库中去</p>
</li>
<li><p>准备工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -path /mnt -prune -o -path /media -prune -o -type f -perm -o+x &gt; scanlist.txt</span><br><span class="line">echo "/proc/version" &gt;&gt; scanlist.txt</span><br><span class="line">cvechecker -b scanlist.txt</span><br></pre></td></tr></table></figure>

<p>每一次系统软件有更改，都需要让cvechecker重新加载系统安装的二进制文件清单。cvechecker不会去自动重新加载文件清单，更加不会去感知系统软件版本的变动。所以需要手动使用 <code>find</code> 命令去感知所有executable commands和libraries</p>
</li>
<li><p><code>cvechecker -r</code> or <code>cvechecker -r -C &gt; output.csv</code></p>
<p>启动检查，cvechecker会打印出一个漏洞列表，加一个 -C 选项会打印出csv格式。</p>
<p>更加具体详细的命令选项，可以参考<a href="https://www.mankier.com/1/cvechecker" target="_blank" rel="noopener">链接</a>。</p>
<br>

</li>
</ol>
<h3 id="cvechecker扫描结果解读"><a href="#cvechecker扫描结果解读" class="headerlink" title="cvechecker扫描结果解读"></a><strong>cvechecker扫描结果解读</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;/home/zingphoy/Software/odp/lib/gcc-3.4.5/libsasl2.so.2&quot; (CPE = cpe:/a:carnegie_mellon_university:cyrus-sasl:2.1.19::￼:) on host ubuntu (key ubuntu)</span><br><span class="line">  Potential vulnerability found (CVE-2009-0688)</span><br><span class="line">  CVSS Score is 7.5</span><br><span class="line">  Full vulnerability match (incl. edition/language)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一段是具体的文件匹配到了一个具体的CPE信息</li>
<li>第二段是相应的CVE编号</li>
<li>第三段是CVSS分数</li>
<li>第四段是匹配出一个漏洞的可能性</li>
</ul>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><p>cvechecker的核心功能就是拿到软件的版本号，然后根据规则去匹配cve漏洞库，cvechecker是怎么做的呢？Sven（开发者）没有依赖于包版本管理器，而是直接通过查找软件包的版本号，然后构造CPE（Common Platform Enumeration）信息，通过在cve数据库中查找给CPE信息来提取CVE信息。每个软件包都包含了众多的软件，如ls和cat都属于coreutils,那么如何从系统软件列表差找到软件包列表及版本号便是Sven方法的关键所在。通过查看代码发现，Sven自己维护了一个软件包和各个命令的映射关系表。内容类似于：</p>
<blockquote>
<p>,perlivp,1,perlivp$,# perlivp v([0-9][0-9]<em>(.[0-9]+)+),a,perl,perl,\1,,,<br>,libvorbis.so,1,libvorbis.so.</em>,Xiph.Org libVorbis ([0-9][0-9]*(.[0-9]+)+),a,xiph,libvorbis,\1,,,</p>
</blockquote>
<p>看过cvechecker帮助文档的用户都知道，用户自己也可以定义添加这种映射表，而默认的映射表是由Sven自己维护的，默认只有<a href="https://github.com/sjvermeu/cvechecker/blob/master/versions.dat" target="_blank" rel="noopener">650条</a>，因此这里就是漏报的一处主要原因。</p>
<p>这个映射表解决了从命令到软件包的映射，但怎么获取软件包的版本号呢？继续看代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Here is where the various version extraction methods are supported.</span></span><br><span class="line"><span class="comment"> * We currently still only support a single method (1, which is the</span></span><br><span class="line"><span class="comment"> * "strings -n 3 &lt;file&gt;" command execution) but now we can see if we can</span></span><br><span class="line"><span class="comment"> * support additional methods as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (filetype == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[BUFFERSIZE];</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        zero_string(buffer, BUFFERSIZE);</span><br><span class="line">        ret = strings_extract_version(ws, &amp;preg, pmatch, &amp;cpe_data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                add_to_sqlite_database(ws, cpe_data);</span><br><span class="line">                cpe_to_string(buffer, BUFFERSIZE, cpe_data);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">" - Found match for %s/%s:\t%s\n"</span>, ws-&gt;currentdir, ws-&gt;currentfile, buffer);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" ! %s/%s: The sqlite3 implementation currently doesn't support file type %d\n"</span>, ws-&gt;currentdir, ws-&gt;currentfile, filetype);</span><br><span class="line">&#125;;</span><br><span class="line">ws-&gt;rc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>原来是通过strings读取二进制程序中的标示，然后通过正则表达式来提取其中的版本信息。系统中的软件多种多样，尽管有默认的编程约定，但不同的开发者肯定会使用不同的声明方式，难免会无法找到或找错版本信息。此外，各个发行版本在发现CVE时往往采用<a href="https://zh.wikipedia.org/wiki/向後移植" target="_blank" rel="noopener">backporting</a>策略，因此即使CVE已经修复，软件包的大版本号也不会发生变化，这也是引起误报的主要原因。</p>
<p>更具体看函数调用（可上github自查）—— strings_extract_version( )的声明和实现：</p>
<p><a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c" target="_blank" rel="noopener">cvechecker</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c/src" target="_blank" rel="noopener">src</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/2186f7e20152d05649d3b24bf59a79e9a0bca20c/src/output" target="_blank" rel="noopener">output</a>/<strong>stringscmd.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../cvecheck_common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../swstring.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Sven Vermeulen.</span></span><br><span class="line"><span class="comment"> * Subject to the GNU Public License, version 3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings_extract_version - Method for extracting the version from the file using the strings command</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strings_extract_version</span><span class="params">(struct workstate * ws, <span class="keyword">regex_t</span> * preg, <span class="keyword">regmatch_t</span> * pmatch, struct cpe_data * cpe)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e" target="_blank" rel="noopener">cvechecker</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e/src" target="_blank" rel="noopener">src</a>/<a href="https://github.com/sjvermeu/cvechecker/tree/e4676651e346d309c0e6191b733b2c4dea13e03e/src/sqlite3" target="_blank" rel="noopener">sqlite3</a>/<strong>sqlite3_impl.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlite3_impl.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strings_extract_version</span><span class="params">(struct workstate * ws, <span class="keyword">regex_t</span> * preg, <span class="keyword">regmatch_t</span> * pmatch, struct cpe_data * cpe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * stringcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> file[FILENAMESIZE];</span><br><span class="line">    <span class="keyword">char</span> data[FILENAMESIZE];</span><br><span class="line">    FILE * workfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">config_setting_t</span> * stringcmdcfg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * buffer;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> retv;</span><br><span class="line">    </span><br><span class="line">    zero_string(data, BUFFERSIZE);</span><br><span class="line"></span><br><span class="line">    stringcmdcfg = config_lookup(ws-&gt;cfg, <span class="string">"stringcmd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (stringcmdcfg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Configuration file does not contain stringcmd directive.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    stringcmd    = config_setting_get_string(stringcmdcfg);</span><br><span class="line">    <span class="keyword">if</span> ((swstrlen(stringcmd) == <span class="number">0</span>) || (swstrlen(stringcmd) &gt; FILENAMESIZE<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Configuration files 'stringcmd' directive cannot be empty or exceed %d characters\n"</span>, FILENAMESIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (swstrlen(ws-&gt;currentdir)+swstrlen(ws-&gt;currentfile) &gt; FILENAMESIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"File path cannot exceed %d characters\n"</span>, FILENAMESIZE<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">"%s/%s"</span>, ws-&gt;currentdir, ws-&gt;currentfile);</span><br><span class="line">    buffer = substitute_variable(stringcmd, <span class="string">"@"</span>, <span class="string">"@"</span>, <span class="string">"file"</span>, file);</span><br><span class="line"></span><br><span class="line">    retv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    workfile = popen(buffer, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(data, FILENAMESIZE, workfile) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[FILENAMESIZE<span class="number">-1</span>] != <span class="number">0x00</span>) </span><br><span class="line">            data[FILENAMESIZE<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[swstrlen(data)<span class="number">-1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            data[swstrlen(data)<span class="number">-1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    rc = regexec(preg, data, <span class="number">16</span>, pmatch, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">        retv = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Found a match, extracting version (but first, print it out)</span></span><br><span class="line">        <span class="keyword">for</span> (rc = preg-&gt;re_nsub; rc &gt; <span class="number">0</span>; rc--) &#123;</span><br><span class="line">            retv += search_and_substitute_group(preg, pmatch, data, cpe, rc);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    zero_string(data, FILENAMESIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(workfile);</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> retv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到此，cvechecker已经获取了系统软件包列表以及软件包对应的版本号，将该信息处理成CPE信息，在CVE列表中查找即可。</p>
<hr>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>扫描速度快，扫描时资源占用少，程序不用需要后台运行，默认配置即可覆盖常用的软件</li>
<li>当扫描规则支持得越丰富，cvechecker的威力就会越大，从某种程度上说它是一个成长性的扫描工具，通过人为配置（如同WAF添加规则一样），作用会越来越强大</li>
<li>cvechecker虽然无法准确的查询出当前系统的cve信息，但是很好的解决了不同Linux版本中包管理器差异的问题，底层依赖较少</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>cvechecker处理中涉及到众多的映射信息，如程序和软件包的映射表、CVE列表，默认会下载当前所有的CVE信息，使用数据库来组织这些映射信息，需要占用不少磁盘空间，截止至2018-08-02，nvdcve漏洞信息的文件就有820MB大小</li>
<li>难以保证漏报率，需要进行大量人工干预</li>
</ul>
<br>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>作为主机软件安全的基准扫描，由于扫描时消耗的资源也不是特别大，可以作为例行扫描来使用；</p>
<p>除了在单台机器上都部署一个cvechecker之外，这里考虑一种集中式的cvechecker。本身cvechecker并不需要长期后台运行，只需要给它一个cpe信息它就可以开始匹配，所以可以试着做成一个后台服务器，上面部署cvechecker，其他机器上装一个agent例行收集机器上软件的cpe信息。agent把收集的信息发送到服务器让上面cvechecker完成匹配工作再返回结果。当然这里的额外工作量就是完成一个收集cpe信息的agent，肯定涉及到不少的兼容工作，而且部署在server上的cvechecker本身的软件版本侦查能力也被浪费了。这样做好处就是可以不用再每一台机器上都拉去nvdcve漏洞信息，可以省去不少磁盘空间，并且只需要维护一套匹配规则，更加方便人为配置匹配规则，而后台负责匹配的cvechecker也可以做成集群式，只要数据库和匹配规则适当地分发下去，就可以连续高负载地匹配漏洞。</p>
<p>对于特殊的、硬件环境较为低端苛刻的服务器，上面只部署了极少数的软件服务，而且存储空间十分小，可考虑使用watchlist功能，手动配置需要扫描的软件的CPE信息，而不需要从网上拉取一个巨大的数据库存在本地。</p>
<hr>
<h2 id="对比公司内部项目"><a href="#对比公司内部项目" class="headerlink" title="对比公司内部项目"></a><strong>对比公司内部项目</strong></h2><p>内部某项目的资产、指纹收集功能也是收集软件和类库的版本号，主要的技术手段是调用软件的shell命令或find文件名，再去截取版本号。这种方案是针对性地获取版本号，覆盖类库&amp;软件若干种。将这些版本号上报到后台，后台会进行CVE版本匹配，找出对应的软件版本是否存在已知CVE漏洞。</p>
<p>部分已脱敏的golang代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g_ClassLibraryInfo = []ClassLibraryInfo&#123;</span><br><span class="line">    &#123;<span class="string">"apr"</span>,<span class="string">"libapr-1.so.0"</span>,<span class="string">"ldconfig -p|grep libapr-|head -1|cut -d '&gt;' -f 2"</span>,<span class="string">"ldconfig -p|grep libapr-|head -1|cut -d '&gt;' -f 2|cut -d '.' -f 3"</span>,<span class="string">""</span>&#125;,</span><br><span class="line">    &#123;....&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> <span class="string">"apr"</span>:</span><br><span class="line">    classlibpath, classlibversion = GetLibInfo(<span class="string">"libapr-"</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"apr-util"</span>:</span><br><span class="line">    classlibpath, classlibversion = GetLibInfo(<span class="string">"libaprutil"</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">case</span> ...</span><br></pre></td></tr></table></figure>

<p>获取软件版本号似乎市面上还没有一个通用的方案，cvechecker也需要针对性地获取软件版本。cvechecker主要是通过编写匹配规则来针对性获取，可以看配置文件 <a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">cvechecker</a>/<strong>versions.dat</strong> ，获取方法上面已经分析过了，就是利用strings命令+正则的方式来匹配版本号，其优点就是不同Linux系统都比较通用（内部的方案其实也是比较通用的，至少在公司需要兼容的几种系统上没有特别问题），但是没有明显数据支撑两者到底哪一个更好，所以这里拿不出高下之分的定论。</p>
<p>缺点也是很明显的，如果软件版本号格式一旦修改，那么规则都会对新的版本号失效，不过一般正规有名气的软件发行到市面上的版本号格式都比较固定，所以不需要担心这个问题。</p>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="https://www.jianshu.com/p/944618676dae" target="_blank" rel="noopener">漏洞扫描基本概念</a></p>
<p><a href="cpe.mitre.org">CPE官网</a></p>
<p><a href="https://cve.mitre.org/index.html" target="_blank" rel="noopener">CVE官网</a></p>
<p><a href="https://nvd.nist.gov" target="_blank" rel="noopener">Natinal Vulnerability Database - CVE数据库</a></p>
<p><a href="https://cpe.mitre.org/specification/1.1/cpe-specification_1.1.pdf" target="_blank" rel="noopener">cpe格式详解</a></p>
<p><a href="https://www.mankier.com/1/cvechecker" target="_blank" rel="noopener">cvechecker官方使用文档</a></p>
<p><a href="https://github.com/sjvermeu/cvechecker/blob/master/docs/cvechecker.1" target="_blank" rel="noopener">cvechecker的github文档</a></p>
<p><a href="http://www.seteuid0.com/cvechecker实现分析/" target="_blank" rel="noopener">cvechecker实现原理分析</a></p>
<p><a href="http://blog.siphos.be/2011/04/cvechecker-3-0/" target="_blank" rel="noopener">cvechecker 3.0</a> </p>
<p><a href="https://www.oschina.net/question/11_6205" target="_blank" rel="noopener">如何选择漏洞扫描工具（扫盲帖）</a></p>
<p><a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">cvechecker的github仓库</a></p>
]]></content>
      <categories>
        <category>调研</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>调研</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>功能测试小感</title>
    <url>/2018/02/28/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%84%9F/</url>
    <content><![CDATA[<p>功能测试某种意义上确实是有套路规律的。所谓的测试经验，在我看来就是把套路运用在不同场景的能力，也就是灵活运用的能力。其实这里的<code>套路</code>，换种说法就是<code>测试理论</code>。</p>
<p>从黑盒角度来说，<code>边界值、等价类</code>，这些应该都是软件测试人员的基本知识，应该深入思维信手拈来而不是刻意为之。<code>边界值</code>帮助我们发现比较好找的bug，改善软件最下限的质量（还别说这些边界校验真的是bug的重灾区，具体数量依赖开发自测水平），<code>等价类</code>帮助我们精简用例数量，提高执行效率。这些可以说是脱离业务场景单独针对代码逻辑的用例设计，可以在不理解业务的前提下直接开测。</p>
<a id="more"></a>

<p>除此之外，<code>场景法</code>也是非常重要的手段。<code>场景法</code> 简单理解就是根据不同的用户场景来设计用例，这里没有什么一套一套的测试理论，唯一的要求就是理解业务场景，从用户角度出发。<strong>一些不是bug的问题，在这样的要求下可能就会变成bug，因为它们有悖于业务场景，削弱了用户体验</strong>。</p>
<p>另外，一些更加工程类的bug，比如多线程竞争、变量缺少正确初始化、数据库死锁等问题偏白盒，从黑盒角度看有时症状会比较奇怪。这些问题我觉得更加适合在白盒的角度来发现，这往往也是code review必要性的体现。很多时候，如资源竞争这类问题需要的业务场景比较复杂，场景触发所需要的成本相对更高，甚至靠线下测试环境的机器资源根本无法触发。所以如果什么问题都想着从黑盒角度来发现，那是不靠谱的。<strong>这也正是一个好的QA与普通QA拉开差距的地方——除了理解业务场景、熟练地从黑盒发现功能问题外，还要求可以白盒通读代码，在脑海模拟业务场景，从而去发现逻辑问题。</strong></p>
<h3 id="如何设计测试用例"><a href="#如何设计测试用例" class="headerlink" title="如何设计测试用例"></a>如何设计测试用例</h3><p>这里并不打算写一篇全面的教程，只是分享个人对某些点的一些看法。</p>
<p>测试的最高目的，是<strong><em>验证代码产出是否符合需求</em></strong>。那可能会问：“既然只需要符合需求，那为什么还要考虑那么多的边界、异常值呢？”，道理很简单，因为<strong>这些都是隐藏在需求之下的情景</strong>。需求，本身是服务于用户体验的，而不是凭空出来的产品功能约束。那么为了一个完整的用户体验，肯定要包含一定程度的容错操作，这就是边界值、异常值考虑的缘由。</p>
<p>既然已经有了一个测试的最终目的，那么具体如何设计用例就好办了。</p>
<ol>
<li><p>根据代码逻辑进行用例设计，以代码覆盖率作为衡量标准。</p>
<blockquote>
<p>所以一些明显覆盖相同逻辑、相同代码路径的用例，就可以去掉。比如新增功能点是支持连续升级，如果连续升级2次和连续升级3次这两个case覆盖的代码逻辑没有差异，后者完全没有存在的必要。</p>
</blockquote>
</li>
<li><p>结合需求进行用例设计。</p>
<blockquote>
<p>QA必须对一切保持怀疑，故不能认为RD已经完全按照需求进行开发。另外，这种方式可能会有bonus——发现RD与QA对需求点理解的差异，从而推动确认真正的需求到底是什么，这样无疑对产品有积极的帮助。</p>
</blockquote>
</li>
<li><p>异常情景用例设计。</p>
<blockquote>
<p>异常测试可以被放在一大块里面，这样更加方便归纳整理、查漏补缺。异常包括很多情况，具体根据不同业务类型来定义什么是 “异常” ，安装失败、升级失败、解析配置失败、网络请求失败、用户高频操作等等，这些都是异常。</p>
</blockquote>
</li>
<li><p>提高用户体验的用例设计。</p>
<blockquote>
<p>这里本身不应该单独分出来的，但是我觉得很重要。用户体验其实不一定会有具体的用例，很多时候往往只是一种主观感受，比如色调、操作流程顺序、功能的作用大小等。一个具体例子就是根据订单号的订单搜索，订单搜索使用模糊匹配效果往往要比精确匹配好，原因很简单，因为根本不可能由用户去记住冗长没有规律的订单号。</p>
</blockquote>
</li>
</ol>
<p>扯一点题外话，一个好的QA，还应该要熟练掌握各种对自己有帮助的工具。除了发现bug外，还应该有定位bug、调试代码的能力。定位某些bug，比如常见却又难发现的内存泄漏，就需要特定工具帮忙。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>功能测试</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY装机小白科普-cpu篇</title>
    <url>/2019/06/30/DIY%E8%A3%85%E6%9C%BA%E5%B0%8F%E7%99%BD%E7%A7%91%E6%99%AE-cpu%E7%AF%87/</url>
    <content><![CDATA[<p>电脑是这个年代的刚需，笔记本便携固然好，但是性能有限，当各位上班族的住所稳定下来之后，购买一台配置跟上时代的台式机的需求自然而然就有了，为什么需要台式机，我用一台笔记本不就够了吗？</p>
<ol>
<li>台式机性价比高，同样的价格买回来的配置性能比笔记本高一到两个档次，同样的配置买回来价格分分钟比笔记本低25-40%。</li>
<li>台式机灵活性好，配置更换方便，基本上任何部分都可以随意升级更换，坏了自己修方便。</li>
<li>台式机容易上 RGB Buff 😆！（RGB灯：五颜六色的灯光效果）</li>
</ol>
<p>好吧，第3点其实是半开玩笑的，前2点已经解释了为什么选择台式机了，但是购买台式机也有要注意的地方：</p>
<ol>
<li>不买品牌机，因为品牌机配置没什么选择性，想要升级配置还得定制，价格贵配置差捆绑售后服务，基本上是交智商税[^1]。</li>
<li>不买电商平台上面看到的整主机（如x美国度），里面的配置缩水得看不下去[^2]。</li>
<li>不去实体店买配件，要网购，请认真看这个链接[^3]，引用别人的话：实体店价格高、不专业、套路多、型号老、售后差。</li>
</ol>
<p>好了，正文准备开始了，这篇文章的用意是指导小白入门，所以尽量做到基础知识上的面面俱到同时将没必要的细节屏蔽，图文会比较多，同时附上较多有价值的参考链接，如果是pc端看的话建议一起看了。建议先收藏，有空就看一个部分😏。注意本文有时效性哦~</p>
<a id="more"></a>

<h3 id="CPU篇"><a href="#CPU篇" class="headerlink" title="CPU篇"></a>CPU篇</h3><p>cpu是什么？电脑的核心啊，因为主板需要根据cpu来选择，所以买电脑一个首先要考虑的就是cpu，cpu正片现在开始。</p>
<blockquote>
<h4 id="cpu有哪些牌子吗？"><a href="#cpu有哪些牌子吗？" class="headerlink" title="cpu有哪些牌子吗？"></a>cpu有哪些牌子吗？</h4></blockquote>
<p>cpu适合个人PC的大概也就是<code>两个牌子</code>，你认为只有两个牌子其实也没有错，因为其他牌子估计也不会听到。这两个牌子一个是<code>Intel (英特尔)</code>，一个是<code>AMD</code> (一般没人叫中文名，百度百科管它叫超威)。在PC上这两个牌子都有一段长长的历史，这里就不做展开了，但是目前Intel在大众视野里应该更加著名，毕竟早个五六年AMD一直被Intel吊打，性价比一直比不上Intel。到了2017年，AMD研制出全新架构，推出Ryzne锐龙处理器之后，格局就不一样了，<a href="https://zhuanlan.zhihu.com/p/44571636" target="_blank" rel="noopener"><strong><em>了解Intel和AMD的恩恩怨怨可以点我</em></strong></a>。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMDvsIntel.jpeg" alt="AMDvsIntel"></p>
<hr>
<blockquote>
<h4 id="cpu的参数如何识别好坏？"><a href="#cpu的参数如何识别好坏？" class="headerlink" title="cpu的参数如何识别好坏？"></a>cpu的参数如何识别好坏？</h4></blockquote>
<p>放上一张JD的cpu参数介绍图，我们来一项一项说明，这里以<code>AMD r7 2700X</code>做例子：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD-r72700x-JD.png" alt="AMD锐龙7 2700x"></p>
<p><code>核心</code>：这是2019年了，早就是cpu的多核时代了，以前的cpu只有一个核心，现在技术上单个cpu核心上的性能已经越来越接近物理极限，厂商们想要提升cpu的性能，开始从单cpu核心转变为多cpu核心。<code>一般来说核心越多越好</code>，当然这不是绝对定理，因为不同的厂商单个cpu核心的性能是有差距的，3个诸葛亮跟4个臭皮匠 (3个好核心比4个垃圾核心)，肯定是前者更好呀。但是核心太多会导致其他问题，越多核心，cpu之间的协作成本越高，好比现实世界，有时候一个人做事反而比三个人更快，就是因为一个人独立负责可以剔除一切沟通成本，使得效率更高，同理，<code>cpu核心越多，不同cpu之间因为合作需要内耗越大</code>，所以cpu核心数并不是越多越好的，需要软件硬件的结合。</p>
<p><code>接口类型</code>：这个一般不关注，不同的接口类型是互不兼容的，也就是插不上去不能用，我们需要关注的是主板是否适合cpu的接口即可。</p>
<p><code>主频</code>：Intel给了一个公式，<strong><em>CPU性能＝IPC×频率</em></strong>，IPC是 <strong>Instruction Per Clock</strong>，也就是cpu每一个时钟周期可以执行的指令多少，这个越高cpu就越快；而频率就是主频，代表一秒可以跑多少个时钟周期，在IPC相同的前提下，主频越高单核性能越强。但是不同型号cpu的主频是无法直接比较的，因为不同代的cpu架构不一样，这会使得IPC、指令集等都不一样，有些老cpu主频也可以很高很高，但是实际上还不如最新一代架构但是主频更低的cpu来得性能好。</p>
<p><code>缓存</code>：cpu缓存分为好几级，现在一般都分为3级，可不要小看这里的缓存怎么才几个MB那么少，L1级缓存的速度可是比内存快上<code>100倍以上</code>，让我们来直观地来看看下面的表格，参考自<a href="https://www.prowesscorp.com/computer-latency-at-a-human-scale/" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>实际耗时</th>
<th>cpu的感官体验</th>
</tr>
</thead>
<tbody><tr>
<td>一个cpu周期</td>
<td>0.4ns(纳秒)</td>
<td>1s(标准数据)</td>
</tr>
<tr>
<td>读取L1级缓存</td>
<td>0.9ns</td>
<td>2s</td>
</tr>
<tr>
<td>读取L2级缓存</td>
<td>2.8ns</td>
<td>7s</td>
</tr>
<tr>
<td>读取L3级缓存</td>
<td>28ns</td>
<td>1 min</td>
</tr>
<tr>
<td>读取内存</td>
<td>~100ns</td>
<td>4 min</td>
</tr>
<tr>
<td>NVMe接口固态硬盘读写</td>
<td>~25μs</td>
<td>17 h</td>
</tr>
<tr>
<td>普通固态硬盘读写</td>
<td>50-150μs</td>
<td>1.5 - 4 days</td>
</tr>
<tr>
<td>机械硬盘读写</td>
<td>1-10ms</td>
<td>1 - 9 months</td>
</tr>
<tr>
<td>从San Francisco到New York City的一次网络通信</td>
<td>65ms</td>
<td>5 years</td>
</tr>
<tr>
<td>从San Francisco到Hong Kong的一次网络通信</td>
<td>141ms</td>
<td>11 years</td>
</tr>
</tbody></table>
<p>cpu的运行速度实在太快了，内存、硬盘、网络三人哭着表示大佬求你别跑了我们跟不上🤣。在cpu看来这3个东西实在太慢了，要是每次都要我去等那我不就废了？于是产生了cpu缓存，cpu从缓存里拿数据的速度非常快，可以大大减少cpu因为等待内存、磁盘、网络响应导致cpu空转原地踏步而浪费性能的时间。所以现在知道这个缓存的重要意义了吧？<code>cpu缓存越大越好！</code></p>
<p><code>功耗</code>：这个参数相对来说比较玄幻，有一定的参考意义，<code>一般来说当然希望功耗越低越好，功耗低发热就少，而且省电</code>。一般同性能等级Intel的cpu功耗要比AMD的cpu低出不少，而功耗过高就要额外考虑cpu的散热问题。</p>
<p>再补一个AMD官网拿过来的<code>AMD r7 2700X</code>的数据，可以看看官网的数据是怎么写的 (长年有道词典在手🤣)，注意TDP，这个参数是功率的参考参数，一般还是要以实际测试为准。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD-r72700x-official.png" alt="AMD锐龙7 2700x官方数据"></p>
<hr>
<blockquote>
<h4 id="哦，看完参数啦？不太懂……"><a href="#哦，看完参数啦？不太懂……" class="headerlink" title="哦，看完参数啦？不太懂……"></a>哦，看完参数啦？不太懂……</h4></blockquote>
<p>看完上面的cpu科普后，是不是依然不得要领，是不是感觉没有找到一个参数能作为cpu对比的靠谱指标呢？那就对了😂。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/Confused_Young.gif" alt="What 7 you say?"></p>
<p>其实上面的cpu数据一般都不会拿来直接对比的，只有在高玩的眼里这些参数才会有足够的参考价值，一般人嘛，只要不是想着买万元土豪机或者工作站什么的，都是不太需要关注这些数据的啦，我们需要什么？是真实测试的cpu性能数据！有这个需求就就产生了cpu天梯图 (另外各大视频弹幕网站里的各种cpu测评也是很有参考价值的)。</p>
<p>百度搜索<a href="https://www.baidu.com/s?wd=cpu天梯图" target="_blank" rel="noopener"><strong><em>cpu天梯图</em></strong></a>，有不少别人已经整理好的图表，非常直观，建议多看两张进行对比，毕竟这些图表都是相对主观的个人编辑，会存在一些作者偏爱什么的，举个例子比如下面这张，而且要注意图表制作的时间，现在是2019年，你再拿2017年的天梯图看已经没有任何参考意义，因为市场在售产品已经完全更新换代了：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/CPU_ladder_201904.jpg" alt="转载自 http://www.365pcbuy.com/article-411.html"></p>
<p>专门的电脑配置百度贴吧里也有不少高玩潜伏，多在贴吧里混一下可以给新手带来十分可观的知识量哦。</p>
<p>面对cpu天梯图，分为Intel和AMD两个阵营，从高至低有一个直观的cpu性能排行榜，可以在JD或Tmall上分别搜索一下<code>排在前头的</code>，<code>排在中间的</code>和<code>相对靠后</code>的cpu的价格，体会梯度之间的差距。</p>
<p>看着天梯图应该是能注意到cpu的命名是有模式的，先说Intel阵营，以<code>i7-9700K</code>举例子，<a href="https://www.intel.cn/content/www/cn/zh/processors/processor-numbers.html" target="_blank" rel="noopener"><strong><em>这个链接是Intel对于型号的官方解释</em></strong></a>：</p>
<ol>
<li><code>i7</code>代表型号，相同后缀4位数前提下，越高越好.</li>
<li><code>9700K</code>需要拆分，第一位代表第几代cpu，代数越大，架构更优。i7-4770K &gt; i7-3770K</li>
<li>第二位代表处理器等级，数字越大，性能越好。i5-8500 &gt; i5-8100</li>
<li>第三位代表核心显卡，可忽略不比。</li>
<li>第四位代表功耗，可忽略不比。</li>
<li>第五位英文字母含义可多了，这里就不全列了。H、M、U从高到低代表功耗，一般是笔记本电脑上的cpu会用到；K、S、T也是功耗从高到低，功耗越大性能就会越好，而且K代表不锁频，意味着可以玩<code>cpu超频</code> (后面解释)；X代表顶级cpu。</li>
</ol>
<p>然后是AMD阵营，这里只讲解锐龙产品线，看<code>Ryzen5 r7 2700x</code>，Ryzen3 (r3)、Ryzen5 (r5)、Ryzen7 (r7) 感官上对标i3、i5、i7。接下来一图胜千言，跟Intel差不多套路：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/AMD_cpu_name.jpg" alt="转载自 http://www.chinaaet.com/article/3000060423"></p>
<hr>
<blockquote>
<h4 id="不同牌子cpu有什么特点，适合什么工作？"><a href="#不同牌子cpu有什么特点，适合什么工作？" class="headerlink" title="不同牌子cpu有什么特点，适合什么工作？"></a>不同牌子cpu有什么特点，适合什么工作？</h4></blockquote>
<p>相比而言，AMD的cpu性价比要稍稍高一些 (反正我是偏爱AMD的嘿嘿嘿😝)。网上流传的是普通电脑用Intel cpu，专门的图像处理、电脑用AMD cpu。</p>
<p>不同的牌子cpu适合什么类型的工作，分别有什么特点</p>
<p>这里可以列举一些场景所对应的性价比高的cpu：</p>
<ol>
<li>单纯需要普通office办公、上上网、看看视屏、播放电影音乐的用户，建议<code>i3-8100</code>，也适合拿来玩烂大街的小网游如DNF、CF、LOL等，不需要买独立显卡。</li>
<li>适度游戏益智类的用户，玩玩几年前的大型单机游戏，放在2019年来说，玩玩孤岛惊魂系列、孤岛危机系列、使命召唤系列、古墓丽影、黑魂啊啥啥啥的，只要特效调节合理都没问题，也包括一般强度的视频图像剪辑、跑代码计算等，写这篇文章的时候我特别偏爱AMD的<code>r5 2600x</code>。</li>
<li>土豪装备，玩当前流行的3A大作全特效，并且希望一步到位在四五年后依然可以玩最新最吃配置的游戏，不要给我说什么性价比、什么架构、什么核心数，老子装电脑就是一把梭，哪个最贵买哪个🤦‍♂️。截止至2019年5月1日，PC (不算工作站cpu)最好的cpu应该是Intel<code>i9-9900K</code>，JD在售4300RMB，妈呀这价钱都能组装一台不差的台式机了。</li>
</ol>
<p><code>i3-8100</code>是一个普适的cpu，性能表现良好，很多装机老司机都推荐，只要是一般工作娱乐机，上上网看看视频玩玩低配网游如英雄联盟，一个<code>i3-8100</code>即可流畅运行，性价比十分高。<code>r5 2600</code>也是一个不错的选择，AMD的cpu超频空间相对较大，不少人买<code>r5 2600</code>回来超频用。其实一切都得要看需求，什么样的需求决定用什么性能层级的cpu，只言片语是无法决定的，需要多搜资料考察，多看看别人的装机性能测评，这样自己就会慢慢有概念，了解什么样的cpu能handle什么样的工作场景。举个例子，AMD的锐龙cpu后缀不带G都是没有核显的，你可以理解为买这样的AMD cpu可以省下核显的钱，尤其是你有强大的独显根本不用核显那么点性能的场景下，而Intel cpu后缀带F则代表无核显，基本上Intel的cpu都是有核显的，虽然现在它的核显性能越来越好 (Intel cpu在功耗和温度上吊打AMD cpu)，但是买高配机，压榨配置预算换取最高性能的条件下，一部分钱捐给了这个无用的核显 ，就显得钱花得不那么值了(都买了很牛逼的独显，要核显干嘛？</p>
<p>接下来对比一下Intel和AMD的cpu，信息翻译自这个<a href="https://www.digitaltrends.com/computing/amd-vs-intel/" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>：</p>
<p>再次来对比Intel和AMD，在中端和低端领域，AMD能给到的性能和价格都更加理想，Intel cpu有更强劲单核性能和游戏表现 (不过一般cpu都不会是游戏的瓶颈，更多时候是显卡)，而AMD的线程撕裂者cpu则适合需要多线程协同工作的场景。</p>
<p>这里额外科普一下主频和线程数在cpu中的概念，参考自<a href="https://www.pc841.com/article/20180522-89740_all.html" target="_blank" rel="noopener"><strong><em>CPU知识科普：秒懂主频、核心、线程、缓存、架构</em></strong></a>：</p>
<p>可以将主频想像成一只粗壮的手臂，线程数想象成手臂的数量。</p>
<p>对于需要粗暴计算的游戏场景，主频高的cpu更有优势，这就好比我的工作是搬砖，肌肉强，力气大才是硬性需求 (主频高)，就算我有8条胳膊16只手 (线程数多)，看起来张牙舞爪很厉害，但是我搬砖的时候根本用不到，这些胳膊大多力气小，所以效果并不会很好。</p>
<p>对于图形渲染等专业工作需求，需要进行大量并行计算，多核心多线程同时工作能比少核心高主频的傻大粗节省大量时间。绿巨人虽然搬砖能力出众，但是如果让他去完成一副复杂的拼图，速度自然是比那种有多条胳膊和多只手同时工作的小机灵慢了不少。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/intel&amd.png" alt="两家各有卖点"></p>
<hr>
<blockquote>
<h4 id="超频，核显分别是什么？"><a href="#超频，核显分别是什么？" class="headerlink" title="超频，核显分别是什么？"></a>超频，核显分别是什么？</h4></blockquote>
<p><a href="https://www.gcores.com/articles/105781" target="_blank" rel="noopener">超频</a>一般是高玩的手法，普通玩家就不要管什么超不超频的了，远离超频珍爱生命，超频的具体定义是：</p>
<p>通过BIOS或者软件将CPU的工作频率设定高于基准频率，CPU能够稳定在这个高频率下运行时可以加快计算机的处理速度。换句话说，超频也就是调整硬件设置让CPU芯片稳定运行时的频率更高的技术手段。可以看看这个<a href="https://www.expreview.com/tag/chaopin.html" target="_blank" rel="noopener">链接</a>补充一下。</p>
<p>可以说超频就是将到手的cpu零成本提升性能的手段 (当然超频除了cpu之外，内存、显卡、甚至显示器都能给超频来获取突破基准的额外性能)。</p>
<p>放在大几年前，超频可能是穷人的玩法，但是放到了现在，超频一般是有钱人或者电脑爱好者拿来折腾的玩法，已经开始变味了 (神tm液氮干冰超频了解一下🙃)。cpu出厂分好坏，有些cpu体质好，能超频超到比较高或者同等电压下就可以达到更高的主频，有些cpu只能超一点点，稍微多一点就不稳定。每个cpu能超频的幅度都不一样，你买到的cpu也分大雕和打雷😆。</p>
<p>超频是一个调试过程，分为软件超频和硬件超频（软超和硬超），一般更偏向于一次性设置便可以不再管的bios硬超，软超每次开机都需要重新配置参数很麻烦。硬超简单来说就是在bios调节各种参数，给cpu加电压，进入系统拷机测试 (<strong><em>拷机就是使用特定软件制造出庞大的运算负载，以此来检测CPU、内存、显卡在极限负载下的超频效果是否稳定，如果拷机过程中死机、黑屏、驱动重置，则代表超频失败，需要降频，重复上述过程</em></strong>)。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/liquid_nitrogen.jpeg" alt="液氮超频"></p>
<p>当然cpu频率上去了，性能也上去了，也不知道谁说的😆，P=U×V，cpu电压给加上去了，发热必须得增加啊！对于cpu甚至全部硬件来说，温度就是<strong><em>生命</em></strong>，所以极限超频都判随着很高的散热要求，如果cpu（无论任何硬件都一样）在过高温下长时间工作，轻则宕机，重则造成硬件永久性的损坏，降低硬件寿命和性能，这也是为什么建议普通玩家不要瞎超频，入坑深似海。</p>
<p>顺带科普一下，intel cpu不是全部都能超频的，只有后缀K的型号（当然比不带K的更贵）并且配合支持超频的主板才满足超频的前提。这里给出一个公式：<strong><em>主频＝倍频×外频</em></strong>，所以超频分为超倍频和超外频，超倍频是cpu自己的事，最坏的情况就是cpu超坏了，而外频和主板上其他所有东西都是关联的，如PCI-E接口频率、总线频率、内存频率……牵一发而动全身，超外频意味cpu和它周边所有硬件包括内存、硬盘、显卡等跟着一起超频。cpu、显卡、内存这些比较耐艹，但是硬盘可是很脆弱的东西，经受不了折磨，数据物价，超坏了硬盘导致数据资料全没了，损失分分钟比坏一个cpu还高哦。所以一般超频都会选择超倍频，而intel不带K型号的cpu是<strong>锁倍频</strong>的，意味着你没法超倍频，真的要抄只能冒险超外频。可以参考链接：<a href="https://baijiahao.baidu.com/s?id=1619727719362104239&wfr=spider&for=pc" target="_blank" rel="noopener">认识外频和倍频</a>。</p>
<p>我们一般看到的intel cpu主频参数是基准频率，实际上cpu在运行时是主频是动态变化的，核心电压也是动态变化的，这里引申出intel的睿频技术，可以根据不同的任务负载智能提高cpu主频，比如我的主机用了intel的cpu <code>e3 1230v2</code>，我观察到机器在空闲时cpu频率会掉到1500+Mhz，偶尔会上到3600+Mhz，所以我在windows<code>我的电脑-&gt;右键属性</code>上看到cpu后面跟着两个频率，一个是3.3Ghz，一个是3.7Ghz。当然这个睿频最高频率只是单核能达到的最高频率，而在多核情况下，核心之间需要保持数据一致性、共用cache、TDP设计等原因，是不可能所有核心同时都达到最高睿频的（AMD当然也有类似的技术）。</p>
<p><a href="https://baike.baidu.com/item/核心显卡" target="_blank" rel="noopener">核显</a>就是<code>核心显卡</code>，是指cpu内置的显卡，区别于独立显卡 (也就是一整块额外买的显卡)，高端cpu的核显吊打垃圾独显，核显相比于独显，功耗低、性价比更高，只是性能有限，没办法玩得动大型游戏or大型图像处理工作。如果只是日常办公的一般需求，核显性能也可以满足要求，显然性价比更高。</p>
<blockquote>
<h4 id="cpu会不会有假货？"><a href="#cpu会不会有假货？" class="headerlink" title="cpu会不会有假货？"></a>cpu会不会有假货？</h4></blockquote>
<p>市面上在售的cpu分为2种：</p>
<p><code>盒装cpu</code>，定位是零售商品，面向市面普通个体用户，官网叫做box，是有序列号有保修服务的。以Intel举例，在Intel官网可以通过序列号查到cpu，也可以看到保修状态，Intel cpu的质保服务是3年内出现非人为损坏免费换新。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/box_cpu.jpg" alt="盒装cpu"></p>
<p><code>散片cpu</code>，定位是批发商品，官网叫做tray，面向企业以批发价出售。这些散片cpu到了企业手上由于各种原因再流向普通市场，就是我们看到的散片cpu。举个例子，个人零售价一个cpu 100美元，现在hp这种买品牌机的厂商向Intel进货cpu 10万个，批发价每个cpu 95美元，后来hp发现自己的品牌机销量不够，cpu 10万个用剩1万个，怎么办？聪明的你肯定想到将cpu偷偷卖给市面上的个体用户 (Intel肯定是不乐意的，但是也放任不管)，诶我不用压价卖，95美元单价一个买回来，我现在96美元一个卖出去，对于企业来说还是有得赚的，个体用户也省钱，岂不美哉😏。当然散片缺少盒装cpu赠送的散热风扇，也不排除是走私水货或者从别的电脑上拆下来的cpu，Intel是不负责保修的，有可能是经销商负责保修服务。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/tray_cpu.jpg" alt="散片cpu"></p>
<p>那你可能问，cpu会不会像其他货物一样出现假货呢？</p>
<p>首先答案是【cpu不存在假货】，这么精密的东西，你要是能造假cpu，国家还不赶紧投几百个亿让你继续研究cpu造着去，至于cpu有多精密，可以看看这个<a href="https://www.bilibili.com/video/av22544389" target="_blank" rel="noopener"><strong><em>链接</em></strong></a>。</p>
<p>可能这里的cpu造假概念不太一样，也还是有一些手段来欺骗消费者的，如：</p>
<ol>
<li>就是<strong><em>换盖</em></strong>，CPU的型号是刻在顶盖上的，所以造假方法就是给垃圾CPU换个牛一点的顶盖吓唬别人。比如核心是i3，换成i7的顶盖，当i7卖。这种你一开机就知道了，设备管理界面，或者各种检测软件都能看到。</li>
<li>用机器把原来的型号打<strong><em>磨掉</em></strong>然后刻上新的型号，这个和第一种差不多，纯粹的物理手段改变外观型号，本质上没改，所以一开机看一下参数就知道了。</li>
<li>用<strong><em>remark</em></strong>直接修改CPU参数，但是这种参数修改只能骗骗windows，用<strong><em>CPU-Z</em></strong>一查就能查到，还有windows自带的注册表管理修改，也可以从软件层面达到更改CPU型号的目的，但是用别的软件都能查到。</li>
<li>整机销售一般惯用套路，就是机器买来系统是装好的，桌面有个鲁大师用来看配置，那么直接把这个<strong><em>鲁大师改掉</em></strong>就好了，你换个别的检测软件就能查出来了，这个套路闲鱼非常多，希望各位看到什么2999就i7 32G内存的机器，切记要小心，贪过分便宜你就要付出代价。</li>
<li>将CPU的<strong><em>测试产品</em></strong>或者<strong><em>残次品</em></strong>当成正品卖。CPU生产成正式商品之前需要先通过测试版本，测试版本相对于正式版没有那么稳定，很有可能会出各种BUG，有的测试版本在CPU-Z是不显示型号的，而有的测试版本是会显示型号的，这时候你看一下<strong><em>步进</em></strong>是什么水平就能知道他到底是不是测试版了 (CPU生产会先生产测试产品，步进就代表它属于什么阶段的产品了，越先进的步进越接近零售产品)。而残次cpu可能出现的情况就是掉电容、缩肛 (超频超坏了，频率往下掉)、剪角、单通道、坏核显等 (cpu摔了也会坏的)……</li>
</ol>
<p>剪角cpu，注意左上角被剪，cpu<strong>可能会</strong>损失一部分性能或功能，属于残次品。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu_imperfect.jpg" alt="剪角cpu"></p>
<p>总的来说，如果在保修的不那么重要的前提下，散片的价格优势太明显，一般组装电脑更推荐买散片，至于散片在JD、Tmall这种正规市场是基本没有的，在某宝就有很多，可以挑选销量高评价高的购买，只要不是运气太足够买彩票，一块cpu正常用上五六年都不会有任何问题。</p>
<blockquote>
<h4 id="其他趣事"><a href="#其他趣事" class="headerlink" title="其他趣事"></a>其他趣事</h4></blockquote>
<p>关于cpu的东西，差不多就这样了，可以给大家说说cpu的一些趣事。</p>
<p>首先介绍一下AMD的别称，一叫<code>农企</code>，二叫<code>按摩店(An|Mo|Dian)</code>。虽然AMD是Advanced Micro Devices的缩写，但由于多年以来产品性能不给力，广大粉丝宁愿相信AMD是来自于缩写Agriculture Machine Devices（农机设备），Agriculture Machine Department（农业机械部）。而且巧合的是，之前AMD的推土机系列处理器命名采用了全套农机设备不是跟你开玩笑的：推土机（一代）、打桩机（二代）、压路机（三代），这无异于官方默认玩家的爱称，这更加坐实了农企的称号是非常科学的🤣。</p>
<p>Intel别称是<code>牙膏厂</code>，前几年时间由于AMD的cpu一直被Intel吊打，AMD被打得苟延残喘，甚至产生了<code>i3战A8，i5秒全家，i7轰成渣</code>的调侃说法（感兴趣的可以自己了解一下15年cpu天梯图），那时候Intel处理器长期保持在一个8、9%的性能提升节奏上，根本不怕AMD赶上来。Intel的cpu技术升级缓慢，更新迭代如同挤牙膏一般，所以广大玩家给Intel起名牙膏厂。</p>
<p>Intel为了赚取更多的利润和降低研发投入，仅需每年做一点提升就能始终保持主流芯片的龙头地位，这样既不需要重新规划产品架构，也不需要投入过多研发实力，还能持续获得利润，这不就是企业最想得到的商业结果吗？躺赚！当然Intel也不傻，这样每年就节约了很大一部分开支用来做未来的技术储备，当市场有威胁其地位的新品出现时，就可以随时进行反击，怎么想都是美滋滋的，何乐而不为？</p>
<p>这两三年AMD推出性能提升52%的Ryzen系列处理器，网友就炸锅了，大有翻身做主重振雄风之势，英特尔马上就采取了行动推出了i9，Intel依然保持着一定的优势，只是远远没有以前那么大了，浪多了还是得稳一波。</p>
<blockquote>
<h4 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h4></blockquote>
<p>cpu本身肯定是有接口类型区分的，不同的cpu只能在不同主板平台上运行，并不是一颗cpu什么主板都能给嵌上去。intel不同的针脚数就是不同的平台，而AMD有Socket AM4等接口类型定义。cpu上每一个针脚位都有固定的含义，如下图：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu_pins.jpg" alt="cpu针脚定义图"></p>
<p>cpu硬改是通过加一层中间层来屏蔽针脚或者调换针脚定义的黑科技手段，具体可参考链接<a href="http://www.21ic.com/news/mcu/201810/838733.htm" target="_blank" rel="noopener">硬改CPU黑科技是啥？</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/55724462" target="_blank" rel="noopener">硅脂U和钎焊U</a></p>
<p>入门概念介绍这么多也足够了，我水平有限，剩下更多的知识需要大家多混论坛贴吧长知识甚至实操才能有所体会了😄。</p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>电脑配件</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程下的单例模式</title>
    <url>/2019/04/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式可能是应用得最广泛的设计模式之一，也是学习设计模式必学、面试必问的模式之一🤣，那么就很有必要搞清楚单例模式是一个什么东西了。这里着重讨论一下多线程下的单例模式，<a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">Singleton（单例模式）</a>的基本概念就不再展开了。一般来说，应用单例模式的场景为要求全局只存在一个单例类的实例，如果该单例类产生了多个实例可能会对系统造成影响或损害，需要限制为1个。</p>
<blockquote>
<p> It ensures that the Singleton class has only one instance and provides a global access point for it. We can use a Singleton when the presence of multiple instances can potentially damage the system, and we need global access to the single instance. </p>
</blockquote>
<a id="more"></a>

<h3 id="单例模式的经典实现"><a href="#单例模式的经典实现" class="headerlink" title="单例模式的经典实现"></a>单例模式的经典实现</h3><p>我们可以来看一下最经典的例子，以伪代码（接近java，get到意思就好😂）展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以说是单例模式最直接的实现了，private修饰构造函数导致外部无法通过<code>new</code>关键字来实例化对象，需要实例化Singleton或者获取Singleton实例必须调用提供的唯一接口<code>getInstance()</code>，对外界调用起到限制。调用<code>getInstance()</code>时首先会检查Singleton对象是否已被初始化，再返回对象实例，另外，Singleton实例只有在第一次调用<code>getInstance()</code>时才会真正初始化，也就是说只有在真正使用的时候才生成实例，这叫做<code>懒加载(lazy initialization)</code>，可以提高系统启动速度，也更加适合在资源有限的系统中运行。</p>
<p>上面的经典实现有十分明显的问题，<strong>它不是线程安全的（not thread safe）</strong>，具体可以看下面的场景：</p>
<ol>
<li>在需要实例化Singleton时，<strong>线程A</strong>进入<code>getInstance()</code>，此时<code>_instance == null</code>为<code>True</code>，<strong>线程A</strong>会进入if分支。</li>
<li>在<strong>线程A</strong>执行初始化代码<code>_instance = new Singleton()</code>之前，发生一次线程切换，<strong>线程A</strong>挂起，切换到<strong>线程B</strong>，并且<strong>线程B</strong>也调用<code>getInstance()</code>。</li>
<li>对于<strong>线程B</strong>来说<code>_instance == null</code>也是为<code>True</code>，因为<strong>线程A</strong>根本还没生成Singleton实例，<strong>线程B</strong>进入if分支。</li>
<li>最终结果就是<strong>线程A</strong>与<strong>线程B</strong>都在if分支里，两个线程都会生成一个Singleton实例，此时系统就有两个Singleton实例。</li>
</ol>
<h3 id="简单粗暴地解决"><a href="#简单粗暴地解决" class="headerlink" title="简单粗暴地解决"></a>简单粗暴地解决</h3><p>怎么样可以防止生成多个Singleton实例呢？很容易，把懒加载去掉就好：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放弃懒加载的特性，这种实现会在类加载的时候就生成Singleton实例，并且保证线程安全。如果Singleton实例生成的代价低、性能影响小，或者这是最合适的一种实现，因为它简单并且安全。</p>
<h3 id="添加锁🔐"><a href="#添加锁🔐" class="headerlink" title="添加锁🔐"></a>添加锁🔐</h3><p>但是我们还是想要懒加载要怎么改？一般方法是添加锁来保护Singleton实例化过程，保证只有一个线程可以进入实例化流程（enter crtical section），实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire_lock();</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    release_lock();</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现也可以保证线程安全，<strong>线程B</strong>不可能在<strong>线程A</strong>完成Singleton实例化之前接触到if判断分支，即使<strong>线程A</strong>在if分支里被切换，其他线程也因为等待锁都被阻挡在<code>if (_instance == null)</code>之前。但是这个实现的致命弱点是对性能影响很大，因为每一次调用<code>getInstance()</code>时都要获取锁，特别是当多个线程一起调用<code>getInstance()</code>的情况下，线程之间会因为竞争锁而被阻塞，当调用足够频繁的时候，系统对外的表现可会是经常卡一会没响应，或者整体的运行效率降低，看起来这样的实现也不太好。</p>
<h3 id="添加锁之前先check"><a href="#添加锁之前先check" class="headerlink" title="添加锁之前先check"></a>添加锁之前先check</h3><p>认真观察添加锁的实现会发现，其实添加锁只是为了安全地进行对象实例化，一旦<code>_instace</code>被实例化后，这把锁🔐就再也不需要了，但是上面的实现是每一次获取实例都去获取一次锁。有没有办法只让锁获取一次就好了？我们意识到锁只是在第一次获取的时候（第一次调用，实例化对象时）才产生意义，所以if判断可以提前到获取锁之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        acquire_lock();</span><br><span class="line">        _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        release_lock();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来好像很机智的样子🎉，我们可以只在首次调用<code>getInstance()</code>时才获取锁，往后因为<code>_instance</code>不为<code>null</code>所以都不用获取锁了，然而实际上行不通，为什么呢？当线程A进入if判断但是在获取锁之前被切换线程，线程B此时也可以进入if判断，会发生两个线程进入if判断的情况，后面就会生成多个Singleton实例，没错，坑就坑在线程可能随时被切换。</p>
<h3 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h3><p>能解决上面的问题吗？还是可以的，我们可以额外添加一个if判断来防止重复进入实例化代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        acquire_lock();</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        release_lock();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码估计是最常见的double-check单例模式实现了，看起来可以有效防止上面提到的问题，即使有多个线程同时进入第一个if判断，在Singleton实例首次被生成之后，后面的线程在critical section里也不会再重复实例化对象了，因为还有第二个if判断在里面。</p>
<p>真的是这样吗？就这样完了？并不是🙃，还有坑。</p>
<h3 id="编译器优化问题"><a href="#编译器优化问题" class="headerlink" title="编译器优化问题"></a>编译器优化问题</h3><p>上面的实现不能保证100%的线程安全，原因是存在编译器优化。现代编译器都太先进了，它们会按照效率更高的方式进行指令重排，会充分利用寄存器和流水线以最高并行度去运行指令（现在已经是多核时代，一台机器上不再是一个CPU而是多个CPU，多个CPU在数据不互相干扰的情况下可以也同时独立运行指令）。一个具体例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>

<p>我们人眼认为a是先于b被声明初始化的，最后c再被计算，但是对于编译器，它可以向我们保证c最后计算出来等于30，也会保证在c计算出来之前a和b都被正确声明和赋值即a肯定等于10，b肯定等于20，但是它不保证的是<strong><em>到底a先被声明赋值还是b先被声明赋值</em></strong>，有可能是先b再a，也有可能是先a再b，我们无从猜测，所以我们也不能指望它可靠。</p>
<blockquote>
<p>这里引申出另一个问题，<code>_instance = new Singleton();</code>实例化操作到底是怎么被运行的？</p>
</blockquote>
<p><code>_instance = new Singleton();</code>并不是一个原子操作，它被执行时是分为3个步骤的：</p>
<ol>
<li><p>一块特定的内存被分配出来给Singleton对象使用。</p>
</li>
<li><p>这块内存会被赋值初始化，此时Singletom对象已经能用了。</p>
</li>
<li><p>这块内存（Singleton对象）的引用赋值给<code>_instance</code>。</p>
<p><code>_instance</code>指向Singleton实例的内存，实际上只有这块内存被完整初始化之后，<code>_instance</code>才是一个正确可用的实例（<code>_instance</code> is valid only when the initialization is complete）。这里可能出现的问题是编译器将这3个步骤打混了，假如<strong>线程A先执行步骤1和3，在没来得及执行步骤2的时候发生线程切换</strong>，对于线程B来说，<code>_instance</code>已经不为<code>null</code>了，就屁颠屁颠拿去用了，但是实际上<code>_instance</code>指向一块还没有被初始化的内存，如果线程B拿这个对象去使用会引发各种谜之bug甚至出现系统崩溃。</p>
</li>
</ol>
<blockquote>
<p>如何解决这个问题？</p>
</blockquote>
<p>我们只需要将实例化对象那一行代码的运行顺序摆正就好了，换个说法就是避免编译器的优化：</p>
<ol>
<li><p>在C++和Java中存在关键字<code>volatile</code>，也就是<code>private volatile Singleton _instance = new Singleton();</code>，它可以使编译器不去做激进的优化，保持原来的执行顺序不变，不过这个关键字某种程度上也会影响整个系统的性能，毕竟变量变成<code>volatile</code>后即使实例化完成后，每次去对象都不去寄存器快速取出来而要去内存取。（<code>volatile</code>这个关键字坑很多，最好还是不要乱用）</p>
</li>
<li><p>使用<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障</a>来迫使完全实例化之后再改变flag的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            acquire_lock();</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                memory_barrier();</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            release_lock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有内存屏障的存在，可以保证<code>flag = true;</code>这句代码不会被编译器优化执行顺序，也就是一定会完成<code>_instance = new Singleton();</code>之后，flag变量才会变为true，所以flag就是<code>_instance</code>已经被正确初始化的标志，if直接判断flag变量即可。如果将<code>flag = true;</code>放在内存屏障前面行不行呢？那是不行的，因为可能被编译器优化之后flag变量甚至会在<code>_instance</code>正确实例化之前就被置为true。然而内存屏障也需要编译器的支持，否则可能很难使用内存屏障，甚至需要写上汇编代码。</p>
</li>
<li><p>最后一种是针对Java的实现，详见<a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" target="_blank" rel="noopener">Initialization-on-demand holder idiom</a>。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面提到的所有实现，都没有找到尽善尽美可以运行在所有平台/编译器的方式。可能最后的解决方案就是放弃懒加载，权衡性能和安全。如果我们想坚持使用懒加载同时保证线程安全，性能会因为锁的获取受到影响（<a href="#添加锁🔐">full locking</a>版本），当然还是有一点小手段可以优化——尽量减少<code>getInstance()</code>的调用次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用三次getInstance函数，也就获取了三次锁</span></span><br><span class="line">Singleton.getInstance().method1();</span><br><span class="line">Singleton.getInstance().method2();</span><br><span class="line">Singleton.getInstance().method3();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 只调用一次getInstance函数，获取一次锁，性能更好</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">instance.method1();</span><br><span class="line">instance.method2();</span><br><span class="line">instance.method3();</span><br></pre></td></tr></table></figure>

<p>虽然这并没有解决问题，但是确实可以在性能上有所提高。</p>
<p>Singleton设计模式从来就不是一个简简单单的设计模式，在不同场景下，每一种设计模式都需要进行演变来应用，分清每一种实现的好坏，挑一种最合适业务场景的实现进行应用，这才是代码功力和业务理解能力💪。</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>violate关键字对单例的影响</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://taskinoor.wordpress.com/2011/04/18/singleton_multithreaded/" target="_blank" rel="noopener">墙裂推荐阅读：Singleton in multi-threaded environment</a></p>
<p><a href="https://www.cnblogs.com/god-of-death/p/7852394.html" target="_blank" rel="noopener">C/C++ volatile关键字深度剖析</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">LINUX KERNEL MEMORY BARRIERS</a></p>
<p><a href="http://ifeve.com/disruptor-memory-barriers/" target="_blank" rel="noopener">Dissecting the Disruptor: Demystifying Memory Barriers</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>多线程</tag>
        <tag>代码实现</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>感情问题的小总结</title>
    <url>/2019/03/29/%E6%84%9F%E6%83%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这是8个多月来我记录下的第16次较大的矛盾了，不包括一些及时解决的小问题。你懂的，大矛盾时时伴随着泪水，我的也好她的也好，我这流眼泪的次数远远大于初中+高中+大学的总和了，现在回头总结一下，其实归根到底都是一个原因：<font color="red"><strong>沟通不充分</strong></font>。</p>
<a id="more"></a>

<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>回顾最近跟妹子发生的一个矛盾，事件背景是我们打算一到两个月后开始同居生活，按照想法准备找一室一厅的房子租下来，期间也到现场看过两次，矛盾的导火索是之前我同事介绍的一个房子我们都喜欢，但是最后被别人放了鸽子，因为全程都是我对接沟通的，她看起来几乎没有怎么贡献过，让我觉得她一点积极性都没有，派不上用场。</p>
<p>当然她要反驳，毕竟我说的是有点夸张，她期间也会在app看房子，跟我讨论房子好不好，也一起商量出找房子的范围，还有跟进中介发出来的房源，被我这样说得分文不值，开心是不可能的。</p>
<p>在我的立场，最近学习劲头特别足，我越来越不想被其他乱七八糟的事情打扰我的学习计划，但是从开始找房子到现在我都感觉是我自己lead整个流程，沟通、安排、跟进几乎都是我一个人在做，让我的怨气积累得越来越多，最后在她面前释放了出来（当然这里有个问题就是房子是我的同事介绍的，对接工作我来完成也是理所当然）。</p>
<p>周日晚上我坐了40分钟的地铁过去找她吃饭，她提起房子被放鸽子的事情，让我的情绪和不满爆发了出来，矛盾出现之后一路上都不说话，两个人虽然并排走路，但是气氛死僵很难受，人在身边心在千里，一刻都不想呆，我有种立马想调头回去的冲动。最后一起随便吃了个沙县继续散步一点一点把压在心里的怨气互相发泄出来后矛盾才算解决了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/sorrow.jpg" alt="sorrow"></p>
<h3 id="侃大山"><a href="#侃大山" class="headerlink" title="侃大山"></a>侃大山</h3><p>矛盾不是第一次了，这么多次下来，我和她的脾性其实都已经掌握得七七八八了。我在有情绪的时候往往不喜欢说话，她也是，所以两个人都不会先挑起话匣子解决气氛问题，在这样的氛围下两个人都会十分难受，所以每次解决矛盾之前总要经历一下这样的痛苦😔，时间从十几分钟到几十分钟不等，贼蛋疼。</p>
<p>我虽然是个男生，而且以前没有恋爱经历，然而在感情上却是一个极限容易感受到细节的人，有时候因为爱得深所以也想的多，往往就会想歪了自己伤自己，而她是认为自己没错就跟你死倔的类型，在某些时候脾气会十分暴躁，我曾经被她莫名其妙凶了一两次。怎么说都好，两个人在感情方面毕竟经验都十分有限，我是初恋，她的感情经历也没多少，所以两个处理手法极其原始的人在矛盾下往往都会手足无措只能互相生闷气，沟通不知道怎么沟通，安慰也不擅长，更加可怕的是一些很危险的时刻随便说一句话可能对方就当真然后立马翻脸。</p>
<p>她说，很多时候我们两个人的角色仿佛互换，我更像一个女生，整天嘤嘤嘤动不动就流眼泪，她就扮演男性角色来安慰我。想不到我光明磊落堂堂猛男竟然在感情面前是这个死样🤣。我的爱情观不知道是不是特别奇怪，反正就跟其他男生不太一样吧（以下只是为了说明清楚才加上序号的，并不代表我斤斤计较）。</p>
<ol>
<li>这个社会给男女恋爱定下来太多规则，特别是网络上一些歪歪扭扭的爱情观，凭什么男生在感情面前一定要无条件大气、包容女方？</li>
<li>爱情讲究什么？互相付出。男生比女生付出多一些无所谓，但是为什么男生总要先付出才能获得回报，为什么一定事事都要男生主动？</li>
<li>女生是不是看霸道总裁看狗血爱情剧多了，总爱矫情还以为这是有深度？</li>
<li>一个劲追求浪漫？爱情与面包我选择面包，没有物质的爱情是假的。</li>
<li><a href="https://www.zhihu.com/question/264976486" target="_blank" rel="noopener">舔狗舔到最后一无所有</a>。</li>
</ol>
<blockquote>
<p>总结出来就是：男女生而平等，也许为了表现男子气概男方可以适度大气一些，但性别差异并不是一个要求男方必须得大气包容的理由。</p>
</blockquote>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%88%94%E7%8B%97-1.jpeg" alt="舔狗-1"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/%E8%88%94%E7%8B%97-2.jpeg" alt="舔狗-2"></p>
<p>基于以上爱情观，偶尔在发生矛盾的时候我会被她说我小气一点都不大方，当然这句话还伤不了我，往往最伤我的是在矛盾中她时而表现的破罐子破摔的态度，比如这一次同居事件，她说我在跟她斤斤计较，那就不要同居了。她可能意识不到这话多么伤，但是为了不加深矛盾，我也就没有接着反驳什么气话，做一个男生要理智，关键一击要扛得下来，撑过去了就好了，深呼吸一口，把情绪附着在二氧化碳上从口腔中一起排出去，呼~</p>
<p>以前的我，是一个比较享受独处的人，因为总有自己的方式可以娱乐，包括但不仅限于健身艹单双杠、打游戏、泡图书馆，工作之后一个人来到深圳，下班依然会经常锻炼健身，时不时看看书写写很low的代码，周末自己去图书馆逛逛，有时出远门到深圳其他地方感受一下，也很愉快。有了她之后，生活慢慢改变，独处的时间明显减少，爱情带来甜蜜的同时也带来了责任，意识到自己需要花时间好好珍惜维护爱情，有时候自己比较烦躁，就会把在爱情上需要投入时间这件事当成是一种负担。世界上哪里有呼之则来挥之则去的爱情，等价交换，想获得足够滋润自己一生的宝物，就得需要将自己最重要的东西<code>时间</code>投入进去，其实要考察自己是否真的爱惜一段感情，就看自己是否愿意随时投入时间去维护它就可以了。当然有些情侣相处的方式不一样，小别胜新婚，经受得了长期异地的情侣，自然也会发展处他们之间相爱的方式，这些我是真的很佩服，因为我不知道假使我和她突然长期异地，我要怎么做才能继续保持爱情的陪伴感和新鲜感。</p>
<h3 id="银弹？"><a href="#银弹？" class="headerlink" title="银弹？"></a>银弹？</h3><p>上面瞎说了一通，下面继续瞎说。</p>
<p>这一次矛盾的尾声，我跟她说，既然我们在发生矛盾之后都无法控制自己的情绪，要不尝试引进一些规则来硬性限制我们的行为吧？毕竟人的理性总有靠不住的时候，规则的介入可以给一个破冰的借口和处理问题的指导方针。</p>
<p>这个被她笑话了，因为我们最终也没有得出一个能够100%可执行的方案，我能想到的也只是我们两人一人轮流一次主动解决问题，下一次发生矛盾我先说话放下尊严和情绪解决问题，下一次是她……看起来似乎很可笑🤣，先试一下吧，沟通是解决问题<code>最有效而且成本最低</code>的手段，但是难也就难在如何沟通，希望这个规则能管用。</p>
<p>这次矛盾下来，我开始寻找一个问题的答案：<code>有没有可以解决情侣/夫妻矛盾的银弹？</code></p>
<p>之前在豆瓣搜过一次，其中两本引起了我的兴趣：<a href="https://book.douban.com/subject/5952488/" target="_blank" rel="noopener">《亲密关系（第5版）》</a>，<a href="https://book.douban.com/subject/6052834/" target="_blank" rel="noopener">《亲密关系（克里斯多福·孟 ）》</a>，前面那本已经买下来了，最近打算认真研习一翻，希望能学习到一些手段和理念吧。</p>
<p><strong>愿认真看完我这篇废话的人都能找到自己真正喜欢的伴侣。</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试初探</title>
    <url>/2017/12/18/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>目前已经对两个不同的C/S架构产品的Server端进分别进行过一次性能测试，慢慢开始对性能测试有了初步的认识，下面大概分享一下我们小组的性能测试过程。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>性能测试开始之前会和开发讨论，目的就是要确定真实业务场景下的各种相关数据的量级，最终计算出预期多少<strong>QPS</strong>才可以应付业务场景的需要。当有了预期的<strong>QPS</strong>作为一个性能目标后，就可以开展性能测试了（根据业务需求不同会有各种不同的指标要求，可能是一个，也可能是多个）。</p>
<p>这里性能测试使用的是<strong>Jmeter</strong>，<strong>Jmeter</strong>的优点很明显，就是简单易用，可以快速搭建分布式测试环境，通过水平扩展增加测试机器来增加对Server的请求压力，把Server推向它的性能转折点。</p>
<p>机器资源在性能测试中是一个比较重要的东西，因为机器配置的好坏或者机器的多少就已经决定了你能对Server造成多大的压力，不同机器之间的配置是越接近越好，因为<strong>Jmeter</strong>的分布式测试是不存在调度一说的，只是简单地通过一个Master对配置好的所有Slave发送测试计划<code>jmx文件</code>，然后Slave会去执行测试计划（Slave也可以是Master自己）。如果Slave机器之间的性能差距太大，那么性能差的机器就会成为短板，导致性能相对好的机器无法最大程度发挥性能。</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>1. 机器资源</strong></p>
<p>继续上面说的机器性能，为什么说性能差的机器会成为分布式测试环境中的短板呢？因为每一台Slave执行的测试计划都是一样的，都要发那么多请求，起那么多线程，一旦消耗的资源超过机器承受范围，该机器发送的请求数量和质量就无法达到预期，总请求数势必变少，也就无法知道并发数等重要指标是否满足，从严谨的角度出发，这一次测试结果是作废了。</p>
<p>所以，分布式环境中性能差的机器会成为测试计划里的短板，使得测试计划的各项参数被遏制在某条线之下。另外，Jmeter的分布式环境应该选用性能最好的机器作为Master，Master所做的工作肯定是比Slave要多的，如果Master性能不好，会造成Jmeter客户端的假死，导致本次压测数据作废，甚至可能得到一些偏差较大的数据。</p>
<p>个人真实经验：用了一台很谜的机器做Master，导致多次测试无法正常结束，浪费时间，后面换了一台好的机器做Master，压测都是一次过，在调到更大请求压力后看到的响应时间甚至比没换Master之前相对更低压力的响应时间更快，所以Master也会对测试数据有影响，应该谨慎挑选。</p>
<p><strong>2. 通过重复测试来分散风险</strong></p>
<p>道理非常明显，单次的测试结果存在较大的偶然性，这些偶然性可能来自于你的测试数据，可能来自于Slave的资源状态，也可能来自于网络……为了降低各个方面的风险，重复测试当然是必须的，至少重复三次取一个平均值，而且要特别关注明显异常的数据，比如某个数据突然变高或变低，要思考一下可能的原因，而不是直接舍弃这一次结果鲁莽地开始下一次测试，谁也说不准里面是否就有一个bug。</p>
<p><strong>3. 调整测试计划</strong></p>
<p>性能测试本身不仅仅是为了验证Server的性能指标是否达到预期，找到Server的性能转折点也是一件重要的事情，需不需要准确定位这个转折点就要看业务需要了。</p>
<p><strong>如何通过调整测试计划来发现这个转折点？</strong>以<strong>Jmeter</strong>来举例子。</p>
<ol>
<li>线程数<code>n</code></li>
<li>发送请求的时间区间<code>t</code>——我理解为在<code>t</code>时间区间内，会逐步启动共<code>n</code>个线程并发出请求</li>
<li>线程循环次数<code>i</code>——也就是总共多少个区间<code>t</code>，因为循环<code>i</code>次，总共就会发<code>n*i</code>个请求</li>
</ol>
<p>以单个请求的平均响应时间为标准，由于线程在t区间内就会全部启动造成并发（可以粗略看成并发数为<code>n/t</code>），如果单请求平均响应时间大于区间t，则代表代表Server在区间t内已经处理不过来这么多请求了，就会造成请求的堆积。</p>
<p><strong><em>为什么说Server处理不过来？</em></strong></p>
<p>拿第一个启动起来的线程来看，本身预期该线程的请求在t区间内返回是没有问题的。但是，假如该线程发出的请求对应的响应时间大于t，则代表该响应在一个大于t的区间内依然算一个并发数，也就会影响到下一个区间t，结果是下一个区间t的并发数会受到来自上一个区间的叠加，最后导致在某个不知道的时间区间内，并发数会大于<code>n/t</code>，这对我们来说既不准确也不可控。</p>
<p>除了以响应时间作为判断转折点的依据之外，<strong><em>Througput</em></strong>也可以作为参考。</p>
<p>另外，应该特别注意一下总请求量，一旦发现总请求量不足预期，很大可能是机器资源不够了，此时只能把参数调低，继续往上压已经不现实。如果请求量比预期要多（这个我们遇到，谜之问题），可以先检查csv配置文件是否正确，csv里的数据是否充足，可以看看<strong>Jmeter</strong>发出的不同请求有没有发生内容的重复，再根据这些已知条件去排查。</p>
<p><strong>4. 测试数据的准备</strong></p>
<p>很多时候构造请求是需要数据的，可以根据数据库的运作特征来构造数据，从而相应地验证数据库的增删改性能，也可以根据Server逻辑来构造，从而触发Server的不同业务路径。但是构造数据务必要合理，以真实业务场景为依据。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>应该对一次性能测试怎样进行记录呢？可以有如下点：</p>
<ul>
<li>核心测试计划的各种指标数据</li>
<li>存在性能问题的方案</li>
<li>优化修改后的方案</li>
<li>优化前的指标数据和优化后的对比指标数据</li>
</ul>
<p>拿到上面的数据，就可以分析得出性能测试的结论，清晰可观地知道这一次性能测试产生一些什么样的积极意义了。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2020总结</title>
    <url>/2020/04/05/%E6%88%91%E7%9A%842020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>妈耶，自己的博客坟头草就几米高了，上一篇文章已经差不多是1年前发的了😅（最近一篇博客其实是《<a href="https://zingphoy.github.io/2019/06/30/DIY装机小白科普-cpu篇/">DIY装机小白科普-cpu篇</a>》，前面的其他文章是后来补的）。没想到接近1年后发的文章，一发就是一篇年终总结啊，真正来动笔的时候，已经是2020年3月22日下午3点多，完成的时候已经在清明节假期了😂。为什么一直没写下来，一个原因确实是工作任务繁重，周末也要经常处理工作落下的问题导致没能起头，万事开头难嘛，不起头就干脆不写了😂，破罐子破摔，反正没人看，就不话心血了，我就是这么懒的。</p>
<p>看了看时间，哇哦2020年都已经过去了1/4了，这年终总结再不写就真的是太过分了，还是决定动手来总结一下自己的2019年，顺便重新经营一下博客。</p>
<p>网上其实有不少大佬的博客，别人的年终总结是很明显看得出思考水平的，比如：</p>
<p><strong><a href="https://draveness.me/2019-summary" target="_blank" rel="noopener">https://draveness.me/2019-summary</a></strong></p>
<p><strong><a href="https://halfrost.com/halfrost_2018/" target="_blank" rel="noopener">https://halfrost.com/halfrost_2018/</a></strong></p>
<p>认真看过并尝试写过博客就知道，要写出高质量的文章，除了肯动笔乐意分享之外，平时的刻意思考和训练是真的少不了的，回头看看自己，自律能力还是相对差了太多，感叹连望其项背都做不到的同时要鞭策自己赶紧跑起来。废话不多说，进入正题吧。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/wutongshan.jpeg" alt="梧桐山山顶"></p>
<hr>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>都是毕业3年的人了，生活中占比最大部分的肯定是工作，这一年完成了<code>百度安全团队 -&gt; 今日头条app</code>的工作变化。17年入职百度，眼看着百度在18年达到了它的市值巅峰接近1000亿美元，再到19年跌到300+亿美元，实在唏嘘不已；反过来，字节一直有着强劲增长势头，敏锐的国际化嗅觉，技术也有着足够的后起优势，没有太多历史包袱，团队年轻。确实是印证了一句话：目标定得越高就越有可能做出更好的成绩。在这样的权衡之下我选择了离开老东家去字节跳动。</p>
<h2 id="跳槽"><a href="#跳槽" class="headerlink" title="跳槽"></a>跳槽</h2><p>毕业在深圳百度呆了2年多，深感自己所在的团队以及周边团队的懈怠，自知在发展上已经没有太大潜力，在2019年的8月份启动了面试找工作的“项目”，在10月底算起来也拿到了4个offer，最终在两个大offer之间选择了深圳字节跳动，从百度老咸鱼变身成字节加班狗🤣。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/me_baidu_2.jpg" alt="百度纪念工卡"></p>
<p>市面上公司都喜欢用这样的话来骗刚毕业的小朋友：<strong>多投入到工作，不要太计较加班，你能学习到很多东西</strong>🤐。会标榜说自己是一家技术驱动的公司，来到就会有很多大佬手把手将你带到行业的TOP，钱少一点不要在意。这些都是你懂我懂的毒鸡汤，但是毕业生一般没有辨识力直接就被骗过去了。世界上根本就没有技术驱动的公司，公司的存活永远要盈利，而技术只是商业化上的一个选择。对于毕业生来说，一个更大更好的平台，即使它的钱少几千（实际上往往平台越大钱还越多），也比任何其他工作更有潜力和发展空间。另外，程序员的成长及其依赖业余学习，如果加班太多，短期来说可能会有正向作用，你会被迫接触到很多以前没做过的东西，但是长期来说，被工作牵着鼻子走并不会让一个程序员走向行业顶尖，没有人是因为加班工作而变成行业大佬（“加班”研究技术是另一回事）。</p>
<p>算起来已经入职字节有5个月了，我有效加班的时长已经大大超过在百度2年多的有效加班时长了（有效加班时长：真正为了干活而加班），感同身受地说，加班并不会让人学到更多的技术，往往加班是因为效率低下，或者对外承诺太多，最需要花时间的往往是那些零零碎碎的问题，逼着人东一榔头西一棒子的。</p>
<p>字节跳动流传着一个文化：<font color="blue"><strong>成长看个人</strong></font>🧐。一个人的成长，除了外部环境氛围的影响外，更重要的是看个人因素。生活中不乏各种家境优越，成长环境充满了资源的人，这种感觉放到公司层面来，就是你的团队能不能给你提供更好的发展空间和成长资源，而你能不能更好组织利用这些资源和渠道来滚雪球。人的成长并不是干巴巴的，就像人只要生存着就要消耗空气一样，你只要成长，首先要消耗的就是资源，资源的概念是抽象的，包括但不仅限于环境氛围、前辈指导、信息渠道、工作含金量等集合。这些资源质量越好，你越有可能在同样的学习强度下获得比别人更快的成长速度，这对以我来说，就是从百度走到字节跳动的最大原因了。</p>
<p>回头来看19年自己在百度的工作历程，看着平淡也还是有一点收获。5月起我在百度的工作内容发生了明显变化，脱离了业务测试岗位，跟着leader做起了安全专项测试，专搞web方向漏洞挖掘，前后接了3个大型的内外部系统的工单，也是这个时候我开始接触web相关的安全知识，同时入门了Go并用它将一个C语言开发的<a href="https://github.com/sjvermeu/cvechecker" target="_blank" rel="noopener">开源CVE漏洞检查工具</a>重新实现一次，其中也用到perf工具做了一些性能调优。这段经历给我的最大感受有三个：</p>
<ol>
<li>明白安全领域的不容易，决定放弃安全方向的深入学习：做安全如果不能早起步，在工作之后还想跨领域专精安全是比较困难的。因为需要很多时间投入来打安全基础，尤其是搞渗透搞逆向，更是要扔一把一把的时间来理解系统底层、软件设计、安全实战等。</li>
<li>白盒审计代码，是降维打击。先知道黑盒上的功能，直接点对点review代码，更高概率发现问题。表面看起来牛逼的项目，不还是代码一砖一瓦堆起来的。</li>
<li>学习一门新编程语言并不难，难就难在能否坚持用新语言做技术输出。</li>
</ol>
<p>在这段搞web安全专项测试的时间内，给了我一些时间去思考自己的定位和发展，知道安全并不是自己最感兴趣的方向，最终决定换工作。去到字节跳动也是有一定的偶然因素，一开始并不想去强度那么大的地方，甚至跟同事表达过不去字节高强度加班的观点，自己明白技术人没有时间自我提高是很危险的。然而在字节高强度加班offer和一家高时薪外企offer的对比之下，最终自己还是真香选择了字节🤣。字节的面试真的让我感受到对人才的渴望和专业素质的，这也是为什么我愿意切换自己的技术栈投入到移动端的质量保障中去。</p>
<p>来到字节跳动，对它的历史做了简要了解后，才明白一个很重要的道理：<font color="red"><strong>选择大于努力</strong></font>💪。为什么这么说，可以拿目前字节的一些高层的工作历史来看，要做到财富自由，单纯从一家公司努力往上爬，在有限的十年中能去到顶端的人少之又少，因为坑就是那么多，占一个少一个，你要上去别人就得下来。而更好的机会，往往是藏在急速发展的小公司中，眼光锐利进入未来独角兽企业，伴随着公司团队一起发展，把先前积累的工作经验应用在当前团队，时势造英雄，这种环境下更可能成为公司的顶级人才，在上市的一刻实现财富自由。当然这里着眼点比较低俗，并不代表你占到坑就成功了，前提是你要具备对等的能力与潜力，机会也只留给有准备的人，满足这样的前提，就会有 <strong><em>猪站在风口上都会飞</em></strong> 的现象。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>在百度里更多的是做被动测试的角色，安全产品的迭代速度很慢，约两周到一个月，RD来什么需求我就针对性做什么测试，在测试细节上比较细，能结合代码做百盒都尽量做，但是整体质量建设都只留在起步阶段，缺少大局思维，也没有外力推动做建设。除了常规流程建设，没有自动化，半自动化也不成体系，公司很多能力也因为产品性质无法接入。总结一起来就是：对于QA来说，一直停留在单兵作战缺少大盘规划的感觉。这也给个人成长带来了明显的瓶颈，可以这么说，在百度的两年半里学到的东西，实质上用9个月到一年就可以完全掌握。</p>
<p>在字节的头条app的QA团队里，我的角色定位虽是测试序列，但是游离于业务测试、技术专项中，接触远远比百度生涯大，也有机会参与到短期中期规划的制定，跟比我工作年限多很多的同事共事，做的事情也更加有意思，让我看到除了常规业务测试外更多的质量保障手段，包括但不仅限于过程改进、线下自动化、线上监控、质量度量、竞品评测、专项建设等。当前工作的缺点嘛也是很明显的，比如：在技术专项上的技术挑战性还是稍有欠缺；工作量大导致无力顾及业务质量建设；加班比较重极大压榨了业余学习时间。除前面提及的几点，对目前的工作还算ok。</p>
<p>循例摆个工位图，传言屏幕越多，技术越菜，发现大佬们似乎都不爱用外接屏幕的🤔，顺带打个广告，字节跳动app质量保障团队很缺人力，业务也好技术也好，只要基础过关，统统欢迎🎉🥳。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/bytedance_desktop.jpeg" alt="字节工位"></p>
<h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>团队的结构相对合理，由于我的角色定位，偏技术维度的事情更多由我来负责，同时也参与到团队目标设定、外包管理、质量建设、氛围建设中去，很多时候做建设都是大家一起探讨商量，一点一点迭代出方案或者对齐目标，有很好的参与感。最近更是有一件事让我很惊讶，上级的上级直接找到我来做QA方安全建设的规划，原因是整个QA团队只有我有安全背景，这除了说在大规划上是我的初体验外，也真真切切感受到敢用新人的文化，这是我从未体验过的。</p>
<p>反观我的百度生涯，单兵作战小产品小团队的模式，一个人要对接所有信息，没办法做良好的信息筛选，也没办法做到各自分工，有好的想法也因为人力问题导致无法开展。这种单人独立对接多个项目的模式真的空间太小了，就像技能点各自只点一两级而且还有点歪技能的感觉。职场除了亲自做事是最好的学习手段外，看着别人做耳濡目染也是十分关键的学习方法，百度生涯就是缺少一个资历丰富的前辈带着我做事，眼光和认知就局限在那么点空间，是很难突围的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个2019年里，百度生涯的技术成长速度严重不符预期，量变过少，质变更加没有。来到头条2-3个月后接手了其他人的代码，在上面做了各种优化让老方案焕发生机run起来，也明白了QA这个岗位的道理：<strong>不需要QA写代码写得多溜，但是需要QA写的时候要能写出来</strong>。更高层面来说，做技术更重要的是方案、是如何解决问题，其次才是具体代码实现，解决实现细节问题。虽然QA也分不同领域方向，但是殊途同归，最终的目标就是质量保障，只是解决这个问题的切入点或着手点各有区别，一切都是为了测试左移，尽快发现风险和缺陷。当然要追技术梦的话，肯定是开发岗起步更好，然而两者并不冲突，QA也可以做到技术专家，只是需要刻意做更多技术沉淀。</p>
<p>之前刷手机时看到一个做算法的前辈说职业发展：</p>
<blockquote>
<p>一般3年或5年考虑一个大致方向，职业规划都是因人而异的，要考虑能力兴趣和短板，多找一些样板，大概比自己大5岁左右，当成自己下一个5年的参照对象，这些人是大家眼里成功的或者失败的，自己再换位思考，假设自己是ta，到底喜不喜欢ta的位置，心累不累，有意思没，自己最喜欢谁的位置，再一一补齐自己对应的能力短板。</p>
<p>对于自己的技术发展，要有一个 <strong>浅入深</strong> 或 <strong>窄变宽</strong> 的脉络，点亮技能树的各种分支，而不是一个系数的图上乱点技能，过一年又换，这种没有积累。没有做过的应用场景，多从数学问题本质思考，锻炼迁移学习的能力，养成好的算法思维惯性，不要被绩效、快速拿收益等完全带偏，先从数学建模角度思考，落地再做方案折中。</p>
</blockquote>
<p>方法论真的是很重要的，所谓的经验，可能也就是方法论更具象化的东西。就像解数学题需要套用公式，而方法论就是解决不同领域问题的工具。对于技术界，要解决一个问题，看看业界怎么做，看看学术界有没有研究，看看内部有没有现成的，能不能拿来主义然后做定制化，简单方案先轻量run起来，再一步步迭代完善，这就是常规的方法论，或者说是套路。</p>
<hr>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>19年做了人生中的第一次真正意义的手术，把拖了半年多的肩膀问题给治了——在18年11月因为练习双力臂过猛导致一边肩膀受伤。本以为年轻人过一段时间就会好，殊不知过了大几个月，只要肩膀转到特定应力位就会明显疼痛，最后在19年7月份去医院做了个微创，前后3天2夜就出院了。距离手术完成已经过去了8个月了，肩膀大概康复了90%。在康复的这么长时间中，几乎放弃绝大多数的体育运动，也因为来到头条之后休息时间变得更少，感觉身体素质往下掉了不少，无论力量、速度、耐力，估计只有肩膀受伤前的70-80%吧，来到头条伙食实在太好了点，体重也到了历史新高140+😑……</p>
<p>最近开始已经重新运动了，做不足20个双杠臂屈伸就整不动了，而且还不敢太浪怕肩膀二次手上，需要时间好好把自己以前的身体状态要回来。先从臂屈伸开始，然后就是引体向上，再来就是前水平和双力臂，健身跟技术本质是一样的，都需要慢慢积累，时间长了效果就有了！</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/country.jpeg" alt="老家小村落"></p>
<h2 id="老家"><a href="#老家" class="headerlink" title="老家"></a>老家</h2><p>今年爆发新冠肺炎疫情，回老家也过了一个很特别的年，以前父母说啥我们都不听，现在我们说啥父母也不听🙃。这一年回老家特别没有过年的感觉（自从上初高中起年味就淡下去了），感觉爸妈又老了一年了，发现老家很多地方已经变了自己现在才知道，跟老妈外出散步时指着哪个地方说起小镇以前这里是什么那里是什么，是真的深刻意识到岁月的问题了！</p>
<p>于是过年时掏起手机一顿拍：家里过年炒的菜、家里的每个角落，还有最重要，<strong>我们一家的合照</strong>❤️，我已经敲定了，以后每回一次老家，都要跟爸妈在同一个地方来一张合照📷，这些照片肯定是我未来最珍贵的宝物之一。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/new_year.jpg" alt="老家过年的9种食物"></p>
<p>在百度时回老家也就是一年三四回，来到头条假期少了很多也忙了很多，估计也就一年两三次机会了，也是因为新冠疫情原因，2020年估计回家也不多，换成以前，清明节爬山祭祖我是一定会回去的，这一年我只能留在深圳宿舍里敲着博客想念老家……</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/hometown2.jpeg" alt="老家小镇"></p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>来到头条后，真的是<strong><em>再也没有再看过一本完整的书</em></strong>了，或者说，看书的总页数不超过40页😶，自我时间管理做得太差了，平时加班很晚一回来就瘫在那里，周末也选择了补工作而不是学习……翻翻自己的豆瓣记录，惨不忍睹，有种我后面几个月人间蒸发的错觉。剔除【物我之境】这本突然记起以前看过就随手标记的书，19年我只看了8本书，自从进到字节之后就彻底断掉了，时间是真的少很多🙂。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/20200405233938.png" alt="2019年读书清单"></p>
<h2 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h2><p>19年我个女王大人终于住在一起了！搬家到一个城中村30平小房间中，在5月份一口气花了1w多买各种电器家具等布置我们的小窝。19年我们俩也和平了很多，记得一起是平均一个月就要炸一次，同居之后已经很少发生这种事了，不过最令人蛋疼的一次就是一起去顺德玩在路上生闷气打冷战了，那两天的游玩直接变成了冷战，别提多蛋疼。</p>
<p>在相处上我终于从钢铁直男开始转变了，每个男生总要面对跟女友相处的一些操蛋情况，即使是对方不讲道理，能不能摆下面子先安抚情绪就成了直男是否开始成熟的标志😅。</p>
<p>布置过的小窝还是摆个照片吧，过了几个月后桌面更多东西了，下图是最原始的样子：</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/our_house.jpeg" alt="小窝"></p>
<hr>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><p>回过头来看<a href="https://zingphoy.github.io/2019/01/02/我的2018总结/">2018年年终总结</a>给19年立的flag，是一个都没达到啊😅：</p>
<blockquote>
<ol>
<li>亟需提升的是代码量，在2019年平均每个月可以产出<code>500行</code>结构化的代码，无论是工作代码还是个人代码都好，那种小脚本小工具不包括在内。【可能每月200-300行左右，大多数还是在换工作后才写的】</li>
<li>最高优的是<code>在安全方面打好基础</code>，熟悉web安全、Linux安全、汇编和各种工具的使用；另外Linux内核、游戏开发、二进制分析、渗透、病毒分析等需要入门。【彻底放弃安全方向，虽然依然对安全领域有着较强探索欲望，但是优先级会很低】</li>
<li>一个一直都想点亮的技能就是学会1个web开发框架，自己写一个博客的前后端，或者搞一点有意思的小需求。确定选中<code>flask</code>，自己未来的主力语言应该是python，备选是go。【用go重构了一个开源安全扫描工具，至于web后端，还是零接触】</li>
<li>阅读至少<code>2个</code>大型开源项目的代码（python源码已经在清单之内）。【完全没读过……】</li>
</ol>
</blockquote>
<p>简直是一事无成啊……好好复盘一下，flag都没达成，要不就是目标定得太高，要不就是自己没有执行落地，很明显是后者嘛，关键问题还是去到自律与计划能力上，自己的潜力部分没激发出来。说到个人时间管理，这个技能在最近两个月有了明显长进，这里有一篇的文章需要引用一下：</p>
<p><a href="https://draveness.me/few-words-time-management" target="_blank" rel="noopener">如何管理自己的时间资产</a></p>
<p>软技能就是这样，它不像谋生的硬核技能那样，这么容易被发现或者总结，很多时候对这些技能自己只是有那么丁点儿的感受，说的好听就叫只能意会不能言传，说到本质就是自己其实还完全弄懂，模模糊糊不能总结抽象出来。方法论其实还是有的，像上面那篇文章那样清晰表达出来，就是自我管理进阶的表现。之前定过的所有KPI、OKR，全都像过眼云烟，定完就忘记了，没有周期check，没有milestone，最后就是完全走偏目标，弄不清楚自己干过了些什么，被牵着鼻子走。</p>
<p>年后简单实践了一下上面的方法论，虽然完全不够作者严格，不过确实有些效果，最大的感受就是进度可视化，而不再是模模糊糊难以言状，下面就重新定义<strong>🚩2020年的目标🚩</strong>吧。</p>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><p>首先大致方向有几个：</p>
<ol>
<li>学习一个不同领域的开发技能。</li>
<li>入门一个不同的技术方向。</li>
<li>掌握一种新的编程语言并应用。</li>
</ol>
<p>叠加工作因素与个人意愿，由上面的方向转化而来的目标：</p>
<blockquote>
<ol>
<li>熟悉后端python Flask + 前端（Vue.js or 其他）的开发能力，具备初级移动端Android / iOS开发能力。</li>
<li>阅读python Flask框架、requests库 &amp; 低版本MySQL源码。</li>
<li>掌握基本的ROP技术，能独立分析一个安全漏洞。</li>
<li>每月至少产出2篇优质博客。</li>
<li>至少阅读8本书。</li>
<li>体重保持在 70±2kg，解锁双力臂、前水平两个动作，俄式挺身不强求。</li>
<li>跟女王大人去国外溜达一次（视新冠疫情而定）。</li>
</ol>
</blockquote>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这种流水账式的无脑年终总结应该是我最后一篇了，感觉这一次换工作是我职业生涯中一次大转变，这小半年来意识到很多技能都开始有点进步，包括技术感知力、自我管理、自我定位、向上管理等，隐约预感2020年会是一个技术和能力上的质变年，希望自己能顶住压力上去。</p>
<p>19年整年来，亲人、爱人、朋友、同事，但凡每一种关系，都能比以前处理得更好。亲情和爱情也更温和了，职场上也交了几个要好的朋友，这一年来本性收敛了一些，不像刚毕业时那个沙雕青年一样口无遮拦大嘴巴子，惹人爱也惹人厌。</p>
<p>最后也没什么好说的了，期待2020年自己的转变😌 ~ </p>
<p>愿自己可以成为自己最喜欢的那一类人。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/hoishan_railway_2.jpeg" alt="老家火车站"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次e3装机心得</title>
    <url>/2019/06/11/%E8%AE%B0%E4%B8%80%E6%AC%A1e3%E8%A3%85%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小学六年级升初中的假期家里买了一台台式机，还记得主机+屏幕+外设+电脑桌整一套下来一共5700+，奔腾cpu，具体啥型号也不懂，内存1g，硬盘不足200g，完全不知道是什么独立显卡，在大学的时候50块钱除了电脑桌外整套卖给了亲戚。大一依然没有自己的电脑，拿的是表弟玩剩的三星笔记本，只记得是2g内存，拿来玩dota2都时不时掉帧，可是相对我以前的台式机来说性能已经好很多了。到了大二终于买了自己的第一台电脑——服役到现在的神舟战神K650D-i7。又是几个年头了，也给老神舟加了120g的msata的SSD和4g内存，虽然胜任日常工作，但是畅快一点的影音娱乐依然有心无力。</p>
<p>出来工作两年了，搬家也稳定下来，终于打算自己DIY一套配置出来，这是一件很让人兴奋的事情，还是说男生总是喜欢折腾乱七八糟的电子产品😂。刚开始是打算正儿八经在6.18组一个中高性能主机的，配置是 <code>r5 2600x + 微星迫击炮B450m + 迪兰rx588 2048sp + 8g*2 十铨 + 酷冷至尊550w + 大霜塔散热器 + 西数黑盘500g</code>，在JD和Tmall上看配件就好像一些人经常喜欢翻淘宝一样，一看不可收拾，有空就会拿出来看一下，彷佛马上就要买一样。后来看的资料多了，慢慢意识到二手配置性价比有多高，又接触了一些矿卡的资讯，来到了图拉丁吧，在公司内网发个帖子收二手配置还来了一位高级垃圾佬聊天，最终成功误入歧途……贪便宜的心越来越重😄，虽然没有DIY过主机，没真是踩过坑，但是却想花更少的钱来达到更高的性能。</p>
<p>于是重新审视自己的需求，其实<code>e3 1230v2</code>即可满足我的需求——写写代码轻度影视娱乐游戏，开始了我的菜鸟装机历程。</p>
<a id="more"></a>

<h2 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h2><table>
<thead>
<tr>
<th>配件</th>
<th>具体</th>
<th>价格</th>
<th>购买渠道</th>
</tr>
</thead>
<tbody><tr>
<td>cpu</td>
<td>e3-1230 v2</td>
<td>388</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>主板</td>
<td>技嘉 B75M-D2V</td>
<td>223</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>显卡</td>
<td>讯景 rx570 4g 黑狼版</td>
<td>423</td>
<td>淘宝二手（矿卡）</td>
</tr>
<tr>
<td>内存</td>
<td>金士顿 8g * 2</td>
<td>Null</td>
<td>存货</td>
</tr>
<tr>
<td>SSD</td>
<td>三星 860 EVO 250g</td>
<td>Null</td>
<td>存货</td>
</tr>
<tr>
<td>HDD</td>
<td>西数企业级硬盘 1TB 7200转</td>
<td>198</td>
<td>淘宝二手</td>
</tr>
<tr>
<td>电源</td>
<td>酷冷至尊 gx450</td>
<td>256</td>
<td>JD全新</td>
</tr>
<tr>
<td>cpu风扇</td>
<td>九州风扇 玄冰400</td>
<td>82</td>
<td>Tmall全新</td>
</tr>
<tr>
<td>机箱</td>
<td>先马米立方</td>
<td>156</td>
<td>JD全新</td>
</tr>
<tr>
<td>机箱风扇</td>
<td>乔思伯日式plus 红光 * 3</td>
<td>50</td>
<td>闲鱼</td>
</tr>
<tr>
<td>其他</td>
<td>主板电池1粒+硬盘数据线1根+网线1根</td>
<td>4.9 + 9.9 + 7.9</td>
<td>JD全新</td>
</tr>
<tr>
<td>显示器</td>
<td>dell U2417</td>
<td>850</td>
<td>闲鱼</td>
</tr>
<tr>
<td>显示器支架</td>
<td>AOC SBX03</td>
<td>124</td>
<td>JD全新</td>
</tr>
<tr>
<td>总价</td>
<td></td>
<td>2782.7（主机1808.7）</td>
<td></td>
</tr>
</tbody></table>
<p>这个是在<code>2019.6.18</code>之前组装的机器，因为急于组装在<code>6.2</code>就下单了，当时是因为<a href="http://www.g4560.cn/" target="_blank" rel="noopener">图拉丁之家</a>推荐低价渠道，当时怕优惠一下子跑了急火攻心不等6.18就当场出了一套配置（实际上我想要的东西也不知道6.18是否真的有折扣），我自己都不敢相信我会决定的这么快，e3 cpu和b75主板这些才刚了解就不管三七二十一买买买，大家都不要学我了😂。上面的清单已经把运费和折扣都算进去了，我自己有一个cherry青轴键盘，鼠标本来也想买但是一看感觉好的要190太贵了就放弃了。如果算上二手内存和地全新低端SSD的价格，估算总花费2700左右。</p>
<p>下面就是全家福，就差电源还没到货！！！</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/all-together.jpg" alt="配置全家福"></p>
<h2 id="挑配置"><a href="#挑配置" class="headerlink" title="挑配置"></a>挑配置</h2><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>整套配置其实是围绕cpu组装起来的，不少地方的言论就是<code>e3 1230v2</code>是i7阉割核显后剩下来的东西，可谓性价比极高，我没有去考究真伪，反正我信了😄。也有不少人推荐<code>e5 2637v2</code>，最大睿频3.8GHz，淘宝不足300块，但是这玩意儿是个电老虎，耗电要电源加功率不说，发热也更强，主板价格也更高，虽说支持双路cpu（也就是一个主板上两个cpu）然而并不适合我这类入门级家用电脑，在我的应用场景来看性价比不高，最后还是选择e3邪教，参考<a href="https://ark.intel.com/content/www/us/en/ark/compare.html?productIds=75779,65732,75792" target="_blank" rel="noopener">1230v2，1620v2，2637v2对比数据</a>。</p>
<p>另外，这种古老二手cpu的价格很不稳定，<a href="http://detail.zol.com.cn/310/309339/param.shtml" target="_blank" rel="noopener">e3 1230v2 参数点这里</a>，大概是13年上市的cpu，我在6月11日看同一家店，<code>1230v2</code>的价格降了10块，从<code>¥375</code>变成<code>¥365</code>。</p>
<p>cpu是直接从福田华强东发货的，我就住在福田，后天到货之后拆开看看，作为新手的我看到cpu背面左上角针脚有几块地方是黑黑的，还以为快递运输出问题方的一b，最后上机正常点亮才松了一口气。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu-front.jpg" alt="e3 1230v2 正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/cpu-behind.jpg" alt="cpu  e3 1230v2 背面，看到左上角针脚有黑点"></p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p><code>1230v2</code>是1155针cpu，这个U其实市面上还是比较多货的，主要是支持1155平台的主板难掏，想要便宜的主板，华南金牌这种寨板也不是不可以考虑，只是你要知道b75主板芯片组早就已经停产，要新的芯片组是不可能的，也就是说那种号称全新的寨板，是从其他拆机版上把芯片组用热风机等其他手段搞下来后拿过来装在自己的pcb板上。寨板的质量情况大家都懂，你RP好并且动手能力强，出问题可以自己给修回来，钱你就可以省下来了，如果像我这样才入门不久没怎么见过世面和<code>j（奸）s（商）</code>套路的，还是老老实实买贵一些的拆机板的吧，很多论坛平台都推荐技嘉b75，内网认识的一个垃圾佬也推这个，我也就只考虑这个板子了。</p>
<p>后来搜主板才发现技嘉b75还分好几种，有D2V、D3V、D3H……这时我犯的一个大错就是没有好好考虑他们的区别，简单看一下就拍了尺寸更小的D2V，后来装机发现机箱还有不少空间都没利用上，主板过小不仅影响美观，原件密集还会影响散热，极度后悔……</p>
<p><a href="http://detail.zol.com.cn/ProductComp_param_309878-341022-386819.html" target="_blank" rel="noopener">技嘉b75主板参数对比</a></p>
<h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><p>我买的是<code>讯景 rx570 4g 黑狼版</code>，那时就是因为看到这个显卡比较满意就把整套配置给临时配出来了。IO接口生锈黄得一b，一看就知道是矿得不能再矿的显卡（因为矿卡挖矿是不需要接屏幕的，而且环境恶劣，IO接口一直不用就很容易生锈，这是分辨矿卡的凭据之一）。之前也在图拉丁发过一帖（不知道为什么被吧务删了），被一堆老哥劝退，要不就说加几百上全新rx588，要不就退货换另一张……也没给我什么具体的建议，基本没有什么可行性，果然贴吧不好玩，帮人解决问题的帖子越来越少了。</p>
<p>显卡正面与背面，我这是第一次摸带壳显卡你信不信😄。IO接口暴露了矿卡的身份，淘宝卖家也不给擦一擦，用指甲抠或磨砂纸打磨才能去掉，而磨砂纸又会刮花挡板，干脆不管了。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/graphics-card-1-1.jpg" alt="显卡正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/graphics-card-2.jpg" alt="显卡IO接口"></p>
<p>另外，都是来买amd的二手显卡，想买到普通玩家自用卡，我觉得蹲几个星期闲鱼都不一定能蹲到，可遇不可求，都这个价格了还要什么自行车。有心蹲二手配件行情得花太多时间，毕竟二手价格直接受到供求关系的影响，如果放在几个月前可能就便宜几十块。</p>
<p>也可与考虑换成rx 580 4g，8g显存太浪费了，根本用不完。我在这套配置上跑孤岛危机3，除了<code>抗锯齿x2</code>外全部都是最高特效，显存也就占用个一g两g，连4g都用不玩还买8g就过分了。孤岛危机3毕竟是13年的神作，优化应该是极好的，可能这一两年的大作对显存的需求完全不一样了吧，所以组装电脑还是要case by case，对于我，4g显存绰绰有余。</p>
<p>网上各类测评rx580性能大概比rx570高10%，差距不大，换成580多花100我觉得不值。不过580可以买到18年出厂的显卡，即使是矿卡挖矿可能也就半年多，有底气长命一点。</p>
<p>其实我也想过要不要退掉这张矿卡，因为这卖相实在让人 不舒服，打电话问客服是17年11月出厂，质保6个月早已过保，连骗一下自己都不行🤣，分分钟挖矿一年多，寿命可能已经不多了。玩十年前的游戏《死亡空间》，显卡电流声啸叫很明显。不过看在它有完整背板，简单拷机六分钟温度84°C也还能接受，娱乐大师是跑分也正常，就留下它拼拼运气了看我能用多久不坏了。虽然店主说3月保修，这些话嘛权当谎言听听就好，不要信这种二手倒腾矿卡的卖家在保修上的任何言论。还是建议大家选购二手显卡要卖家给SN码，最好查过这些信息再考虑买不买：</p>
<ol>
<li>此卡是否在保，还有多久保修？</li>
<li>如果坏了，联系不到商家，能否个人送保？</li>
<li>此卡是否有过维修历史？</li>
</ol>
<p>不过既然想买便宜卡，可能上面一个条件你都满足不了，就像我这张卡一样😄，得看你有多少耐心蹲闲鱼了。</p>
<h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>电源算好功率买就好了，网上计算整机功率的算式五花八门。二手电源选好牌子，问题不大，垃圾应该也比较好捡，我是因为第一次装机，电源估计还会一直用下去，毕竟电源才是整机最关键的地方，它出问题其他配件可能跟着就烧坏，数据无价，boom了小命都没，就选择一个全新电源，这点钱加上去我觉得还是值得的。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/naked-2.jpg" alt="裸奔尝试点亮"></p>
<p>尝试点亮机器，没加cpu风扇，在bios cpu就爆到96度，手贱摸了一下cpu顶盖，酸爽😭。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/temp.jpg" alt="BIOS界面"></p>
<h3 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h3><p>先马米立方机箱是很久以前就挑上的，没有仔细看接口参数，只看颜值，结果踩坑，前面板只能装2个120mm风扇或者1个200mm风扇，并且由于是平躺放主板的设计理所当然没有背板走线……一开始看上这个机箱是因为它可以平放主板而且3面侧透另外还相对便宜，不像一般机箱主板竖着放，我怕cpu风扇这么重会伤害主板，其实是我想多了。</p>
<p>后来知道有个<code>启航者s3</code>机箱，我喜欢小一点的机箱（MATX主板），感觉它结构良好，走线也方便，不过看到有帖子说散热不太好，我觉得应该不是问题，那么便宜的机箱你也不会去配多么高端的配置，散热够用就行。</p>
<p>觉得自己的机箱只有一个赠送的前面板200mm风扇和自己买的cpu风扇，觉得单调得要死，忍不住还是上闲鱼掏了几个带光的风扇让自己嗨一下，机箱其实也可以去掏点垃圾，分分钟附送几个风扇给你，都不用买了。</p>
<h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器在闲鱼上还是比较好掏的，我是孤身到龙岗工业区上门验收回来的ips 24寸dell屏幕，现场检测没有问题，以6折的价格把一个8.5成新的屏幕买回来，是这套配置里面我觉得比较值的一个东西😀。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>强烈安利显示器支架，找个好的牌子，然后哪款便宜买哪款就行。</p>
<p>至于硬盘，最好买个新的，存储设备买二手风险比较大，数据（小姐姐）无价，除非你像我一样存的东西一文不值，丢了也不心痛😄。</p>
<p>最后再补几张效果图。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/naked-11.jpg" alt="灵魂走线，尽力了"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/front.jpg" alt="主机正面"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/top.jpg" alt="主机顶部"></p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/left.jpg" alt="主机一侧"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>捡垃圾入门易精通难，需要花很大精力来熟悉市场价格走势和老配件的参数，这样才能有敏锐的嗅觉知道哪个垃圾捡起来更香。</p>
<p>如果要捡垃圾，先从cpu主板开始，确认自己要在哪个平台上攒配置，特别是对于小白，cpu和主板并不是都配套的，以来分平台（intel 和 amd），而来分接口类型。如果不会组装机器的，多上网搜搜一大把资料，b站的视频教程多得是，最好看两三个，这样自己就很有把握了，切记安装时不要大力出奇迹，硅胶tm不要给我涂到主板针脚上😂。</p>
<p>上面的配置，其实电源、cpu风扇、机箱这三样都能缩水一下，大概可以再省150 - 200元，我的cpu风扇和电源其实不太搭这套配置，钱稍微有点浪费了。在图拉丁吧中有类似配置的主机1000 - 1200就有人凑出来了，机会可遇不可求，便宜一去不再来😂，反正嘛，捡到便宜自己开心。</p>
<p>普通用户，选择机箱其实无所谓散热和材质，只要风道合理，结构良好和走线方便即可。特别是MATX主板以下的尺寸，这类小机箱其实无所谓高度，最重要的是长和宽，考究的是摆在桌上占不占地儿，我这个机箱就买得有点失败，又宽又长除了3面侧透没啥优点。</p>
<p>最近6.18 ddr4内存掉价特别恐怖，不少垃圾佬都在囤货了，如果你是一名像我一样的普通玩家直接忽略就好，如果你是有强烈DIY爱好，手头有两三台主机的金主，赶紧去捞便宜吧😜。</p>
<p>另外还有部分劝退心得😄：</p>
<ol>
<li>不要以为买一个多线程的cpu就觉代码跑多线程更high，你下班后根本不想再写代码，休息都来不及。</li>
<li>不要以为买了一个2000大洋的显卡就能好好玩3A大作，过了那个年纪再这样玩游戏会觉得很空虚。</li>
<li>总结：不要太高估自己的需求，特别是幻想中的需求。</li>
</ol>
<hr>
<p>上面就是我的首次装机历程，这里最后的内容是在装机大半年之后回来写的。装机完成才用了几次就开始频繁无法开机，当时初步怀疑是主板老化接触问题了，每次开机都要拆机箱插拔配件折腾，最后嫌麻烦800便宜卖了。也就当做是一次玩机经历吧，这样的操作让资深图拉丁玩家看到免不了一脸鄙夷哈哈哈哈，在此也奉劝大家捡垃圾怡情就好，不要花大把大把的钱，除非你要搞商机😝。</p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>电脑配件</tag>
        <tag>图拉丁</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018总结</title>
    <url>/2019/01/02/%E6%88%91%E7%9A%842018%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>已经工作一年半了，以QA的身份入职到现在，前半年跟后半年还是有不少变化的，看着一批老同事离职，包括自己的导师，有的QA同事转型成RD，有的跳槽去了更大更好的平台继续做测试，有的为了工作能轻松一些好带小孩去了传统公司，也有一些RD感觉到自己在这里到了瓶颈跳槽寻求发展。慢慢地自己变成了团队里一个老人了，开始独立负责一些项目的测试工作，角色开始从一个单纯的执行者稍稍往上走了一点，要自己出测试方案，要自己叫人一起来review，然后自己执行。以前在导师的荫蔽下，几乎把一切RD对接的沟通工作都省去了，自己安心做基础测试工作。那时候的自己浑然不觉，自以为完全handle了自己负责的那一部分，现在看来甚是傻逼。</p>
<p>前半年就是这样子的一个状态，接触了几个小型项目，有客户端的，有web平台的，也有后台的，前半年对于自己来说，这些不同的项目并没有什么根本区别，唯一的区别可能也就是功能和测试场景不一样吧，或者说仅仅局限于实现方式的不一样，现在回头看一下，这些项目从需求背景就完全不是一码事。以前自己好奇技术细节的实现，具体到单个功能的几个函数是怎么写的，用到了什么样的技术，而现在自己更好奇的是用什么方案来解决一个问题，其次才是具体的代码实现细节或者技巧。从环境上来前半年跟后半年是有明显区别的，增加了不少新同学只后测试工作负担少了很多，也终于拿到了一些对接项目的代码可读权限了，当自己对具体实现细节感兴趣或者遇到bug想自己排一下的时候就可以看一看。</p>
<a id="more"></a>

<h3 id="白天求生存，晚上谋发展"><a href="#白天求生存，晚上谋发展" class="headerlink" title="白天求生存，晚上谋发展"></a>白天求生存，晚上谋发展</h3><p>前半年跟着导师干活，后半年导师离职后隔壁组的QA leader过来一起管理我们的测试工作，客观评价一下两个人的工作作风区别。</p>
<ul>
<li>导师（女）属于那种雷厉风行，做事情不吭声，测试效率高的人，但是她不会去看项目源码，没有足够强的自动化意愿，在我看来是一个相对传统的QA。<ul>
<li>优点：<ol>
<li>一切的工作都是为了快速完成项目测试并保证基础质量，测试效率真的很高，测试速度得到对接RD一致好评。</li>
<li>场景覆盖较为全面，QA思维清晰缜密，相关类型的项目测试经验丰富（7年经验），可以及时发现RD的方案设计的不足之处。</li>
<li>工作真的负责认真，该周末加班时毫不含糊（有小孩的人）。</li>
</ol>
</li>
<li>缺点：<ol>
<li>更加愿意通过手工测试来完成工作，对于项目逻辑单纯听RD口述即可，从没听过她追究代码，100%黑盒测试，自动化的想法不足，更不要说最后落地的自动化方案，几乎为零。</li>
<li>对项目的owner精神不足，测试完一个提测（这边的项目迭代速度十分慢，一点都不敏捷）后基本不闻不问。</li>
<li>对复杂项目流程有着一定的厌恶，不主动推合适的测试开发流程。</li>
<li>对隔壁组QA测试的项目没有展现出任何兴趣（相反我倒是超级感兴趣的）。</li>
</ol>
</li>
</ul>
</li>
<li>新QA leader（男）RD出身，只负责在我们这边推流程，自动化意愿和想法极高（当然还是我们自己来落地），推动力较强，经常在RD之间游说新流程。<ul>
<li>优点：<ol>
<li>push我们落地新流程，包括详细设计评审会、case评审会、迭代分析会，提测流程等，虽然不是每个项目组都能接受所有流程，但是帮我们在RD leader层面解决了很多流程上的推动障碍，让QA有了更多可以介入的空间。</li>
<li>push我们做自动化，虽然没有强制我们做，但是一直给我们灌输想法，最后我自己做了起来。</li>
<li>一直push我们给项目做各个维度的质量保障，从基础的监控到CI到单测（emmmmm我没有去做）。</li>
</ol>
</li>
<li>缺点<ol>
<li>站着说话不腰痛，不了解项目的具体情况，按照他那边大项目的<strong>重型流程</strong>在我们这边的小项目组里做无意义的推动，搞得RD有点抵触情绪。</li>
<li>只说不做，给我们想法，具体落地完全只能靠我们自己。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>可能因为一开始只有我和导师两个人扛二十多个RD的测试任务，所以一直没有时间从各个维度去完善质量保障，那一段时间一个项目还没测试完就已经有两个项目在后面排着队，RD都让我的经理给我们加人力，确实没有时间去考虑什么自动化，只要保证项目上线不出问题就已经很不错了。但是这样测试得越久，我自己越来越难以提升，像一个测试机器一样来一个提测就测一个，这根本就不是我自己想要的发展道路。我尝试去向RD要项目源码来看，答复都是拒绝，都是让我去跟RD leader沟通，我tm怎么敢直接跟比我高几个级别的RD leader说我想看源码……导师自己本身对源码丝毫不感兴趣，所以也没帮过我。那时候的测试流程确实很原始，RD发一个提测邮件，导师再开一个测试方案评审会就可以开始测试，很多东西都是一边测试一边沟通，测试完一个项目还没来得及总结一下就下一个，日复一日这样我真的厌倦了，可能这种心情很多新人QA都可以体会到——发现让自己成长的平台并不如一开始想象得那么光鲜亮丽。</p>
<p>新QA leader对于我们的测试工作管得很松，所以后面基本上是我一个人去handle项目测试，多了一些新同学，测试工作也没那么恐怖了，大多数时间完全可以实现每天9点下班，甚至实现了<strong>白天求生存，晚上谋发展</strong>的理想状态。我开始给自己排期更多的时间，以了解项目同时自己积累其他方面的知识，后半年下来慢慢地觉得工作节凑开始走上正规了，在其位谋其职，测试工作当然依然有保证，那是职业道德，但是不能让自己的发展局限于目前的岗位职责，尽可能将自己的能力往上下游蔓延🤔。慢慢地自己对项目的owner精神开始加深，主动跟进项目各种情况，开始考虑项目测试的痛点，深入了解项目的各种细节，也感受到了自己跟以前有不一样的地方。</p>
<p>常常说程序需要健壮需要鲁棒性，后端不能相信前端传过来的东西，agent也不能相信server下发的东西，QA方肯定是需要测试这些边边角角的东西。然而问题是RD很抗拒添加这种健壮性的代码，如果项目赶工期的话可以理解，但是普通迭代并没有忙成什么样而且他们还有时间玩手机刷网页都不愿意改，虽然我有点站着说话不腰疼，但如果我是RD，我肯定愿意把自己的东西做得更好，况且还是别人给自己发现的问题。隔壁组有个93年的同事，传闻是高中毕业就出来打工，做过保安、在电影院做过检票人，最后自学了编程，在<code>吾爱破解</code>里做了一个模块的版主，最后被公司安全部门的人挖过来做开发，简直是励志。他是一个相对的完美主义者，自己写的代码，隔几天想到一种更好的实现方式就会自己重构一遍，跟他合作沟通都很顺畅，这类型的同事永远都是学习榜样。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/office.png" alt="我的工位"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>QA的工作内容相对来说都比较同质化，所有的工作内容无非围绕着项目的质量保障来做，细分包括流程、功能测试、性能测试、监控、自动化等几大类。</p>
<p>项目组里需要QA去推的流程可能包括各类评审会、CI、单测准入、上线会议、迭代分析等，可以看到这些流程其实都是给QA创造更多介入项目的机会。流程能否推动，QA只是一部分的因素，毕竟多数情况QA都不是跟着产品一起走的，是一个流动团队，体系跟RD数不一样的，所以你说的别人不一定听，推流程如果RD leader都不合作，那就不要想了。</p>
<p>功能测试是基础，重点是对项目功能的理解程度和场景的覆盖是否充分，QA做功能测试的目的不是要完整地覆盖各种代码分支，这些应该交由RD保证，我觉得更重要的是发现RD没考虑的逻辑分支和覆盖一些稀有、异常场景，需要的不是100%的覆盖而是针锋相对的用例设计，这样才能用尽量少的时间尽量多地发现问题，当然如果知道具体代码，就可以把预先知道一定pass的多余的用例去掉，这样会节省时间，叫合理的偷懒。QA做的是集成测试，很多时候到手的模块已经是一个整体，而不是一个一个给输入得输出的函数，很多东西会更加模糊，同时由于复杂度的提高，场景也会更加复杂，能否尽可能多覆盖到这些场景，而不是顺着正常数据流程一路走，这才是功能测试的重点（当然正常流程也要测试）。</p>
<p>性能测试我接触的实在太少了，只有寥寥几次，用Jmeter在多台电脑上搭建主从测试环境，一起发请求给sever压测接口，得出一些请求响应时间的数据做简单分析。性能测试我觉得主要是看三个方面，一是你会用多少工具来实现你的性能测试方案，二是你能设计出什么样的性能场景，三是你拿到性能数据之后如何分析得出结论。我感觉我三个方面都很菜，没啥实战经验……</p>
<p>监控、自动化属于一个QA其他层面的能力，一般大公司内部有监控平台可以直接对接，如果没有就要自己想监控方案，确定监控指标，从最原始的进程在不在、进程号有没有改变、cpu内存IO是否过高，到接口是否可用，响应时间是否合理等都是监控的指标。自动化就是业界经常拿来吹嘘的点，说我们的团队对业务做了多少百分比的自动化什么的，自动化也分半自动化和全自动化，半自动化可能是自动生成数据人工验证结果，如生成数据的工具；或者人工生成数据自动验证结果。这写我觉得都不算自动化，因为还是需要人为干预。全自动化在我对接的项目组里是0，也是我19年重点建设的东西，对接不同的端就有不同的自动化，web前端自动化可能要去到像素级别（这个估计业界做得不多），web后端或者server的自动化多数是生成数据发送接口然后验证数据库或者接口返回，agent端的自动化就繁杂一些，需要看具体的业务场景，比如我对接的一个内部macbook安全监控agent就需要通过GUI（操作鼠标点击拖拽）来实现自动化，麻烦多了。不过说到底，自动化的能力是衡量一个QA开发水平的重要指标，毕竟 <code>talk is cheap, show me the code</code>。</p>
<p>更好的QA，那可以是在项目架构上产生影响，审视的不再是项目的单个具体功能而是项目的不同模块如何协调、架构是否能承受未来多少时间内的业务量、是否具备足够的扩展性和维护性……越说越飘，还没到这个境界，</p>
<h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><p>说起源码，我对接的开发组也是够奇葩的，我了解到的很多业务线的QA都能有完整可读的源码权限，而在我这边RD就说代码要保密，QA对于RD来说仿佛只是一个工具，从心智上看RD就觉得QA只是支持作用，他们只应该黑盒测试，有需要就告诉他们业务逻辑而不是代码细节，RD不理解QA为什么非要拿源码看，为什么要参与debug，为什么要了解一个bug从出现到修复等等。QA为什么要这样，答案应该就是一个——更好地改善产品质量。很多东西，没有代码都是空谈，当然我自己有一颗日后转型RD的心，所以一直想多了解具体实现好让自己积累更多的代码基础，这里是有私心存在的，但是更多时候直接原因是QA需要完整知道一个bug的产生到修复甚至到预防的过程，以更好地覆盖测试不同场景，去发现和积累一些之前都没有想到的点，推动RD改进提测质量，从而保证项目质量。不仅很多老RD质疑QA做白盒测试的意义，也有应届跟我一起入职的RD不明白我对项目源码的执着。</p>
<p>对代码观念的改变，有一个小故事。当时测试一个agent端的时候，一个3年的RD让我别看他们项目源码，说他们的代码一点技术含量都没有，他自己都懒得看，让我还不如去<code>github</code>上找代码看，上面的代码强多了。这一个agent端是内网IDC上保证主机安全的，他说，项目真正值钱的地方往往不是代码实现，因为网上一搜多得是，值钱的是这个agent做的安全方案，它解决安全问题的思路和方法，它是如何将一些安全概念以代码的形式落地的。当时我没有理解，但是现在回想简直茅塞顿开，是的，其实最后的代码实现都是业务逻辑 if else for while 那种东西嘛，<strong>关键应该是这个项目背景是什么，安全概念是怎么来的。有什么样的安全意义，概念如何转化成具体可执行的安全方案，方案如何转化成需求，而最后一个环节才是代码实现需求，所以应该花更多精力去了解学习的是前面的环节，而不是最后的代码实现</strong>✨。</p>
<p>要深入理解一个项目，要能做到打破砂锅问到底，不要怕尴尬一定要问清楚，虽然真的会有RD觉得自己问的问题很低级，没办法自己掌握的信息实在很少。一开始接触项目代码的时候一脸懵逼，甚至连语法都看不懂，对接的项目开发语言有php、js、go、object-c、python，也只能硬着头皮快速过一遍语法后直接看，根据自己对项目的了解先从核心的代码模块和业务流程开始看，比较nice的RD会主动跟我讲一遍不同的代码模块和其实现的功能。边看边梳理自己已掌握的信息，最后将一个一个零碎的点整合在一起，整一个项目的业务和架构就会明朗很多。这里特别建议的一点就是根据问题去看代码，要有目的地看才会有收获，可以根据一个典型的bug来看，看bug是如何产生如何修复，足够典型的bug往往会涉及到多个模块之间的交互，这样走下来让人印象十分深刻🤔。</p>
<p>还有一件事一直让我十分惶恐，自从当上了QA之后，我就很少写代码了，或者说成体系写结构化的代码，而不是写那种辅助工作的只有百十来行的零碎的测试工具脚本。既然我心念念未来要转RD，代码能力就不能太弱，相比于天天写代码的RD，我们QA很多时候半年的代码量还不够别人一月多（虽然代码量不能代表代码水平，但至少是开发效率的一个参考指标），毕竟各有分工，这个是无法改变的事实，除非做的是测试工具研发类的测试岗位。我现在的岗位叫测试开发工程师，但是很多时候由于多个项目测试进度的压力，很多想法都来不及去实现，毕竟测试质量是最优先的，其次才是自动化。这个困境过了一年多，在这一个多月里终于开始改变了，因为项目空档期我差不多3周的时间闲下来思考项目测试的痛点，然后去实现我的自动化。我下定决心再也不接那么多测试工作了，相反，将更多的时间投入到开发维护自动化程序中去，虽然只是我的个人代码，没办法体会到团队合作开发的流程，但是我可以用更规范的形式去要求自己完善这个工具，代码库要有相对完备的<code>README.md</code>和<code>CHANGELOG.md</code>，代码要有适当的注释，文件结构和模块要整理封装，有好的想法出来就要去重构替换掉老的代码，即使未来可能并不会有人用，我也要以面向用户的标准去打磨它，把开发、维护这个自动化程序当成是我自己的一次修炼。</p>
<h3 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h3><p>12月份因为需要对上头的上头做一个业务分享会，分享我自己负责的一个相对成熟的项目。为了满足上头的口味，我那小段时间经常拉着将要离职的RD去会议室单独开小灶给我讲这个项目，幸好RD哥们也够义气，给我讲了业务的大流程、每个模块的功能、项目的基础架构、一些以前发现的重点bug和这个项目存在的一些问题，然后我自己再仔细理了理，把几个重要的代码模块通读了一下，在短时间内就对这个几万行代码的项目有了相对清晰的认识，然后再去做个ppt，根据需要自己再理了一下，发现以前自己完全不了解的地方原来是那么那么的多，可见以前的自己眼光是多么地狭隘，这是我这个阶段里一次很宝贵的历练了。</p>
<p>说起ppt，不得不说，我在的组对于汇报工作有着非同一般的“执着”追求，ppt稍微做差一些做得随意一些，就会在会议上受尽指点，跟同组同事精美的ppt一对比，简直惭愧得无法做人。还记得一个已离职的QA同事说，她的ppt能力在现在的公司排不上用场哈哈哈哈。会叫的鸟儿有虫吃，ppt只是一种汇报手段，无论什么途径最终还是要向别人展示自己的工作，要量化指标，要对比，要有逻辑，汇报得清晰才能证明自己的价值。在这个组呆了一年半真可谓把我的汇报能力强行拉了一个等级，还是得多感谢这个组这样疯狂地push我们😓（虽然很多汇报工作明显是多余的）。</p>
<blockquote>
<p>总结一句话，这一年来心态和思维成熟了很多，知道自己想要什么、缺什么、讨厌什么，开始明确自己的追求。</p>
</blockquote>
<h3 id="2019的FLAG"><a href="#2019的FLAG" class="headerlink" title="2019的FLAG"></a><strong><em>2019的FLAG</em></strong></h3><ol>
<li>亟需提升的是代码量，在2019年平均每个月可以产出<code>500行</code>结构化的代码，无论是工作代码还是个人代码都好，那种小脚本小工具不包括在内。</li>
<li>最高优的是<code>在安全方面打好基础</code>，熟悉web安全、Linux安全、汇编和各种工具的使用；另外Linux内核、游戏开发、二进制分析、渗透、病毒分析等需要入门。</li>
<li>一个一直都想点亮的技能就是学会1个web开发框架，自己写一个博客的前后端，或者搞一点有意思的小需求。确定选中<code>flask</code>，自己未来的主力语言应该是python，备选是go。</li>
<li>阅读至少<code>2个</code>大型开源项目的代码（python源码已经在清单之内）。</li>
</ol>
<hr>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>一定要说这一年最大的变化，那就是<strong>爱情</strong>。</p>
<p>自己的生活片段都是记录在微信朋友圈上，18年已经再也没有学校的片段了，自己只身来到深圳，本以为没什么朋友，自己一个人过着普普通通的假期和周末，很偶尔出去跟同事玩一下。结果一个大学时期隔壁班一起上课的同学开始约我出来玩，后面又有一个在深圳宝安中医院实习高中时期非常要好的老乡时不时叫我出去玩，最后是我的女朋友出现在了深圳。我们是小学同学，当时知道她在深圳，我以地主之谊请她出来吃饭，到慢慢爱上她表白，再到现在一起走了快半年的时光，她还会说我们两个人这样走在一起，她觉得很神奇。我自己单身了20多年突然生活里多了一个自己如此在乎的异性，生活也发生了翻天复地的改变。我开始为了引导她往好的方向走，为了让她可以过得更充实，教她python编程，科普她不少知识，给她工作上的建议，监督她改正坏毛病，这么多年来从未有一个人让我如此在意。为了记录我跟她的点滴，我多了写相处日记的习惯，将我们每一次见面都记录下来，从一开始的单纯流水账记录，到慢慢假如越来越多的细节，单篇日记可以四五千字以上，这占用了我大量的时间，极大地压缩了我的学习和锻炼的空间，她也讲了好几次，说我们每次见面其次都是重重复复那些事情而已，没必要一直写日记。然而，我认为这一切的牺牲都是值得的，这样的日记写到我们同居之后就不会再写了，约摸还可以写个小半年吧，到时候我要打印成小册子保存下来留念呢，想想我们以后还可以翻翻，就觉得很甜美~</p>
<p>常常说<code>work life balance</code>，在我的三观里我不认可为了工作把一切东西都放在其次，工作可以放在第一位，但是那只会在特定的时间段里（比如晋升期间）。对于我来说，爱情才是第一位，她才是第一位。她陪我度过了很多我的第一次，比如第一次有人关心我工作晋升情况、第一次有人专门为我庆祝生日（生日送fc游戏机你敢信）、第一次有人为我准备出游计划、第一次有人带着我到处吃吃吃，各种第一次多得我自己都记不清了，那种被她安排得明明白白的感觉真是太棒了……我们都为对方做出了不少积极的改变，我也不再像以前那样不修边幅了哈哈哈哈哈，我们会越来越好的！</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/play_games.png" alt="一起打游戏"></p>
<p>半年来虽然我们没有去过多少什么远方，说得上是出游的，就是国庆假去HK走了一天见了朋友，元旦假一起回广州玩了两天两夜，带她见了我的一个好朋友。本来国庆假是计划去湖南的，由于我们都很懒最后买不到高铁只能放弃，即便这样，每一次出游我们都十分珍惜，在出发前简单定一下行程，去到一个地方再定下一个行程，虽然十分粗糙，但是往往会在路上遇到惊喜。回想起来，正式表白后的一天出来见面她主动给我机会让我签她的手，在情人节那天交换了双方的初吻，还有很多甜蜜的回忆，也有一些争吵和阴暗面，各自都有自己的时间，精神上互相依赖缺不会一直粘着对方。从正式表白那天算起，我就在日历上勾出我们见面的每一天，现在一统计，原来<code>53.4%</code>的日子我们都有见面啊，意料之外的频繁呢~两人一路走来，虽然开心也少不了大大小小的矛盾，哭也哭过不少次，想不到我堂堂男子汉也会哭得稀里哗啦的，半年时间很不容易，倍加珍惜，<font color="red"><strong>感谢你</strong></font>☺️。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/she.png" alt="女王大人"></p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>2017年我在豆瓣上标记读过43本书，而2018年我在豆瓣标记的是看过20部电影，读过8本书。从18年开始我第一次在豆瓣上标记看过的电影，以前的我上是基本都不会去电影院看电影的，认知上就觉得为什么网上有高清资源还非要去电影院花钱看这么傻，然而有她之后就知道区别是什么了。自从恋爱之后，我的周末时间就再也不是单纯的看书学习，更多的是跟她见面约会一起去玩，最后一本书是我在8月份标记的，可以说我已经有4个月没有完整地看完一本书了，尤其是硬核技术书，一直没法坚持完整安心地看一本书，不少书反反复复看了一点就停了然后再看再停，自从毕业以后很多非常硬核的技术书就很难静下来心去啃了，也没有一个成小规模的个人代码学习项目，这让我很不踏实，害怕自己落后于别人😞。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/douban.jpeg" alt="豆瓣读书报告"></p>
<h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>健身习惯也有点变化，今年的最大变化是基本离开了健身房，走上了户外徒手锻炼的道路。10月份我的健身频率开始下降，在11月末脚踝痛风中断了整整4周的锻炼，整个12月份我几乎都没锻炼过！真是意想不到，对于痴迷健身的我竟然会中断锻炼如此之长的时间，手上的老茧都开始掉了。公司饭堂吃得也不好，营养跟不上导致体重还破天荒跌破大学时期最瘦的体重，这一切让我觉得我的力量和肌肉在日益萎缩，还有右肩的反反复复受伤，也使我偶尔不安。唯一值得开心的是，在8-9月份我终于完成了相对完整的<code>muscle up</code>，虽然要靠双腿摆动借力，不过算是有很大突破了，回想以前做个单力臂都要死要活的非常sloppy，自己一直在踏踏实实做引体向上慢慢积累基础力量和熟悉技巧，到最后完成完整动作的那一霎那，真的是有捶打胸口大吼出来的那种兴奋😆。</p>
<p>18年身体最好的状态，7月出差北京参加培训，在酒店的沙雕自拍 。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/body_best_of_2018.png" alt="沙雕自拍"></p>
<h3 id="老家"><a href="#老家" class="headerlink" title="老家"></a>老家</h3><p>2018这一年跟父母之间的关系也有了微妙的升级，明白父母为什么老是会想念我这个独生子（老家小镇独生子真的不多），为什么每次我回家他们都可以这么开心，以前以为自己本身就是个比较逗的人，所以回去后撩他们开心也是很正常的，其实远不止这个原因，最重要还是我是他们儿子的这个身份。每次回家都会和老妈晚上一起在小镇的河边散一次步，聊一聊我未来的打算，解释我为什么不愿意回老家买房子，我未来会在哪里发展定居，我的生活工作感情情况，我对生孩子的看法……每一次这样的对话，都感觉自己给老妈开拓了一些眼界，同时也能感受到老妈一辈子活在小镇，没出过省去过大城市见识的局限性，自己的担子不轻，为了美好的未来自己必须要成为一个相对优秀的人。</p>
<p>自从上了初中就一直寄宿在学校，在老家的朋友越来越少有联系。小学初中高中都是在老家上的，现在每次回到老家，小镇里就是那几个小学同学可以叫出来玩一下，初中同学除了继续成为高中同学的那些人外，全部断了联系（初中就是一段黑历史，宿舍里有个小混混头，把年级其他小混混招过来宿舍聚众吸烟，整天喊打喊杀讲江湖义气，也造就了我不沾烟酒的好品质🙂），高中也只剩下几个比较好的同学会叫出来一起浪。当然让我很欣慰的是，18年过年的时候一部分高中同学终于出来约了一顿晚饭，上一次约是15年了，还是那群比较活跃的人出来见面，大家还是很能聊，都是老样子。</p>
<p>回到老家很多时候需要帮父母干点重活，搬搬扛扛的，还记得高中还是大学的某一次回家，老爸让我扛了一袋很重的大米上楼，后来被老妈痛骂了他一顿说要是我的腰因为扛米扛坏了就绕不过我老爸，emmmmm作为一个初中就开始健身的人，我老妈待我如宝呢……自己一个人没事干的时候就会去镇里小公园锻炼一下，以前还有一点老年人保健器材在那里，勉强可以用来做一下臂屈伸，悬挂收腹等等基本动作，现在公园改造了，啥都没了，除了水泥路🙂。还有就是骑单车（自行车，粤语叫单车），两年多三年前花800收了一辆原价2k的二手Giant，有空就是拼命往深山老林踩，才知道老家虽然落后，但是好就好在自然风光还不错，自己方圆七八公里都踩过了，以前一点方向感都没有，现在脑里有点整合出一张小地图的感觉。特别喜欢在没人的路上狂奔，跟着耳机一震一震的鼓点，感受着从双腿蔓延出来的疲软，大口大口急促热辣地呼吸，真的是feel到自己很实在地活着。</p>
<p><img src="https://gitee.com/zingphoy/img/raw/master/blog_image/bike.jpeg" alt="小路与单车"></p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>18年后半年我几乎脱离了游戏。从小玩红警、CS、魔兽、各类网游，中学玩CF、DNF、各种单机、魔兽dota，大学还常常跟舍友一起魔兽，跟隔壁宿舍的肥韬开黑dota2打到深夜1点多的我，现在竟然对游戏如此佛性。手游玩着我觉得很不舒服，单机游戏越来越吃配置，我大学买的老神舟也跑不动了，关键是没有什么游戏的游戏性让我动心（玩起来还比较high的估计只有COD和Crysis了），还发现自己但凡玩游戏刷手机花的时间多了，会有一种恐惧想要尽快摆脱它们，于是乎这样也就渐渐告别了游戏吧，活得越来越不像个年轻人了，不过却有未来跟妹子一起合作开发点小游戏的想法。</p>
<blockquote>
<p>总结一句话，有了爱情，活得更完整，生活上虽然作了一些牺牲，但是都是为了更好的未来。</p>
</blockquote>
<h3 id="2019的FLAG-1"><a href="#2019的FLAG-1" class="headerlink" title="2019的FLAG"></a><strong><em>2019的FLAG</em></strong></h3><ol>
<li>结束目前奔波操劳的爱情生活，跟她一起同居，再也不用为了见面花时间在路上。</li>
<li>单次<code>pull up</code>达到25个，单次<code>dips</code>达到50个，<code>muscle up</code>脱离腰腿借力，完成<code>free handstand</code>、<code>front level</code>、<code>human flag</code>，体脂降到14%以下；带着她锻炼，让她获得川字腹肌。</li>
<li>豆瓣标记完成至少24本书，其中硬核技术书至少10本。</li>
<li>跟她一起远途出游一次。</li>
<li>工作日我可以12:30前入睡。</li>
<li>祈求痘痘再见😭。</li>
</ol>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个世界上钱不是最重要的，这个大家都知道。亲情爱情生活工作都很重要，但这个还不是最终的源头，最重要的只有一种东西，那就是<strong><em>时间</em></strong>。每一个人可以在各方面都有所不用，唯独相同的就是手上的时间上限，所以，给家人更多交流的时间，给她更多陪伴的时间，给自己的未来更多的学习和锻炼时间，最后的最后，其实都是为了一个更加美好的未来，这些愿望，全部都来源于一颗不甘落后的心❤️。</p>
<p>好在自己还有点自知之明，深知自己水平有多菜，自己大学4年，碍于狭隘见识和浅薄认知，没能把握好这个关键的蜕变时期，前2年半几乎都是做一个乖乖学生，完全束缚在二流学校的三流教学体系里面，只是在最后的1年才知道自己应该干些什么，然而都来不及了。<strong>努力最好的时间是前十年，其次是现在</strong>，B乎上不缺各种鸡血成才例子，别人是可谓下足了功夫吃透苦头才在4-7年内拿到令人羡慕的成就。</p>
<blockquote>
<p>不要用战术上的勤奋来掩盖战略上的懒惰。</p>
</blockquote>
<p>2019年年末再见，稀饭兄dei👋。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
